<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Coding-Zuo</title>
  
  <subtitle>Coding And Studying</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-10-10T01:52:15.076Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Coding-Zuo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>79/130/200/733FloodFill/17/22/784字符串回溯</title>
    <link href="http://example.com/2021/10/10/79-130-200-733FloodFill-17-22-784%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9B%9E%E6%BA%AF/"/>
    <id>http://example.com/2021/10/10/79-130-200-733FloodFill-17-22-784%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9B%9E%E6%BA%AF/</id>
    <published>2021-10-10T01:37:48.000Z</published>
    <updated>2021-10-10T01:52:15.076Z</updated>
    
    <content type="html"><![CDATA[<h1 id="79-130-200-733FloodFill-17-22-784字符串回溯"><a href="#79-130-200-733FloodFill-17-22-784字符串回溯" class="headerlink" title="79/130/200/733FloodFill/17/22/784字符串回溯"></a>79/130/200/733FloodFill/17/22/784字符串回溯</h1><h2 id="Flood-Fill"><a href="#Flood-Fill" class="headerlink" title="Flood Fill"></a>Flood Fill</h2><p>提示：Flood 是「洪水」的意思，Flood Fill 直译是「泛洪填充」的意思，体现了洪水能够从一点开始，迅速填满当前位置附近的地势低的区域。类似的应用还有：PS 软件中的「点一下把这一片区域的颜色都替换掉」，扫雷游戏「点一下打开一大片没有雷的区域」。</p><p>下面这几个问题，思想不难，但是初学的时候代码很不容易写对，并且也很难调试。我们的建议是多写几遍，忘记了就再写一次，参考规范的编写实现（设置 visited 数组，设置方向数组，抽取私有方法），把代码写对。</p><h3 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a><a href="https://leetcode-cn.com/problems/word-search/">79. 单词搜索</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[][] DIRECTIONS = &#123;&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rows;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cols;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[][] visited;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] charArray;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[][] board;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        rows = board.length;</span><br><span class="line">        <span class="keyword">if</span> (rows==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cols = board[<span class="number">0</span>].length;</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.len = word.length();</span><br><span class="line">        <span class="keyword">this</span>.charArray = word.toCharArray();</span><br><span class="line">        <span class="keyword">this</span>.board = board;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cols;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(i, j, <span class="number">0</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x&gt;=<span class="number">0</span> &amp;&amp; x&lt;rows &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;cols;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> begin)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(begin == len-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> board[x][y] == charArray[begin];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(board[x][y] == charArray[begin])&#123;</span><br><span class="line">            visited[x][y] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] direction:DIRECTIONS)&#123;</span><br><span class="line">                <span class="keyword">int</span> newX = x + direction[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> newY = y + direction[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(inArea(newX,newY) &amp;&amp; !visited[newX][newY])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dfs(newX, newY, begin+<span class="number">1</span>))&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            visited[x][y] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><p>偏移量数组在二维平面内是经常使用的，可以把它的设置当做一个技巧，并且在这个问题中，偏移量数组内的 4 个偏移的顺序无关紧要；<br>说明：类似使用这个技巧的问题还有：「力扣」第 130 题：被围绕的区域、「力扣」第 200 题：岛屿数量。</p><p>对于这种搜索算法，我认为理解 DFS 和状态重置并不难，代码编写也相对固定，难在代码的编写和细节的处理，建议多次编写，自己多总结多思考，把自己遇到的坑记下。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;79-130-200-733FloodFill-17-22-784字符串回溯&quot;&gt;&lt;a href=&quot;#79-130-200-733FloodFill-17-22-784字符串回溯&quot; class=&quot;headerlink&quot; title=&quot;79/130/200/733Fl</summary>
      
    
    
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>只用一行代码能提高模型表现吗?</title>
    <link href="http://example.com/2021/10/09/%E5%8F%AA%E7%94%A8%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E8%83%BD%E6%8F%90%E9%AB%98%E6%A8%A1%E5%9E%8B%E8%A1%A8%E7%8E%B0%E5%90%97?/"/>
    <id>http://example.com/2021/10/09/%E5%8F%AA%E7%94%A8%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E8%83%BD%E6%8F%90%E9%AB%98%E6%A8%A1%E5%9E%8B%E8%A1%A8%E7%8E%B0%E5%90%97?/</id>
    <published>2021-10-09T11:13:48.000Z</published>
    <updated>2021-10-10T14:57:43.758Z</updated>
    
    <content type="html"><![CDATA[<h1 id="只用一行代码能提高模型表现吗"><a href="#只用一行代码能提高模型表现吗" class="headerlink" title="只用一行代码能提高模型表现吗?"></a>只用一行代码能提高模型表现吗?</h1><p>一行代码能做什么，有的人能发顶会，而有的人…</p><p>相信大家在训练模型的时候都会遇到一个现象，训练集损失降到一定的值之后，验证集的损失就开始上升了，在实验中一般奇怪的是准确率还跟着上升。这是为什么？如下图所示：</p><p><img src="https://z3.ax1x.com/2021/10/09/5kiiNV.png" alt=""></p><p>先看图(a)，是一个正常的训练过程，对于阶段A，随着training loss的降低，test loss也会 跟着降低;</p><p>但是到阶段B后，我们继续在训练集上训练，会让test loss上升。我们通常认为这是过拟合了，因为泛化误差变大了。</p><p>图 (b) 是ICML2020上《Do We Need Zero Training Loss After Achieving Zero Training Error》提出的flooding方法。这是一种使训练损失在一个小常量附近浮动的方法，以防止训练损失趋近于零 (这也是flooding的约束假设)。</p><p>为什么要防止训练损失趋近于0呢？</p><p>如果我们在模型已经记住了训练数据，完全没有错误的情况下仍继续训练，训练损失可以很容易地变得(接近)零，特别是对于过度参数化的模型。我们的模型其实就是个函数拟合器，在训练集上拟合的太好就容易发生过拟合。</p><p>经过推导（下文），flooding其实也和正则化的一些方法一样，通过各种方式避免训练过多。正则化方法可以被认为是间接控制训练损失的方法，通过引入额外的约束假设。</p><p>这里科普一下花书对于正则化的官方定义：</p><blockquote><p>凡是可以减少泛化误差(过拟合) 而不是减少训练误差的方法——正则化方法。</p></blockquote><p>其实对抗训练从理论上也是一种正则化方法，而正则化其实也可以理解成我们在求解最优化问题中的约束条件。我们通常希望将模型约束到一个较为”平坦“的损失，能够使得模型鲁棒性、泛化性更好。</p><p>从svm的角度来思考这个问题。对于一个线性可分的二分类问题，有无数条分类面能将其分开，而svm是去挑选能满足“最大间隔”的分类器。从另一个角度来理解是，越平坦的损失，是不是能越尽可能的将不同类给分开，因为样本进行些许扰动，损失的变化不会太大，相当于进行细微扰动后的样本也不会被分类到另一类去。</p><h2 id="flooding-方法分析"><a href="#flooding-方法分析" class="headerlink" title="flooding 方法分析"></a>flooding 方法分析</h2><p>论文其实就一行代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">logits = model(x)</span><br><span class="line">loss = criterion(logits, y)</span><br><span class="line">loss = (loss - b).<span class="built_in">abs</span>() + b <span class="comment"># This is it!</span></span><br><span class="line">optimizer.zero_grad()</span><br><span class="line">loss.backward()</span><br><span class="line">optimizer.step()</span><br></pre></td></tr></table></figure><p>泛洪是直接解决训练损失变为(接近)零的问题。当训练损失达到合理的小值时，泛洪故意阻止训练损失的进一步减少。</p><p>设原来的损失函数为 $\mathcal{L}(\theta)$ ，改为 $\tilde{\mathcal{L}}(\theta)$:</p><script type="math/tex; mode=display">\tilde{\mathcal{L}}(\theta) =  |\mathcal{L}(\theta) - b| + b</script><p>其中 b 是超参数阈值</p><p>当 $\mathcal{L}(\theta) &gt; b$ 时， $ \tilde{\mathcal{L}}(\theta) =\mathcal{L}(\theta)$, 这个时候和正常他梯度下降无异；</p><p>当$\mathcal{L}(\theta) &lt;b$ 时， $ \tilde{\mathcal{L}}= 2b - \mathcal{L}(\theta)$ 变成了梯度上升了。</p><blockquote><p>当training loss大于一个阈值（flood level）时，进行正常的梯度下降；当training loss低于阈值时，会反过来进行梯度上升，让training loss保持在一个阈值附近，让模型持续进行“random walk”，并期望模型能被优化到一个平坦的损失区域，这样发现test loss进行了double decent！一个简单的理解是，这和early stop类的方法类似，防止参数被优化到一个不好的极小值出不来。</p></blockquote><p>这里借用 <a href="https://kexue.fm/archives/7643">我们真的需要把训练集的损失降低到零吗？</a> 的推导</p><p>当损失函数达到 b 之后，训练流程大概就是在交替执行梯度下降和梯度上升。直观想的话，感觉一步上升一步下降，似乎刚好抵消了。事实真的如此吗？我们来算一下看看。假设先下降一步后上升一步，学习率为 $\epsilon$，那么：</p><script type="math/tex; mode=display">\theta_n = \theta_{n-1} - \epsilon g(\theta_{n-1}) \ ,\ \ \theta_{n+1} = \theta_n + \epsilon g(\theta_n)</script><p>其中 $g(\theta) = \nabla_{\theta} \mathcal{L}(\theta)$ , 现在有：</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}\theta_{n+1} =&\, \theta_{n-1} - \varepsilon g(\theta_{n-1}) + \varepsilon g\big(\theta_{n-1} - \varepsilon g(\theta_{n-1})\big)\\ \approx&\,\theta_{n-1} - \varepsilon g(\theta_{n-1}) + \varepsilon \big(g(\theta_{n-1}) - \varepsilon \nabla_{\theta} g(\theta_{n-1}) g(\theta_{n-1})\big)\\ =&\,\theta_{n-1} - \frac{\varepsilon^2}{2}\nabla_{\theta}\Vert g(\theta_{n-1})\Vert^2 \end{aligned}\end{equation}</script><p>近似那一步是使用了泰勒展式对损失函数进行近似展开，最终的结果就是相当于损失函数为梯度惩罚 $\Vert g(\theta)\Vert^2=\Vert\nabla<em>{\theta}\mathcal{L}(\theta)\Vert^2$、学习率为 $\frac{\varepsilon^2}{2}$ 的梯度下降。更妙的是，改为“先上升再下降”，其表达式依然是一样的（这不禁让我想起“先升价10%再降价10%”和“先降价10%再升价10%”的故事）。因此，平均而言，Flooding对损失函数的改动，相当于在保证了损失函数足够小之后去最小化 $\Vert\nabla</em>{\theta}\mathcal{L}(\theta)\Vert^2$，也就是推动参数往更平稳的区域走，这通常能提供提高泛化性能（更好地抵抗扰动），因此一定程度上就能解释Flooding其作用的原因了。</p><p>本质上来讲，这跟往参数里边加入随机扰动、对抗训练等也没什么差别，只不过这里是保证了损失足够小后再加扰动。读者可以参考<a href="https://kexue.fm/archives/7466">《泛化性乱弹：从随机噪声、梯度惩罚到虚拟对抗训练》</a>了解相关内容，也可以参考“圣经”《深度学习》第二部分第七章的“正则化”一节。</p><h2 id="关于-b-的选择"><a href="#关于-b-的选择" class="headerlink" title="关于 b 的选择"></a>关于 b 的选择</h2><p> b 的选择，原论文说 b 的选择是一个暴力迭代的过程，需要多次尝试</p><blockquote><p> The flood level is chosen from $b\in {0, 0.01,0.02,…,0.50}$</p></blockquote><p>脑洞：b 无非就是决定什么时候开始交替训练罢了，那如果我们从一开始就用不同的学习率进行交替训练呢？也就是自始自终都执行</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}&\theta_n = \theta_{n-1} - \varepsilon_1 g(\theta_{n-1})\\ &\theta_{n+1} = \theta_n + \varepsilon_2 g(\theta_n) \end{aligned}\end{equation}</script><p>其中 $\varepsilon_1&gt; \varepsilon_2$，这样我们就把 b 去掉了（引入了 $ \varepsilon_1, \varepsilon_2$ 的选择，天下没有免费的午餐）。重复上述近似展开，我们就得到</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned} \theta_{n+1} =& \, \theta_{n-1} - \varepsilon_1g(\theta_{n-1})+\varepsilon_2g(\theta_{n-1} - \varepsilon_1g(\theta_{n-1}))\\\approx&\, \theta_{n-1} - \varepsilon_1g(\theta_{n-1}) + \varepsilon_2(g(\theta_{n-1}) - \varepsilon_1\nabla_\theta g(\theta_{n-1})g(\theta_{n-1}))\\=&\, \theta_{n-1} - (\varepsilon_1 - \varepsilon_2) g(\theta_{n-1}) - \frac{\varepsilon_1\varepsilon_2}{2}\nabla_{\theta}\Vert g(\theta_{n-1})\Vert^2\\ =&\,\theta_{n-1} - (\varepsilon_1 - \varepsilon_2)\nabla_{\theta}\left[\mathcal{L}(\theta_{n-1}) + \frac{\varepsilon_1\varepsilon_2}{2(\varepsilon_1 - \varepsilon_2)}\Vert \nabla_{\theta}\mathcal{L}(\theta_{n-1})\Vert^2\right] \end{aligned}\end{equation}</script><p>这就相当于自始自终都在用学习率 $\varepsilon<em>1-\varepsilon_2$ 来优化损失函数 $\mathcal {L}(\theta) + \frac {\varepsilon_1\varepsilon_2}{2 (\varepsilon_1 - \varepsilon_2)}\Vert\nabla</em>{\theta}\mathcal {L}(\theta)\Vert^2$ 也就是说一开始就把梯度惩罚给加了进去，这样能提升模型的泛化性能吗？<a href="http://www.danielpovey.com/files/2017_interspeech_backstitch.pdf">《Backstitch: Counteracting Finite-sample Bias via Negative Steps》</a>里边指出这种做法在语音识别上是有效的，请读者自行测试甄别。</p><p>这种做法在这篇博客上做了尝试，可能验证loss会降的更低一点，但具体得分情况还得自己尝试。<a href="https://wmathor.com/index.php/archives/1551/">我们真的需要把训练集的损失降到零吗？</a></p><h2 id="实验测试"><a href="#实验测试" class="headerlink" title="实验测试"></a>实验测试</h2><p>在第五届达观杯竞赛中使用的BERT模型，进行了实验。原论文的实验配合Eearly Stop 和 Weight decay 一起使用效果较好。重要的要花时间去调的是b的取值，初始的b值一般设为 验证集loss开始上扬的值的一半。</p><p>在我的实验中发现，在预训练后的bert模型加上dice loss之后，验证集loss上扬的情况就不存在了。但是预训练后的bert加上cross entropy还是会上扬。而未经过预训练的bert无论是在dice loss还是cross entropy上都会上扬。分析背后的原因可能有二：</p><ul><li>预训练后的bert模型表现更加稳定，对数据有一定的认识。</li><li>cross entropy对每个样本都一视同仁，不管当前样本是简单还是复杂。当简单样本有很多时，模型训练就会被这些简单的样本占据，使得模型难以从复杂样本中学习，而dice loss一旦模型正确分类当前样本（刚刚过0.5），就会使模型更少关注它，而不是像交叉熵那样，鼓励模型迫近0或1这两个点。这就能有效避免模型训练受到简单样本的支配，同时也防止了过拟合。</li></ul><h3 id="无flooding的情况下"><a href="#无flooding的情况下" class="headerlink" title="无flooding的情况下"></a>无flooding的情况下</h3><p>预训练后的bert+dice loss 的情况如下图所示。</p><p><img src="https://z3.ax1x.com/2021/10/10/5Ah6FP.png" alt=""></p><p>预训练后的bert + cross entropy，依旧上扬但相比下一个图未经预训练bert的情况要好一些。</p><p><img src="https://z3.ax1x.com/2021/10/10/5ETvN9.png" alt=""></p><p>未经预训练的bert+cross entropy</p><p><img src="https://z3.ax1x.com/2021/10/10/5EIsUA.png" alt=""></p><h3 id="经过flooding后"><a href="#经过flooding后" class="headerlink" title="经过flooding后"></a>经过flooding后</h3><p>No_pretrain bert/ cross entropy/  flooding b=0.5/ weight decy=0.01/ early patience=12 相比于上图验证集的loss已经不在无止境的上扬了。在下图的15到20step之间train的loss也不是和上图一样一路走低，而是出现了波动，这和论文的预期一致。</p><p><img src="https://z3.ax1x.com/2021/10/10/5ECkIP.png" alt=""></p><p>未经预训练后的bert b=0.5  dice loss</p><p><img src="https://z3.ax1x.com/2021/10/10/5EIvb4.png" alt=""></p><p>未经预训练后的bert，b=1.0 ,cross entropy</p><p><img src="https://i.loli.net/2021/10/10/DfcyQP3n5oqFLze.png" alt=""></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>flooding确实可以缓解验证集损失上扬的现象，而且本质还是个正则化的功能。至于具体效果有多大，是好是坏还是要根据具体任务去调试b的取值。</p><p>不过我的实验可以证明  预训练后的bert 和 dice loss 确实是可以让模型避免出现类似过拟合的现象。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://wmathor.com/index.php/archives/1551/">我们真的需要把训练集的损失降到零吗？</a></p><p><a href="https://zhuanlan.zhihu.com/p/163676138">【论文】一行代码发一篇ICML？</a></p><p><a href="https://kexue.fm/archives/7643">我们真的需要把训练集的损失降低到零吗？</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;只用一行代码能提高模型表现吗&quot;&gt;&lt;a href=&quot;#只用一行代码能提高模型表现吗&quot; class=&quot;headerlink&quot; title=&quot;只用一行代码能提高模型表现吗?&quot;&gt;&lt;/a&gt;只用一行代码能提高模型表现吗?&lt;/h1&gt;&lt;p&gt;一行代码能做什么，有的人能发顶会，而有的</summary>
      
    
    
    
    
    <category term="ML&amp;DL" scheme="http://example.com/tags/ML-DL/"/>
    
  </entry>
  
  <entry>
    <title>Meta-Learning Representations for Continual Learning</title>
    <link href="http://example.com/2021/10/09/Meta-Learning-Representations-for-Continual-Learning/"/>
    <id>http://example.com/2021/10/09/Meta-Learning-Representations-for-Continual-Learning/</id>
    <published>2021-10-09T07:11:17.000Z</published>
    <updated>2021-10-10T03:48:27.322Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Meta-Learning-Representations-for-Continual-Learning"><a href="#Meta-Learning-Representations-for-Continual-Learning" class="headerlink" title="Meta-Learning Representations for Continual Learning"></a>Meta-Learning Representations for Continual Learning</h1><p>持续学习的代理应该能够在现有知识的基础上快速学习新数据，同时最大限度地减少遗忘。</p><p>目前基于神经网络函数逼近器的智能系统 很容易遗忘，而且很少经过训练来促进未来的学习。这种糟糕行为的一个原因是，他们从没有为这两个目标明确训练的表征中学习。</p><p>本文提出了OML，它的目标是通过学习表征来直接最小化灾难性的干扰，加速未来的学习，并且在连续学习中对在线更新下的遗忘具有健壮性。</p><p>证明了学习自然稀疏表示是可能的，这对于在线更新更有效。此外，该算法是对现有的连续学习策略(如MER和GEM)的补充。</p><blockquote><p>有经验的程序员学习一门新的编程语言比以前从未编程的人要快得多，而且不需要忘记旧的语言来学习新的语言。</p></blockquote><p>在这项工作中，显式地学习一种持续学习的表示法，以避免干扰并促进未来的学习。设计一个元目标，它使用灾难性干扰作为训练信号，通过在线更新直接优化。目标是学习一种表示，以便模型在 meta-test 时使用的随机在线更新总体上提高其预测的准确性。</p><h2 id="Problem-Formulation"><a href="#Problem-Formulation" class="headerlink" title="Problem Formulation"></a>Problem Formulation</h2><p>Continual Learning Prediction (CLP)问题由无休止的样本流组成</p><script type="math/tex; mode=display">T = (X_1,Y_1) ,(X_2,Y_2) ,..., (X_t,Y_t) ...</script><p>随机向量 $Y<em>t$ 根据未知分布 $p(Y|X_t)$抽样。我们假设过程 $X_1,X_2,..,X_t,…$有一个边际分布 $\mu ：X \to [0,\infty)$，它反映了每个输入被观察到的频率。这种假设允许各种相关序列。例如，可以从潜在依赖于过去变量 $X</em>{t-1}$ 和 $X_{t-2}$ 的分布中采样 $X_t$。然而目标 $Y_t$ 仅依赖于 $X_t$ , 而不依赖于过去的 $X_i$。</p><p>定义 $S<em>k = (X</em>{j+1}, Y<em>{j+1}),(X</em>{j+2}, Y<em>{j+2}) ,…,(X</em>{j+k}, Y_{j+k}) $ 为从CLP问题 $T$ 中抽样的长度为 $k$ 的随机轨迹。</p><p>最后，$p(S_k|T)$ 给出了可以从问题 $T$ 中抽样的所有长度为 $k$ 的轨迹上的分布。</p><p>对于给定的CLP问题，我们的目标是学习一个函数 $f_{W,\theta}$ 它可以预测给定 $X_t$ 的 $Y_t$。更具体地说，设 $l:Y\times Y \to R$ 是将预测 $\hat y \in Y$ 和目标 $y$ 之间的损失定义为 $l(\hat y,y)$的函数。</p><p>如果假设输入 $X$ 与某个密度 $\mu$ 成正比： $X \to [0,\infty)$, 那么我们希望最小化目标：</p><script type="math/tex; mode=display">L_{CLP}(W,\theta) = E[l(f_{W,\theta}(X), Y)] = \int \left[ \int l(f_{W,\theta}(x), y) p(y|x) dy  \right] \mu(x) dx</script><p>其中 $W,\theta$ 代表一系列参数，是更新和最小化的目标。</p><p>为了最小化 $L_{CLP}$，我们将自己限制在通过从 $p(S_k|T)$ 采样的单个 $k$ 长度轨迹上的在线更新来学习。</p><p>这改变了标准 iid 设置中的学习问题——模型看到长度为 k 的相关样本的单一轨迹，而不是直接从 $p(x, y) = p(y|x)\mu(x)$ 中采样。当简单地为IID设置应用标准算法时，此修改可能会引起重大问题。相反，我们需要设计考虑这种相关性的算法。</p><p>这个公式可以表示各种连续问题。 一个例子是在线回归问题，例如在给定当前位置的情况下预测机器人的下一个空间位置； 另一个是现有的增量分类基准。 CLP 公式还允许依赖于最近 m 次观测的历史记录的目标 $Y<em>t$。 这可以通过将每个 $X_t$ 定义为最后 m 个观测值来获得。 $X_t$ 和 $X</em>{t-1}$ 之间的重叠不违反对相关输入序列的假设。 最后，强化学习中的预测问题——从一个状态预测策略的值——可以通过将输入 $X_t$ 视为状态和要采样的目标返回或引导目标来表示。</p><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><p>端到端训练的神经网络在使用从 $p(S_k|T)$ 采样的单个轨迹来最小化CLP loss 方面不是有效的，原因有两个。</p><p>首先，它们的样本效率极低，需要多个epoch的训练才能收敛到合理的解决方案。</p><p>其次，当在线学习相关数据流时，他们会受到灾难性的干扰。</p><p>元学习可以有效地提高神经网络的样本效率。但元学习模型初始化，这种归纳偏差不足以解决灾难性的干扰问题。</p><p>经验发现，学习编码器比只学习初始化的性能要好得多，此外，元学习优化问题在学习编码器时表现更好(对超参数不敏感，收敛速度更快)。这种差异的一种解释是，当在高度相关的数据流上学习时，全局且贪婪的更新算法(例如梯度下降)将贪婪地改变神经网络的初始层相对于当前样本的权重。初始层中的这种变化将干扰模型的过去知识。因此，初始化不是增量学习的有效归纳偏差。另一方面，当学习编码器 $\phi_{\theta}$ 时，神经网络可以学习使得更新不那么全局的高度稀疏表示(因为连接到零的特征的权重保持不变)。</p><p>为了将神经网络应用于问题的求解，作者提出了一种元学习函数 $\phi_{\theta} (X)$  ——一种由 θ 参数化的深度表示学习网络(RLN)—从$X \to R^{d}$中学习。然后学习另一个来自 $R^d\to Y$的函数 $g_W$，称为预测学习网络(PLN)。</p><p>两个函数的组合为 $f<em>{W,\theta }(x) = g</em>{W}(\phi_{\theta} (X))$</p><p><img src="https://z3.ax1x.com/2021/10/10/5APRG8.png" alt=""></p><p>将 $\theta$ 视为通过最小化元目标学习的元参数，然后在元测试时固定。在学习 $\theta $ 之后，我们从 $R^d\to Y $ 学习 $g_W $，用于从单个轨迹 $S $ 使用单次传递全在线的SGD更新解决CLP问题。</p><p>对于元训练，假设由 $p(T)$ 给出的CLP问题上的分布。</p><p>OML的目标函数为 ：</p><script type="math/tex; mode=display">min_{W,\theta} \sum_{T_i \sim p(T)} OML(W,\theta) = \sum_{T_i\sim P(T)} \sum_{S_k^j\sim p(S_k|T_i)} [ L_{CLP_i} (U(W,\theta, S_k^j))]</script><p>其中 $S<em>k^j = (X</em>{j+1}^i,Y<em>{j+1}^i),(X</em>{j+2}^i, Y<em>{j+2}^i),…,(X</em>{j+k}^i,Y_{j+k}^i)$ , </p><p>$U(W<em>t, \theta, S_k^j) =(W</em>{t+k},\theta)$ 表示一个更新 $W_{t+k}$ 是k步SGD后的权重向量</p><p>U 中第 $j$ 步更新 在样本 $(X<em>{t+j}^i, Y</em>{t+j}^i)$ 使用参数  $W<em>{t+j-1}, \theta$ , 得到 $(W</em>{t+j},\theta)$ </p><p>MAML-Rep和OML目标可以分别实现为算法1和算法2，两者之间的主要区别以蓝色突出显示:</p><p><img src="https://z3.ax1x.com/2021/10/10/5AkLJP.png" alt=""></p><p>注意，MAML-Rep使用完整批数据 $S_k$ 进行 $l$ 次内部更新(其中 $l $ 是超参数)，而OML使用 $S_k$ 中的一个数据点进行一次更新。这使得OML可以考虑在线持续学习的影响，例如灾难性的遗忘。</p><p>OML 目标的目的是学习适合在线持续学习的表示。 为了说明什么将构成持续学习的有效表示，假设我们有三个输入集群，它们具有显着不同的 $p(Y |x)$，对应于 $p<em>1$、$p_2$ 和 $p_3$。 对于固定的二维表示 $\phi</em>{\theta} : X \to R^2$，我们可以考虑由线性模型给出的解 $W\in R^2$ 的线性模型，该模型为每个 $p_i$ 提供等效准确的解。</p><p>这三个过程在图2中的 $W\in  R^2$参数空间中描述为三条不同颜色的线。</p><p><img src="https://z3.ax1x.com/2021/10/10/5AZfkd.png" alt=""></p><p>对于目标是由三个不同的分布 $p_1(Y|x)$ 、$p_2(Y|x)$ 和 $p_3(Y|x)$生成的问题，研究了表示对连续学习的影响。</p><p>目的是通过对来自三个分布的样本进行在线学习，找到一个对所有三个分布都有效的参数向量 W。 对于两种不同的表示，这些流形及其交集可能看起来非常不同。 直觉是，当流形平行（允许正泛化）或正交（避免干扰）时，来自 W 的在线更新更有效。 产生这种流形的表示不太可能自然出现。 相反，我们必须明确地找到它。 通过考虑在线持续学习的影响，OML 目标针对这种表示进行了优化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Meta-Learning-Representations-for-Continual-Learning&quot;&gt;&lt;a href=&quot;#Meta-Learning-Representations-for-Continual-Learning&quot; class=&quot;headerl</summary>
      
    
    
    
    
    <category term="context detection" scheme="http://example.com/tags/context-detection/"/>
    
  </entry>
  
  <entry>
    <title>Continual Lifelong Learning in Natural Language Processing: A Survey</title>
    <link href="http://example.com/2021/10/09/Continual-Lifelong-Learning-in-Natural-Language-Processing-A-Survey/"/>
    <id>http://example.com/2021/10/09/Continual-Lifelong-Learning-in-Natural-Language-Processing-A-Survey/</id>
    <published>2021-10-09T02:04:28.000Z</published>
    <updated>2021-10-09T05:17:06.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Continual-Lifelong-Learning-in-Natural-Language-Processing-A-Survey"><a href="#Continual-Lifelong-Learning-in-Natural-Language-Processing-A-Survey" class="headerlink" title="Continual Lifelong Learning in Natural Language Processing: A Survey"></a>Continual Lifelong Learning in Natural Language Processing: A Survey</h1><p>与计算机视觉或机器人技术相反，NLP领域中的CL仍处于初级阶段</p><p>持续学习 (CL) 旨在使信息系统能够跨时间从连续数据流中学习。然而，现有的深度学习体系结构很难在不遗忘以前获得的知识的情况下学习新任务。此外，由于自然语言是模棱两可的，CL对语言学习尤其具有挑战性：它是离散的，组合的，意思是上下文相关的。</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>catastrophic forgetting (CF) or catastrophic interference</p><p>由于数据分布的变化，模型会随着时间的推移而变得不那么精确—这一现象称为概念漂移。现有的方法不能有效地保留以前学到的知识并同时适应新的信息。</p><p>最简单的，从头开始重新训练模型以适应新的任务(或新的数据分布)，是昂贵和耗时的，容量饱和和模型扩展问题也扩大了这个问题。</p><p>具体地说，参数模型在学习具有不同分布的数据样本或通过一系列任务进行处理时，最终到达不能存储更多知识的点-即其表示能力接近极限。在这一点上，要么扩展了模型的容量，要么应用了选择性遗忘（可能会导致性能下降）。后一种选择可能导致对新任务(或数据分布)的预测精度恶化或忘记以前获得的知识。</p><p>这一约束是由CL的一个定义特性支撑的，即所谓的稳定性-可塑性困境。具体地说，该现象考虑了模型试图在其稳定性(保留先前知识的能力)和可塑性(适应新知识的能力)之间取得平衡。</p><h2 id="Learning-Paradigms"><a href="#Learning-Paradigms" class="headerlink" title="Learning Paradigms"></a>Learning Paradigms</h2><p>目标是从大量任务 $T$ 中顺序学习模型 $f：X\times T\to Y$。</p><p>该模型在实例 $(x<em>i，y_i)$ 上训练，$x_i \in X</em>{t<em>i}$ 是输入特征向量，$y_i \in y</em>{t<em>i}$ 是目标向量，$t_i \in T$表示任务描述符(在最简单的情况下 $t_i=i$)，其中 $i\in Z$。目标是最大化任务 $T_i$  处的函数 $f$ (由 $θ\in R$ 参数化)，同时最小化任务 $T_1,…,T</em>{i-1}$ 的CF。</p><p>CL所需的性质 :</p><ul><li>Knowledge retention : 模型不容易发生灾难性的遗忘。</li><li>Forward transfer : 模型在重用从先前任务中获得的知识的同时学习新的任务。</li><li>Backward transfer :  模型在学习一项新任务后，在以前的任务上取得了更好的性能。</li><li>On-line learning : 模型从连续数据流中学习。</li><li>No task boundaries : 模型无需明确的任务或数据边界即可学习。</li><li>Fixed model capacity : 无论任务的数量和数据流的长度如何，内存大小都是恒定的。</li></ul><p>许多模型仅以有监督的方式使用大的标签数据集进行训练，因此它们不会暴露在涉及很few-shot、无监督或自监督学习的更具挑战性的情况下。</p><h3 id="Related-Machine-Learning-Paradigms"><a href="#Related-Machine-Learning-Paradigms" class="headerlink" title="Related Machine Learning Paradigms"></a>Related Machine Learning Paradigms</h3><div class="table-container"><table><thead><tr><th><em>Paradigm</em></th><th><em>Definition</em></th><th style="text-align:left"><em>Properties</em></th></tr></thead><tbody><tr><td>Transfer learning</td><td>将知识从源任务/域转移到目标任务/域<br/>以提高目标任务的性能。</td><td style="text-align:left">+ forward transfer<br/> – no backward transfer<br/> – no knowledge retention <br/> – task boundaries<br/> – off-line learning</td></tr><tr><td>Multi-task learning</td><td>联合学习多个相关任务，利用参数共享，<br/>提高所有任务的泛化能力。</td><td style="text-align:left">+ positive transfer <br/>– negative transfer <br/>– task boundaries <br/>– off-line learning</td></tr><tr><td>Meta-learning</td><td>Learning to learn学习一般知识，<br/>给出一小串训练样本和许多任务，并快速适应一项新任务。</td><td style="text-align:left">+ forward transfer<br/> – no backward transfer<br/> – no knowledge retention <br/>– off-line learning</td></tr><tr><td>Curriculum learning</td><td>从训练样本中学习按有意义的顺序排列-<br/>任务或数据难度逐渐增加。</td><td style="text-align:left">+ forward transfer<br/> + backward transfer<br/> + knowledge retention<br/> – task boundaries<br/> – off-line learning</td></tr><tr><td>On-line learning</td><td>通过按顺序提供的训练示例的连续流进行学习。<br/>体验由于非I.I.D.的数据造成的概念漂移。</td><td style="text-align:left">+ on-line learning<br/> + forward transfer<br/> – no backward transfer<br/> – no knowledge retention<br/>– single task/domain</td></tr><tr><td>On-the-job learning</td><td>发现新任务，学习并适应。<br/>On-the-job learning 是在一个开放的环境中进行的，<br/>它涉及到与人和环境的互动。这要归功于CL方法家族。</td><td style="text-align:left">+ on-line learning<br/> + forward transfer<br/> + backward transfer<br/> + knowledge retention <br/>+ no task boundaries <br/>+ open-world learning<br/> – interactive learning</td></tr></tbody></table></div><h3 id="Approaches-to-Continual-Learning"><a href="#Approaches-to-Continual-Learning" class="headerlink" title="Approaches to Continual Learning"></a>Approaches to Continual Learning</h3><p>Rehearsal 、regularization、architectural methods</p><p>纯来自NLP领域的模型数量相当有限。</p><h4 id="Rehearsal"><a href="#Rehearsal" class="headerlink" title="Rehearsal"></a>Rehearsal</h4><p>依靠保留以前任务中的一些训练样本，以便稍后可以将它们显示给手头的任务。</p><p>iCaRL 由于每个任务都保留训练样本，并在学习模型时定期重放，因此模型的计算和内存需求随着任务数量的增加而成比例增加。为了减少存储，建议使用 latent replay(Pellegrini等人，2019年)或 pseudo-rehearsal(Robins，1995)方法。</p><p>Pseudo-rehearsal methods 不使用memory中的训练样本，而是通过知道先前任务样本的概率分布来生成样本。方法包括生成性自动编码器和基于生成性对抗网络的模型。</p><h4 id="regularization"><a href="#regularization" class="headerlink" title="regularization"></a>regularization</h4><p>是依赖于固定模型容量和附加损失项的单模型方法，这有助于在学习后续任务或数据分布的同时巩固知识。例如，Elastic Weight Consolidation(EWC)通过损失正则化来减少遗忘；换句话说，它减缓了对之前任务重要的参数的学习。</p><p>Memory method 是正则化方法的特例，可分为两组：synaptic regularization 和 episodic memory (A-GEM、MER、MbPA++) 前一种方法集中于通过以防止改变先前学习的模型参数的方式调整学习率来减少对巩固知识的干扰。而后者存储来自先前看到的数据的训练样本，这些样本稍后被排练以允许学习新的类别。重要的是，梯度情节记忆(GEM)允许正向后转移，并防止过去任务的损失增加。</p><p>MBPA++进行稀疏经验回放和局部适应。学者们声称，MBPA++的训练速度比A-GEM快，训练它的时间并不比编解码器模型长。虽然这是可能的，因为稀疏的体验回放，但MBPA++需要额外的内存。</p><p>Knowledge distillation methods 与情景记忆方法非常相似，但与GEM不同的是，它们使过去任务中的预测保持不变。具体地说，它是一类通过依赖从大型网络模型(教师)到新的、较小的网络(学生)的知识转移来缓解CF的方法。其基本思想是，学生模型学习生成对教师模型的预测。</p><h4 id="architectural"><a href="#architectural" class="headerlink" title="architectural"></a>architectural</h4><p>通过将模块化更改应用于网络架构并引入特定于任务的参数来防止遗忘。通常，以前的任务参数保持固定或屏蔽。此外，新的层通常是动态注入的，以使用附加模块来扩充模型，以适应新的任务。</p><p>Progressive Networks (PNN）以及它们的改进版本 Dynamically Expandable Network (DEN）Reinforced Continual Learning (RCL）这些都是突出的例子。这些策略的主要缺点是参数数量大幅增加。</p><p>与PNN类似，BatchEnsemble(2020)也不受CF的影响，此外，由于只训练快速权重，它支持任务的并行排列，并且比PNN消耗更少的内存。</p><p>同样，适配器模块旨在克服大量参数的问题。 它们充当具有少量参数的附加网络层，可即时重新配置原始网络 对于目标任务，同时保持原始网络的参数不变并在不同任务之间共享。</p><h2 id="Continual-Learning-in-NLP-Tasks"><a href="#Continual-Learning-in-NLP-Tasks" class="headerlink" title="Continual Learning in NLP Tasks"></a>Continual Learning in NLP Tasks</h2><h3 id="Word-and-Sentence-Representations"><a href="#Word-and-Sentence-Representations" class="headerlink" title="Word and Sentence Representations"></a>Word and Sentence Representations</h3><p>分布式词向量表示是许多NLP应用程序的基础。</p><p>通常，词嵌入是在大型通用语料库上训练的，因为领域内语料库的大小在大多数情况下是不够的。这是有代价的，因为在通用语料库上训练的嵌入通常不适合特定于领域的下游任务，因此，整体性能会受到影响。</p><p>在CL设置中，这也意味着词汇可以相对于两个维度改变：时间和领域。一个公认的共识是，由于复杂的语言和社会过程，单词的意义会随着时间的推移而变化。因此，重要的是检测和适应意义和数据分布的变化，同时防止先前从 CF 中学习到的表示。</p><p>为了解决这个问题 ， Lifelong domain word embedding via meta-learning提出了一种元学习方法，该方法利用过去多领域语料库中的知识生成改进的新领域嵌入。</p><p>Continual Learning for Sentence Representations Using Conceptors 引入了一种随时间更新的句子编码器，使用矩阵概念不断学习依赖于语料库的特征。</p><p>重要的是，王等人。(2019b)认为，当一个神经网络模型被训练到一个新的任务上时，嵌入的向量空间会发生不希望的变化，从而导致嵌入对于以前的任务是不可行的。为了缓解嵌入空间失真的问题，他们建议使用锚定对齐句子嵌入。最近出现了一个词嵌入和语言建模交叉点的研究线，称为上下文嵌入，并展示了许多NLP任务的最新成果。</p><h2 id="Research-Gaps-and-Future-Directions"><a href="#Research-Gaps-and-Future-Directions" class="headerlink" title="Research Gaps and Future Directions"></a>Research Gaps and Future Directions</h2><p>在现实世界中，我们经常处理部分信息数据。此外，数据来自非 i.i.d。分布，并受代理的干预或环境变化的影响。尽管存在一些尝试，模型从一系列示例中学习而不知道它们来自哪个数据集和分布（例如 d’Autume 等，2019），但这种方法很少见。此外，学习很少的例子（例如通过少样本转移学习）（Liu，2020）是当前模型的主要挑战，尤其是执行分布外泛化（Bengio，2019）。特别是，广泛用于 NLP 的序列到序列模型仍然难以系统泛化（Lake 和 Baroni，2018 年；Bahdanau 等人，2019 年），无法学习高级语言概念的一般规则和推理。例如，Feder 等人最近在反事实语言表示方面的工作。 (2020) 是朝着这个方向迈出的有希望的一步。非平稳学习问题可以通过从数据中理解和推断因果关系来缓解（例如 Osawa 等人，2019 年）——这是一个突出的挑战（Pearl，2009 年）——并提出不太可能的组合存在于训练分布中（Bengio，2019）。也就是说，语言是组合的；因此，该模型可以动态操纵语义概念，这些语义概念可以在新情况下重新组合（Lake 等人，2015 年），后来得到基于语言的溯因推理（例如 Bhagavatula 等人，2020 年）的支持。</p><p>在模型级别，CL 与贝叶斯原理的结合应该可以更好地识别神经网络每个参数的重要性，并有助于参数修剪和量化（例如 Ebrahimi 等人，2020 年；Golkar 等人，2019 年）。我们认为，不仅参数信息量应该是不确定性引导的，而且先前记忆的周期性重放也应该通过因果关系来告知。此外，重点关注降低模型容量和计算要求也很重要。尽管神经网络的过度参数化很普遍（Neyshabur 等人，2018 年），但许多当前的 CL 方法促进了参数空间的扩展。我们设想进一步的研究工作集中在压缩方法上，例如知识蒸馏、低秩分解和模型修剪。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Continual-Lifelong-Learning-in-Natural-Language-Processing-A-Survey&quot;&gt;&lt;a href=&quot;#Continual-Lifelong-Learning-in-Natural-Language-Proce</summary>
      
    
    
    
    
    <category term="context detection" scheme="http://example.com/tags/context-detection/"/>
    
  </entry>
  
  <entry>
    <title>Optimizing Reusable Knowledge for Continual Learning via Metalearning</title>
    <link href="http://example.com/2021/10/05/Optimizing-Reusable-Knowledge-for-Continual-Learning-via-Metalearning/"/>
    <id>http://example.com/2021/10/05/Optimizing-Reusable-Knowledge-for-Continual-Learning-via-Metalearning/</id>
    <published>2021-10-05T01:41:33.000Z</published>
    <updated>2021-10-05T11:54:48.040Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Optimizing-Reusable-Knowledge-for-Continual-Learning-via-Metalearning"><a href="#Optimizing-Reusable-Knowledge-for-Continual-Learning-via-Metalearning" class="headerlink" title="Optimizing Reusable Knowledge for Continual Learning via Metalearning"></a>Optimizing Reusable Knowledge for Continual Learning via Metalearning</h1><p>当网络的权重在新任务的训练过程中被覆盖，从而导致忘记旧信息时，就会发生灾难性遗忘。</p><p>为了解决这个问题，作者提出了MetA Reusable Knowledge: MARK, 它提高了权重的可重用性，而不是在学习新任务时被覆盖。</p><p>MARK在任务之间保留一组共享权重，将这些共享的权重设想为一个公共知识库(KB)，它不仅用于学习新任务，而且在模型学习新任务时还会丰富新知识。</p><p>关键组成部分有两个方面：</p><ul><li>1.元学习方法提供了用新知识逐步丰富知识库的关键机制，并促进了任务之间的权重可重用性。</li><li>2.一组可训练掩码提供了从知识库相关权重中有选择地选择来解决每个任务的关键机制。</li></ul><p>以往预防灾难性遗忘（CF）的工作主要遵循两种策略：</p><ul><li>1.避免修改对解决先前任务至关重要的参数。具体地说，当面对新的任务时，正则化项确保了关键参数的修改尽可能少。一般而言，该方法在任务较少的问题上表现出令人满意的性能，但是当任务数量增加时，诸如权值的累积漂移和它们之间的干扰等问题使得该方法难以扩展。</li><li>2.模型的体系结构更改。这包括保留部分网络容量来学习每个任务的方法，以及使用特殊记忆单元来回忆以前任务中的关键训练样本的方法。这些方法的主要问题是额外的模型复杂性并且需要一种有效的方法来回忆以前任务中的关键信息。</li></ul><p>与这些先前的策略相反，当学习新任务时，人类会不断地将先前的经验与新情况联系起来，增强先前的记忆，这有助于缓解CF问题。</p><p>MASK 一种基于学习策略的新模型，它不是减轻权重覆盖或学习不同任务的独立权重，而是使用元学习方法来促进任务之间的权重可重用性。特别地，将这些共享的权重设想为一个公共知识库(KB)，它不仅用于学习新任务，而且在模型学习新任务时还会丰富新知识。从这个意义上说，MASK背后的KB不是由以向量编码信息的外部存储器给出的，而是由以其权重编码共享信息的可训练模型给出的。作为查询该KB的补充机制，MASK还包括一组可训练掩码，其负责实施选择性寻址方案来查询KB。</p><p>因此，为了构建和查询其共享知识库，MARK 使用了两种互补的学习策略。 </p><ul><li>1、元学习技术提供了实现两个目标的关键机制：</li><li><ul><li>鼓励对多个任务有用的权重更新</li><li>在模型学习新任务时用新知识丰富知识库。 </li></ul></li><li>2、一组可训练的掩码提供了从知识库相关权重中选择性地选择来解决每个任务的关键机制。</li></ul><p>MARK的工作方式是，首先通过检测知识库中学习的每个模式的重要性的函数强制模型重用当前知识，然后如果过去的知识不足以成功执行任务，则扩展其知识。</p><h2 id="Continual-Learning-Scenario"><a href="#Continual-Learning-Scenario" class="headerlink" title="Continual Learning Scenario"></a>Continual Learning Scenario</h2><p>每个任务 $t$ 由新的数据分布 $D^t = (X^t, Y^t,T^t)$ 组成，其中 $X^t$  是输入样例，$Y^t$ 是任务标签， $T^t$ 是任务ID。</p><p>目标是学习一个分类模型 $f : X\to Y$ 使用来自T个任务序列的数据：$D = {D^1,…,D^T}$</p><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><p>两个主要挑战：</p><ul><li>如何增量地构建此知识库？（一种称为情景训练的元学习策略）</li><li>如何查询此知识库以访问相关的知识片段？（为每个任务训练掩码生成函数）</li></ul><h3 id="Model-Architecture"><a href="#Model-Architecture" class="headerlink" title="Model Architecture"></a>Model Architecture</h3><p><img src="https://z3.ax1x.com/2021/10/05/4v9aff.png" alt=""></p><p>给定来自任务 $T$ 的输入 $X_i$，使用特征提取器 $F^t$ 来获得 $F_i^t$。 </p><p>然后将 $F_i^t$ 传递给mask函数 $M^t$ 以生成mask $M_i^t$。</p><p>之后，相同的输入 $X_i$ 进入 KB，它具有由 $M_i^t$ 调制的中间激活</p><p>最终，调制的特征经过任务相关的分类器 $C^t$，该分类器执行对 $X_i$ 的类别预测。</p><p>模型的主要模块：</p><ul><li><p>Feature Extractor ($F^t$) : 该模块负责为每个输入 $X_i$ 提供初始嵌入，即 $F^t$ 取输入$X_i$ 并输出向量表示$F_i^t$。重要的是要注意，模型 $F^t$ 可以在任务之间共享，也可以特定于每个任务。</p></li><li><p>Knowledge Base (KB) : 这是MASK背后的主要模块。当模型面临新的任务时，它负责积累相关知识。实现时使用了带B blocks的卷积架构。模型的这一部分在任务之间共享。</p></li><li>Mask-Generating functions ( $M^t$): 将特征向量 $F_i^t$ 作为输入，并为 KB 的每个 block 生成一个实例和依赖于任务的掩码 $M_i^t$。 每个掩码由一组标量组成，每个标量用于KB的卷积块中的每个通道，其乘以每个通道的激活。这些掩码对于选择与每个实例和任务相关的知识至关重要。在实施中，作者使用全连接层。</li><li>Classifier ( $C^t$) : 这些模块对应于依赖于任务的分类头。 它输入$ F^t_{i,KB}$ , 是通过对 KB 的最后一个 block 的输出进行展平操作而给出的。 给定输入 $X_i$ 的任务 ID，相应的 head 输出模型预测。 实现中使用全连接层。</li></ul><h3 id="MARK-Training"><a href="#MARK-Training" class="headerlink" title="MARK Training"></a>MARK Training</h3><p>首先是通过在第一个任务中端到端地训练知识库来初始化知识库，而不使用元学习和掩码函数。</p><p>对于分类任务，首先使用卷积神经网络的规则训练过程来执行知识库初始化。之后，我们交替三个主要步骤对Mark进行每个任务的顺序训练：</p><ul><li>KB Querying : 训练任务相关的掩码生成函数，这些函数用于使用向量 $F_i^t$ 来查询知识库。另外，我们同时训练当前任务的任务分类器。请注意，撇开知识库初始化不谈，在此步骤中，每个新任务仅使用以前任务积累的知识进行训练。</li><li>KB Update: 使用元学习策略来更新知识库中的权重。该方案允许促进知识库更新，有利于获取可重用的知识以面对新任务。</li><li>KB Querying : 在使用来自当前任务的知识更新知识库之后，我们重复查询过程，使用这些新知识来优化掩码生成函数和任务分类器。注意，在此步骤中，KB保持固定。</li></ul><p>前面三个步骤的应用背后的直觉如下:</p><blockquote><p>最初使用从先前任务中积累的知识来查询知识库。 这迫使掩码函数和分类器重用可用知识。 当该知识耗尽时，我们继续将当前任务中的知识添加到知识库中。 最后，我们利用这个新更新的知识库来获得给定任务的最终掩码函数和分类器。</p></blockquote><p><img src="https://z3.ax1x.com/2021/10/05/4vkqS0.png" alt=""></p><h3 id="KB-Querying"><a href="#KB-Querying" class="headerlink" title="KB Querying"></a>KB Querying</h3><p>一旦我们通过使用特征提取器 $F^t$ 获得特征向量，模型就可以了解知识库中哪些模块能够最好地解决当前任务。在这个训练阶段，模型训练函数学习如何使用知识库中可用的知识，只关注重用以前任务中的知识，而不修改KB。特别是在这一步中，我们只训练 $M^t$ 和 $C^t$。两者都经过端到端训练，同时保持KB权重冻结。</p><p>当我们为模型的每个中间激活生成掩码时，严格地说，我们总共有B个掩码生成函数。然而，为了便于表示，我们将所有此类函数都包含在 $M^t$下，并将其输出视为这些 $B$ 函数结果的拼接。</p><p>下式表明函数$M^t$，其中在给定来自任务 $t$ 的输入$X_i$的情况下获得掩码 $M_i^t$:</p><script type="math/tex; mode=display">M_i^t = M^t (F_i^t) = \rho((W^{t,M})^T F_i^t)</script><p>在此过程中生成的遮罩具有两种效果：</p><ul><li>给出KB中特定模块对当前输入的重要性的信号</li><li>确保梯度更新在真正重要的地方进行。</li></ul><p>如果激活映射与某个任务无关，则相应掩码的值将为零，从而使与该激活相关联的梯度更新也为零。</p><h3 id="KB-Update"><a href="#KB-Update" class="headerlink" title="KB Update"></a>KB Update</h3><p>这个训练步骤的目的是将当前任务中的新知识添加到KB。为了实现这一点，使用元学习作为一种方式，迫使模型捕获可以重用的知识，以面对新的任务。下图，训练Mark的元学习过程的示意图。这个过程是 Reptile的改编</p><p><img src="https://z3.ax1x.com/2021/10/05/4v3dZn.png" alt=""></p><p>给定任务t，随机生成一组K个小任务，其中每个小任务由来自原始任务的类的子集组成。</p><p>对于每个小任务，我们为固定数量的epoch训练当前知识库的独立副本，从而生成K个模型。</p><p>然后，使用一组保持训练样本计算每个模型的损失函数的梯度。</p><p>最后，使用这些梯度的加权平均值来更新KB。</p><p>具体地说，创建了一组K个小任务，其中每个小任务包括从当前任务中随机抽样一组H个类和每个类的h个训练实例。</p><p>这允许我们创建一个与主任务不同的小任务，找到不特定于它的权重。使用 $E_{inner}$ epochs的每个小任务训练模型的一个副本。将为e个epochs 训练的副本 k 称为 $KB^{k}_e$。对于每个小任务，使用一个临时分类器 $C^k$，该分类器由 $C^t$参数初始化。在内部循环的最终迭代之后，丢弃这个分类器。</p><p>与MAML一样模型训练包括两个嵌套循环，一个内循环一个外循环。内循环负责为当前小任务训练我们的知识库副本，而外循环负责按照梯度方向更新知识库权重，从而快速适应新的小任务。</p><p>在每个内循环期间，$KB^k$ 和 $C^k$ 被端到端地训练以用于 $E_{inner}$ epochs。</p><p>下式模拟外循环并更新 KB，具体地说，对于每个k，平均 $KB^k_0$之前的 KB 参数的差异:</p><script type="math/tex; mode=display">KB = KB - \alpha \nabla KB  \ \ \ \ \ \  \nabla KB = \frac{1}{E_{inner}}\sum_{k}^K \gamma_k (KB^k_{E_{inner}} - KB_0^k)</script><p>和Reptile 一样梯度更新为每个模型 $KB^k$ 的累积梯度之和的平均值。其中权重 $\gamma_k$  为：</p><script type="math/tex; mode=display">\gamma_k = \frac{acc}{\sum_{j}^K acc_j}</script><p>其中自同一任务 $t$ 的验证批次上的每个模型的精度作为参考。</p><h2 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h2><p><img src="https://z3.ax1x.com/2021/10/05/4vGBgU.png" alt=""></p><ul><li>MARK-Task :  为每个任务训练 $F^t$，在它上面添加一个使用 $D^T$训练的分类器。训练完 $ F^t $后，该分类器被丢弃。</li><li>MARK-Random:  $F^t $由一组随机权重组成。所有任务共享相同的 $F^t$。</li><li>MARK-Resnet :  所有任务共享在Imagenet上预先训练的Resnet-18作为特征提取器。</li></ul><p><img src="https://i.loli.net/2021/10/05/Ez3rPXkuyfm1lTg.png" alt=""></p><p>随着训练的任务越多，权重更新的数量就会迅速减少，几乎降到零。此外，在这两个基准中，相对于基线的更新次数都有显著减少。这些结果表明，当使用Mark训练模型时，干扰较少，我们将其归因于其存储可重用知识的知识库。</p><p><img src="https://i.loli.net/2021/10/05/UXRnuh4dDtSKkeB.png" alt=""></p><ul><li>Baseline :简单的顺序学习，没有元学习或掩码生成函数。我们使用与知识库相同的架构。</li><li>Baseline + ML : 添加元学习，即知识库更新来改进基线。</li><li>Baseline + Mask :  添加特定于任务的掩码函数来改进基线。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Optimizing-Reusable-Knowledge-for-Continual-Learning-via-Metalearning&quot;&gt;&lt;a href=&quot;#Optimizing-Reusable-Knowledge-for-Continual-Learnin</summary>
      
    
    
    
    
    <category term="context detection" scheme="http://example.com/tags/context-detection/"/>
    
  </entry>
  
  <entry>
    <title>39/40/46/47/77/78/90/60/93排列、组合、子集相关问题</title>
    <link href="http://example.com/2021/10/04/39-40-46-47-77-78-90-60-93%E6%8E%92%E5%88%97%E3%80%81%E7%BB%84%E5%90%88%E3%80%81%E5%AD%90%E9%9B%86%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2021/10/04/39-40-46-47-77-78-90-60-93%E6%8E%92%E5%88%97%E3%80%81%E7%BB%84%E5%90%88%E3%80%81%E5%AD%90%E9%9B%86%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</id>
    <published>2021-10-04T01:06:33.000Z</published>
    <updated>2021-10-09T01:21:52.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="39-40-46-47-77-78-90-60-93排列、组合、子集相关问题"><a href="#39-40-46-47-77-78-90-60-93排列、组合、子集相关问题" class="headerlink" title="39/40/46/47/77/78/90/60/93排列、组合、子集相关问题"></a>39/40/46/47/77/78/90/60/93排列、组合、子集相关问题</h1><h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39 组合总和"></a>39 组合总和</h2><h4 id="39-组合总和-1"><a href="#39-组合总和-1" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a></h4><p>思路分析：根据示例 1：输入: candidates = [2, 3, 6, 7]，target = 7。</p><p>候选数组里有 2，如果找到了组合总和为 7 - 2 = 5 的所有组合，再在之前加上 2 ，就是 7 的所有组合；<br>同理考虑 3，如果找到了组合总和为 7 - 3 = 4 的所有组合，再在之前加上 3 ，就是 7 的所有组合，依次这样找下去。</p><p><img src="https://z3.ax1x.com/2021/10/04/4Oev7Q.png" alt=""></p><ul><li>以 target = 7 为根节点，创建一个分支的时候做减法。</li><li>每一个箭头表示：从父亲节点的数值减去边上的数值，得到孩子节点的数值。边的值就是题目中给出的 candidate 数组的每个元素的值。</li><li>减到0或负数的时候停止，即：节点0和负数节点成为叶子节点。</li><li>所有从根节点到节点0的路径（只能从上往下，没有回路）就是题目要找的一个结果</li></ul><p>这棵树有 4 个叶子结点的值 0，对应的路径列表是 [[2, 2, 3], [2, 3, 2], [3, 2, 2], [7]]，而示例中给出的输出只有 [[7], [2, 2, 3]]。即：题目中要求每一个符合要求的解是 不计算顺序 的。下面我们分析为什么会产生重复。</p><h3 id="针对具体例子分析重复路径产生的原因（难点）"><a href="#针对具体例子分析重复路径产生的原因（难点）" class="headerlink" title="针对具体例子分析重复路径产生的原因（难点）"></a>针对具体例子分析重复路径产生的原因（难点）</h3><p>产生重复的原因是：在每一个结点，做减法，展开分支的时候，由于题目中说，每一个元素可以重复使用，我们考虑了所有的候选数，因此出现了重复的列表。</p><p>一种简单的去重方案是借助哈希表的天然去重功能，但实际操作没那么容易。</p><p>另一种可以再搜索的时候去重，遇到这一类相同元素不计算顺序的问题，我们在搜索的时候就需要按某种顺序搜索。具体做法是：每一次搜索的时候设置下一轮搜索的起点 begin ：</p><p><img src="https://z3.ax1x.com/2021/10/04/4OmrDS.png" alt=""></p><p>即：从每一层的第2个节点开始，都不能再搜索产生同一层节点使用过的 candidate 里的元素。</p><ul><li>Python3 的 [1, 2] + [3] 语法生成了新的列表，一层一层传到根结点以后，直接 res.append(path) 就可以了；</li><li>基本类型变量在传参的时候，是复制，因此变量值的变化在参数里体现就行，所以 Python3 的代码看起来没有「回溯」这个步骤。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span>(<span class="params">self, candidates, target</span>):</span></span><br><span class="line">      size = <span class="built_in">len</span>(candidates)</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">          <span class="keyword">return</span> []</span><br><span class="line">        path = []</span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">candidates, begin, size, res, target</span>):</span></span><br><span class="line">          <span class="keyword">if</span> target &lt; <span class="number">0</span>:</span><br><span class="line">              <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">              res.append(path)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span>  index <span class="keyword">in</span> <span class="built_in">range</span>(begin, size):</span><br><span class="line">              dfs(candidates, index, size, path+[candidates[index]], res, target - candidate[index])</span><br><span class="line">        dfs(candidates, <span class="number">0</span>, size, path, res, target)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = candidates.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        dfs(candidates, <span class="number">0</span>, len, target, path, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> begin, <span class="keyword">int</span> len, <span class="keyword">int</span> target, Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// target 为负数和 0 的时候不再产生新的孩子结点</span></span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重点理解这里从 begin 开始搜索的语意</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; len; i++) &#123;</span><br><span class="line">            path.addLast(candidates[i]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注意：由于每一个元素可以重复使用，下一轮搜索的起点依然是 i，这里非常容易弄错</span></span><br><span class="line">            dfs(candidates, i, len, target - candidates[i], path, res);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 状态重置</span></span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剪枝提速"><a href="#剪枝提速" class="headerlink" title="剪枝提速"></a>剪枝提速</h3><ul><li>根据上面画树形图的经验，如果 target 减去一个数得到负数，那么减去一个更大的树依然是负数，同样搜索不到结果。基于这个想法，我们可以对输入数组进行排序，添加相关逻辑达到进一步剪枝的目的；</li><li>排序是为了提高搜索速度，对于解决这个问题来说非必要。但是搜索问题一般复杂度较高，能剪枝就尽量剪枝。实际工作中如果遇到两种方案拿捏不准的情况，都试一下。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = candidates.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 排序是剪枝的前提</span></span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        dfs(candidates, <span class="number">0</span>, len, target, path, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> begin, <span class="keyword">int</span> len, <span class="keyword">int</span> target, Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 由于进入更深层的时候，小于 0 的部分被剪枝，因此递归终止条件值只判断等于 0 的情况</span></span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 重点理解这里剪枝，前提是候选数组已经有序，</span></span><br><span class="line">            <span class="keyword">if</span> (target - candidates[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            path.addLast(candidates[i]);</span><br><span class="line">            dfs(candidates, i, len, target - candidates[i], path, res);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="什么时候使用-used-数组，什么时候使用-begin-变量"><a href="#什么时候使用-used-数组，什么时候使用-begin-变量" class="headerlink" title="什么时候使用 used 数组，什么时候使用 begin 变量"></a>什么时候使用 <code>used</code> 数组，什么时候使用 <code>begin</code> 变量</h3><ul><li>排列问题，讲究顺序（即 <code>[2, 2, 3]</code> 与 <code>[2, 3, 2]</code> 视为不同列表时），需要记录哪些数字已经使用过，此时用 <code>used</code> 数组；</li><li>组合问题，不讲究顺序（即 <code>[2, 2, 3]</code> 与 <code>[2, 3, 2]</code> 视为相同列表时），需要按照某种顺序搜索，此时使用 <code>begin</code> 变量。</li></ul><h2 id="40-组合总和-2"><a href="#40-组合总和-2" class="headerlink" title="40 组合总和 2"></a>40 组合总和 2</h2><h4 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a href="https://leetcode-cn.com/problems/combination-sum-ii/">40. 组合总和 II</a></h4><p><code>candidates</code> 中的每个数字在每个组合中只能使用一次。</p><p>为了使得解集不包含重复的组合，有两种方案：</p><ul><li>使用哈希表，编码复杂</li><li>需要按顺序搜索，在搜索的过程中检测分支是否会出现重复结果。注意：这里的顺序不仅仅指数组candidate有序，还指按照一定顺序搜索结果。</li></ul><p><img src="https://z3.ax1x.com/2021/10/04/4OnqeS.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(candidates.length==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n  = candidates.length;</span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line"></span><br><span class="line">        dfs(candidates, <span class="number">0</span>, n, path, target,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> begin, <span class="keyword">int</span> n, Deque&lt;Integer&gt; path, <span class="keyword">int</span> target, List&lt;List&lt;Integer&gt;&gt; res)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 小剪枝：同一层相同数值的节点，从第2个开始，候选数更少，结果一定发生重复，因此跳过</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=begin;i&lt;n;i++)&#123;</span><br><span class="line">           <span class="comment">// 大剪枝：减去 candidates[i] 小于0 ，减去后面的candidates[i+1], candidates[i+2] 肯定也小于0</span></span><br><span class="line">           <span class="keyword">if</span>(target - candidates[i]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 小剪枝：同一层相同数值的节点，从第2个开始，候选数更少，结果一定发生重复，因此跳过</span></span><br><span class="line">           <span class="keyword">if</span>(i &gt; begin &amp;&amp; candidates[i] == candidates[i-<span class="number">1</span>])&#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           path.addLast(candidates[i]);</span><br><span class="line">           dfs(candidates, i+<span class="number">1</span>, n, path, target - candidates[i], res);</span><br><span class="line">           path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="77-组合"><a href="#77-组合" class="headerlink" title="77 组合"></a>77 组合</h2><h4 id="77-组合-1"><a href="#77-组合-1" class="headerlink" title="77. 组合"></a><a href="https://leetcode-cn.com/problems/combinations/">77. 组合</a></h4><p>法一：根据搜索起点画出二叉树</p><ul><li>如果组合里有 1， 那么需要再 $[2,3,4]$ 里再找一个数</li><li>如果组合里有 2， 那么需要再 $[3,4]$ 里再找一个数，注意：这里不能再考虑 1，因为包含 1 的组合，在第一种情况以及包含。</li></ul><p><img src="https://z3.ax1x.com/2021/10/05/4jEZSP.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= <span class="number">0</span> || n &lt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从 1 开始是题目的设定</span></span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        dfs(n, k, <span class="number">1</span>, path, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> begin, Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归终止条件是：path 的长度等于 k</span></span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历可能的搜索起点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 向路径变量里添加一个数</span></span><br><span class="line">            path.addLast(i);</span><br><span class="line">            <span class="comment">// 下一轮搜索，设置的搜索起点要加 1，因为组合数理不允许出现重复的元素</span></span><br><span class="line">            dfs(n, k, i + <span class="number">1</span>, path, res);</span><br><span class="line">            <span class="comment">// 重点理解这里：深度优先遍历有回头的过程，因此递归之前做了什么，递归之后需要做相同操作的逆向操作</span></span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>剪枝</p><p>上面的代码，搜索起点遍历到 n，即：递归函数中有下面的代码片段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从当前搜索起点 begin 遍历到 n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt;= n; i++) &#123;</span><br><span class="line">    path.addLast(i);</span><br><span class="line">    dfs(n, k, i + <span class="number">1</span>, path, res);</span><br><span class="line">    path.removeLast();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，如果 n=7, k=4 ，从5开始搜索就已经没有意义了， 这是因为：即使把5选上，后面的数只有，6，7一共三个候选数，凑不出4个数的组合。因此搜索起点有上界，这个上界是多少，可以举例分析。</p><p>分析搜索起点的上界，其实是在深度优先遍历的过程中剪枝，剪枝可以避免不必要的遍历，剪枝剪得好，可以大幅度节约算法的执行时间。</p><p>下面的图片绿色部分是减掉的枝叶，当n很大的时候，能少遍历很多节点，节约了时间</p><p><img src="https://z3.ax1x.com/2021/10/05/4jEvkj.png" alt=""></p><p>容易知道：搜索起点和当前还需要选几个数有关，而当前还需要选几个数与已经选了几个数有关，即与path 的长度相关。举例分析：</p><p>例如： n=6, k=4</p><p><code>path.size() == 1</code> 的时候，接下来要选择 3 个数，搜索起点最大是 4，最后一个被选的组合是 <code>[4, 5, 6]</code>；</p><p><code>path.size() == 2</code> 的时候，接下来要选择 2 个数，搜索起点最大是 5，最后一个被选的组合是 <code>[5, 6]</code>；</p><p><code>path.size() == 3</code> 的时候，接下来要选择 1 个数，搜索起点最大是 6，最后一个被选的组合是 <code>[6]</code>；</p><p>再如：<code>n = 15</code> ，<code>k = 4</code>。</p><p><code>path.size() == 1</code> 的时候，接下来要选择 3 个数，搜索起点最大是 13，最后一个被选的是 <code>[13, 14, 15]</code>；</p><p><code>path.size() == 2</code> 的时候，接下来要选择 2 个数，搜索起点最大是 14，最后一个被选的是 <code>[14, 15]</code>；</p><p><code>path.size() == 3</code> 的时候，接下来要选择 1 个数，搜索起点最大是 15，最后一个被选的是 <code>[15]</code>；</p><p>可以归纳出：</p><p>搜索起点的上界 + 接下来要选择的元素个数 - 1 = n</p><p>其中，接下来要选择的元素个数 <code>= k - path.size()</code>，整理得到：</p><p>搜索起点的上界 = n - (k - path.size()) + 1</p><p>所以，我们的剪枝过程就是：把 <code>i &lt;= n</code> 改成 <code>i &lt;= n - (k - path.size()) + 1</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有这里 i &lt;= n - (k - path.size()) + 1 与参考代码 1 不同</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt;= n - (k - path.size()) + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            path.addLast(i);</span><br><span class="line">            dfs(n, k, i + <span class="number">1</span>, path, res);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>方法二：按照每一个数选与不选画出二叉树</p><p><img src="https://z3.ax1x.com/2021/10/05/4jV1BD.png" alt=""></p><p>画一个表格更容易看出边界条件。</p><p><img src="https://z3.ax1x.com/2021/10/05/4jVJNd.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= <span class="number">0</span> || n &lt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为了防止底层动态数组扩容，初始化的时候传入最大长度</span></span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> ArrayDeque&lt;&gt;(k);</span><br><span class="line">        dfs(<span class="number">1</span>, n, k, path, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> n, <span class="keyword">int</span> k, Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基础版本的递归终止条件：if (begin == n + 1) &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (begin &gt; n - k + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不选当前考虑的数 begin，直接递归到下一层</span></span><br><span class="line">        dfs(begin + <span class="number">1</span>, n, k, path, res);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不选当前考虑的数 begin，递归到下一层的时候 k - 1，这里 k 表示还需要选多少个数</span></span><br><span class="line">        path.addLast(begin);</span><br><span class="line">        dfs(begin + <span class="number">1</span>, n, k - <span class="number">1</span>, path, res);</span><br><span class="line">        <span class="comment">// 深度优先遍历有回头的过程，因此需要撤销选择</span></span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="78-子集"><a href="#78-子集" class="headerlink" title="78 子集"></a>78 子集</h2><h4 id="78-子集-1"><a href="#78-子集-1" class="headerlink" title="78. 子集"></a><a href="https://leetcode-cn.com/problems/subsets/">78. 子集</a></h4><ul><li>组合问题，需要按顺序读字符，就不需要设置used 数组</li><li>在根节点、非叶子节点和叶子节点都需要结算，因此 res.add(path)需要放中间</li></ul><h3 id="法一：-回溯搜索"><a href="#法一：-回溯搜索" class="headerlink" title="法一： 回溯搜索"></a>法一： 回溯搜索</h3><p>执行一次深度优先遍历，一路走到底，走不通的时候，返回回来，继续执行，一直这样下去，知道回到起点。</p><p><img src="https://z3.ax1x.com/2021/10/06/4xkH81.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>, n, nums, path, res);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> n, <span class="keyword">int</span>[] nums, Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(begin == n)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前数可选 也可以不选</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不选 直接进入下一层</span></span><br><span class="line">        dfs(begin+<span class="number">1</span>, n, nums, path, res);</span><br><span class="line">        <span class="comment">// 选了，进入下一层</span></span><br><span class="line">        path.add(nums[begin]);</span><br><span class="line">        dfs(begin+<span class="number">1</span>, n, nums, path, res);</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把选这个数作为左分支，把不选这个数作为右分支</p><p><img src="https://z3.ax1x.com/2021/10/06/4xAyZD.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        dfs(nums, <span class="number">0</span>, len, stack, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index, <span class="keyword">int</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">                     Stack&lt;Integer&gt; stack, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == len) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(stack));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前数可选，也可以不选</span></span><br><span class="line">        <span class="comment">// 选了有，进入下一层</span></span><br><span class="line">        stack.add(nums[index]);</span><br><span class="line">        dfs(nums, index + <span class="number">1</span>, len, stack, res);</span><br><span class="line">        stack.pop();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不选，直接进入下一层</span></span><br><span class="line">        dfs(nums, index + <span class="number">1</span>, len, stack, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; subsets = solution.subsets(nums);</span><br><span class="line">        System.out.println(subsets);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="方法二：使用位运算技巧"><a href="#方法二：使用位运算技巧" class="headerlink" title="方法二：使用位运算技巧"></a>方法二：使用位运算技巧</h3><p>数组的每个元素，可以有两个状态：</p><ul><li>不在子数组中（用0表示）</li><li>在子数组中（用1表示）</li></ul><p>从0到2 的数组个数次幂（不包括）的整数的二进制表示就能表示所有状态的集合</p><p>子集数量为 $2^n$  ，也就是1 &lt;&lt; n<br>用二进制0表示不选，1表示选，遍历从0到 $2^n$ 的所有二进制数<br>对每个二进制数也就是每种子集情况都要遍历一边nums数组，<br>将二进制数中为1的位置在nums中对应的数加入到当前子集中</p><p><img src="https://z3.ax1x.com/2021/10/06/4xEaTg.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.length;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1</span> &lt;&lt; size;</span><br><span class="line">        </span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            List&lt;Integer&gt; cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;size;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>( ((i&gt;&gt;j) &amp; <span class="number">1</span>) ==<span class="number">1</span>)&#123;</span><br><span class="line">                    cur.add(nums[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(cur);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a><a href="https://leetcode-cn.com/problems/subsets-ii/">90. 子集 II</a></h2><h4 id="90-子集-II-1"><a href="#90-子集-II-1" class="headerlink" title="90. 子集 II"></a><a href="https://leetcode-cn.com/problems/subsets-ii/">90. 子集 II</a></h4><p>解集 <strong>不能</strong> 包含重复的子集</p><p>考虑数组 $[1,2,2]$ ，选择前两个数，或者第一、三个数，都会得到相同的子集。</p><p>也就是说，对于当前选择的数 $x$ ，若前面有与其相同的数y，且没有选择 y，此时包含的 x 的子集，必然会出现在包含 y 的所有子集中。</p><p>我们可以通过判断这种情况，来避免生成重复的子集。代码实现时，可以先将数组排序；迭代时，若发现没有选择上一个数，且当前数字与上一个数相同，则可以跳过当前生成的子集。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="keyword">false</span>, n, path, nums, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> begin,<span class="keyword">boolean</span> choose, <span class="keyword">int</span> n, Deque&lt;Integer&gt; path, <span class="keyword">int</span>[] nums, List&lt;List&lt;Integer&gt;&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(begin==n)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(begin+<span class="number">1</span>, <span class="keyword">false</span>, n,path, nums, res);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(begin&gt;<span class="number">0</span> &amp;&amp; nums[begin]==nums[begin-<span class="number">1</span>] &amp;&amp; !choose)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.add(nums[begin]);</span><br><span class="line">        dfs(begin+<span class="number">1</span>, <span class="keyword">true</span>, n, path, nums, res);</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：</p><p>$O(n \times 2^n)$ 其中 n 是数组nums 的长度。排序时间复杂度为 $O(nlogn)$ 。最坏情况下nums中无重复元素，需要枚举其所有 $ 2^n$ 个子集，每个子集加入答案时需要拷贝一份，耗时 $O(n)$, 一共需要 $O(n \times 2^n) + O(n) = O(n\times 2^n)$ 的实际来构造子集。</p><p>空间： $O(n)$ , 临时数组t的空间代价是O(n)， 递归时栈空间的代价为 $O(n)$</p><h2 id="60-排列序列"><a href="#60-排列序列" class="headerlink" title="60. 排列序列"></a><a href="https://leetcode-cn.com/problems/permutation-sequence/">60. 排列序列</a></h2><p>一句话题解：以下给出两种方法，思路其实是一样的：通过 计算剩余数字个数的阶乘，一位一位选出第 k 个排列的位数。</p><p>基于以下几点考虑，</p><p>所求排列一定在叶子节点处得到，可以根据已经选定的数的个数，进而计算还未选定的数的个数，然后计算阶乘，就知道这一个分支的叶子节点的个数。</p><ul><li>如果 k 大于这一个分支将要产生的叶子节点数，直接跳过这个分支，这个操作叫剪枝。</li><li>如果 k 小于等于 这个分支将要产生的叶子节点数，那说明所求的全排列一定在这个分支将要产生的叶子节点里，需要递归求解</li></ul><p><img src="https://i.loli.net/2021/10/08/GvmfoYzpLq3yanM.png" alt=""></p><p><img src="https://i.loli.net/2021/10/08/6nCmOXqcV7ND8KG.png" alt=""></p><p><img src="https://i.loli.net/2021/10/08/JPbKsoE6WkFvq7H.png" alt=""></p><p><img src="https://i.loli.net/2021/10/08/wGPRyatZ4oMgXA8.png" alt=""></p><p><img src="https://i.loli.net/2021/10/08/pZrdiPentQKCafI.png" alt=""></p><p><img src="https://i.loli.net/2021/10/08/nUOdm7P2skCzGr8.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line">        StringBuilder path = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span>[] factorial = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>]; <span class="comment">// 阶乘数组</span></span><br><span class="line">        factorial[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n ;i++)&#123;</span><br><span class="line">            factorial[i] = factorial[i-<span class="number">1</span>] * i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>, n ,k, path, used, factorial);</span><br><span class="line">        <span class="keyword">return</span> path.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// index 在这一步之前已经选择了几个数字，其值恰好是等于这一步需要确定的下标位置</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> n,<span class="keyword">int</span> k, StringBuilder path, <span class="keyword">boolean</span>[] used, <span class="keyword">int</span>[] factorial)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == n)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算还未确定的数字的全排列的个数，第一次进入的时候是 n-1</span></span><br><span class="line">        <span class="keyword">int</span> cnt = factorial[n-<span class="number">1</span>-index];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (cnt &lt; k)&#123;</span><br><span class="line">                k -= cnt;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.append(i);</span><br><span class="line">            used[i] = <span class="keyword">true</span>;</span><br><span class="line">            dfs(index+<span class="number">1</span>, n, k, path, used, factorial);</span><br><span class="line">            <span class="comment">// 注意：不可以回溯（重置变量），算法设计是【一下子来到叶子结点】，没有回头的过程</span></span><br><span class="line">            <span class="comment">// 这里加return，后面的数没有必要遍历去尝试了</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="93-复原-IP-地址"><a href="#93-复原-IP-地址" class="headerlink" title="93. 复原 IP 地址"></a><a href="https://leetcode-cn.com/problems/restore-ip-addresses/">93. 复原 IP 地址</a></h2><p><img src="https://i.loli.net/2021/10/09/gPWyb8XIRqJ3ABr.png" alt=""></p><p>分析剪枝条件：</p><ul><li>一开始，字符串的长度小于4 或者 大于 12， 一定不能拼凑出合法的ip</li><li>每一个节点可以选择截取的法法只有三种，截1位，截2位，截3位，因此灭一个节点可以生长出的分支最多有3条，根据截取出来的字符串判断是否是合理ip，先截取，再转成int判断。</li><li>由于ip段最多就4段，因此这颗三叉树最多4层，这个条件作为递归终止条件之一。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        List&lt;String&gt; res =  <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">4</span> || n&gt;<span class="number">12</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;String&gt; path = <span class="keyword">new</span> ArrayDeque&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>, n, path, s, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> splitTimes, <span class="keyword">int</span> n, Deque&lt;String&gt; path, String s, List&lt;String&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(begin == n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(splitTimes == <span class="number">4</span>)&#123;</span><br><span class="line">                res.add(String.join(<span class="string">&quot;.&quot;</span>,path));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 看到剩下的不够就退出，n-begin 表示剩余的还未分割的字符串的位数</span></span><br><span class="line">        <span class="keyword">if</span>(n - begin &lt; (<span class="number">4</span>-splitTimes) || n - begin &gt; <span class="number">3</span>*(<span class="number">4</span>-splitTimes))&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(begin + i &gt;= n)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> ipSegment = judgeIFIpSegemnt(s, begin, begin+i);</span><br><span class="line">            <span class="keyword">if</span>(ipSegment != -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 在判断是ip段的情况下，采取截取</span></span><br><span class="line">                path.addLast(String.valueOf(ipSegment));</span><br><span class="line">                dfs(begin+i+<span class="number">1</span>, splitTimes+<span class="number">1</span>, n, path, s, res);</span><br><span class="line">                path.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断s的子区间 [left, right] 是否能构成一个 ip段</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">judgeIFIpSegemnt</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = right - left + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 大于1 位的时候，不能以0开头</span></span><br><span class="line">        <span class="keyword">if</span>(len&gt;<span class="number">1</span> &amp;&amp; s.charAt(left) == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转成int 类型</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=left; i&lt;=right; i++)&#123;</span><br><span class="line">            res = res*<span class="number">10</span> + s.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(res &gt; <span class="number">255</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;39-40-46-47-77-78-90-60-93排列、组合、子集相关问题&quot;&gt;&lt;a href=&quot;#39-40-46-47-77-78-90-60-93排列、组合、子集相关问题&quot; class=&quot;headerlink&quot; title=&quot;39/40/46/47/77/7</summary>
      
    
    
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Large-scale Extensible User Intent Classification for Dialogue Systems with Meta Lifelong Learning</title>
    <link href="http://example.com/2021/10/02/MeLL-Large-scale-Extensible-User-Intent-Classification-for-Dialogue-Systems-with-Meta-Lifelong-Learning/"/>
    <id>http://example.com/2021/10/02/MeLL-Large-scale-Extensible-User-Intent-Classification-for-Dialogue-Systems-with-Meta-Lifelong-Learning/</id>
    <published>2021-10-02T01:42:29.000Z</published>
    <updated>2021-10-06T14:18:19.340Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MeLL-Large-scale-Extensible-User-Intent-Classification-for-Dialogue-Systems-with-Meta-Lifelong-Learning"><a href="#MeLL-Large-scale-Extensible-User-Intent-Classification-for-Dialogue-Systems-with-Meta-Lifelong-Learning" class="headerlink" title="MeLL: Large-scale Extensible User Intent Classification for Dialogue Systems with Meta Lifelong Learning"></a>MeLL: Large-scale Extensible User Intent Classification for Dialogue Systems with Meta Lifelong Learning</h1><p>用户意图检测（UIC）对于理解他们在对话系统中的需求至关重要。(文本分类)</p><p>这是因为不同域中的用户输入可能具有不同的文本分布和目标意图集。随着底层应用程序的发展，新的UIC任务不断涌现。因此，为大规模可扩展UIC开发一个框架至关重要，该框架能够持续适应新任务，并以可接受的参数增长率避免灾难性遗忘。</p><p>作者引入Meta Lifelong Learning (MeLL) framework  解决此问题。</p><p>在MELL中，基于BERT的文本编码器被用来学习跨任务的健壮文本表示，其被缓慢更新以用于终身学习。</p><p>全局和局部记忆网络用来捕获不同类的跨任务原型表示，将其视为元学习者快速适应不同的任务。</p><p>此外，应用最近最少使用的替换策略来管理全局记忆，以使模型大小不会随时间爆炸。</p><p>最后，每个UIC任务都有自己的特定于任务的输出层，并仔细总结了各种特性。</p><h2 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h2><h3 id="task-wise-UIC-models-的缺陷"><a href="#task-wise-UIC-models-的缺陷" class="headerlink" title="task-wise UIC models 的缺陷"></a>task-wise UIC models 的缺陷</h3><p>一个天真的方法是训练task-wise UIC模型。这种方法不适合工业规模的应用，有三个原因:</p><ul><li>模型参数总数不断增加，与任务数成线性关系。考虑到当前预先训练的语言模型具有数十亿个参数，为UIC训练这样的模型很容易涉及数万亿个参数，从而导致参数爆炸问题。</li><li>由于跨域的UIC任务有一些相似之处，单任务方法无法从其他任务中学习可转移的知识，这对提高UIC的性能至关重要。(前向后向迁移)</li><li>当需要维护越来越多的模型时，这些方法不可避免地带来了工程负担。</li></ul><p>另一种流行的方法是跨任务的多任务训练，其中利用共享编码器来捕获共同知识，并且每个任务具有其自己的预测头。当一个新的UIC任务出现时，我们可能需要为以前的任务重新训练模型，这不仅计算量大，而且很难保持现有UIC任务的性能稳定。</p><h3 id="Liflong-learning-amp-Meta-learning"><a href="#Liflong-learning-amp-Meta-learning" class="headerlink" title="Liflong learning &amp; Meta learning"></a>Liflong learning &amp; Meta learning</h3><p>近年来，终身学习受到了研究界的广泛关注。它是一种学习范式，它不断积累过去学到的知识，并用它来帮助未来的任务学习。当终身学习应用于大规模EUIC时，当新任务不断到达时，我们只需要维护相对较少的模型参数，从而缓解了参数爆炸效应。</p><p>在终身学习中，解决灾难性的遗忘问题是具有挑战性的，即模型在学习新任务时“忘记”如何解决现有任务。这是特别不可取的，因为我们希望在学习新的UIC任务时保持现有任务的性能稳定。</p><p>元学习，旨在获得跨任务的元学习者，这样它就可以用很少的数据样本快速适应新任务。通过获取元学习者，可以获取跨不同UIC任务的可迁移知识，并将其传递给新任务。主要的缺点是元学习者(在本文的情况下是BERT模型) 应该分别适应每项任务，无法避免参数爆炸。</p><p>因此，一个自然的问题就产生了：是否有可能为大规模EUIC设计一个持续学习框架，使其既能在模型适用于新的UIC任务时保持现有UIC任务的性能，又能在新的UIC任务数量增加时具有可接受的参数增长率？</p><h3 id="MeLL"><a href="#MeLL" class="headerlink" title="MeLL"></a>MeLL</h3><p><img src="https://z3.ax1x.com/2021/10/02/4Hyvin.png" alt=""></p><p>它有一个共享的网络结构，用于学习不断增长的UIC任务，由三个部分组成：文本编码器、全局记忆网络和局部记忆网络。</p><p>文本编码器是基于BERT构建的，以生成健壮的文本表示(无论是针对用户的查询还是响应)。对于终身表示学习，这些参数被缓慢更新，这确保由新任务调用的更新操作不会对现有任务产生显著的负面影响。</p><p>受基于原型的元学习的启发，全局网络存储不同类别的跨任务原型表示</p><p>记忆单元的更新速度很快，捕捉到了可跨任务转移的知识，使我们的模型可以很容易地适应新的任务。随着所有任务的不同类别的数量不断增加，使用LRU(最近最少使用)替换策略来管理全局内存，这样大小就不会随着时间的推移而爆炸。</p><p>通过注意力机制将文本编码器产生的特征与全局记忆网络进行融合，并利用它们来学习最终的任务特定的UIC分类器。</p><p>学习过程完成后，我们将与任务相关的原型表示复制到任务自己的本地内存网络中，并冻结参数。在推理过程中，我们使用文本编码器和任务自身的局部记忆网络进行特征生成。</p><p>编码器被认为是不断消化可传递的表示学习知识并将其传递给特定任务的慢速学习者。</p><p>全局记忆网络是快速学习器，能够快速编码给定任务的特定知识。</p><p>LRU替换策略和从全局存储网络到局部存储网络的复制机制在不增加过多参数的情况下缓解了灾难性遗忘。</p><h2 id="RELATED-WORK"><a href="#RELATED-WORK" class="headerlink" title="RELATED WORK"></a>RELATED WORK</h2><h3 id="User-Intent-Classification"><a href="#User-Intent-Classification" class="headerlink" title="User Intent Classification"></a>User Intent Classification</h3><p>UIC的技术最初应用于搜索引擎中的信息搜索，帮助搜索引擎理解用户发送的搜索查询。 由于对话系统通常通过系统和用户之间的交互提供更好的用户体验，对话系统的 UIC 越来越受欢迎。</p><p>UIC 也可以表述为一个排名问题。 Intent-Aware Ranking with Transformers (IART) 模型，基于注意力机制考虑查询意图来选择合适的答案。 MeLL 与这些方法的不同之处在于，它考虑在终身学习环境中解决大量 UIC 任务，这对于工业应用至关重要。</p><h3 id="Lifelong-Learning"><a href="#Lifelong-Learning" class="headerlink" title="Lifelong Learning"></a>Lifelong Learning</h3><p>终身学习或持续学习是一种机器学习范式，它侧重于借助先前学习的任务来解决无限的任务序列。开发终身学习算法的一个关键挑战是提高未来任务的性能，同时避免对现有任务的灾难性遗忘。典型的方法包括经验回放[16，20，40]，知识提炼[6，26]，迁移学习[5，19，39]等。在实际的工业应用中，将经验回放应用于大量的历史任务或存储这些训练好的模型进行知识提取代价很高。</p><p>在MEL中，同时使用慢速和快速学习器(即文本编码器和全局记忆网络)来将知识从现有任务转移到新任务。</p><h3 id="Meta-learning"><a href="#Meta-learning" class="headerlink" title="Meta-learning"></a>Meta-learning</h3><p>元学习的目标是培养能够在训练数据较少的情况下适应各种任务的元学习者。元学习在计算机视觉中得到了广泛的应用，它被认为是一种K-way N-shot few-shot learning problem。典型的应用包括 few-shot 图像分类[25]、目标检测[12]和许多其他应用。元学习在自然语言处理中的应用研究不多，有文献[31，32，34]。</p><p>与前人的工作相比，MELL框架不是一个典型的K-way N-shot算法，而是利用元学习的思想来学习文本编码器，该编码器捕获跨任务可转移的知识。全局存储器中使用的快速更新机制和原型表示类似于几个元学习神经网 络[30，43]。</p><h3 id="Pre-trained-Language-Models"><a href="#Pre-trained-Language-Models" class="headerlink" title="Pre-trained Language Models."></a>Pre-trained Language Models.</h3><p>尽管它们很有效，但现代语言模型的巨大规模给在工业应用程序中的部署带来了巨大的挑战，因为工业应用程序中有许多任务需要解决。在MEL中，通过使用缓慢和快速更新的元学习器来解决这个问题，这些元学习器能够处理越来越多的任务，而不会在模型中引入太多新参数。</p><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>$T<em>n$ 代表第 $n$ 个UIC 任务， $D_n={(x</em>{n,i}, y<em>{n,i})}$ 是 $T_n$ 的训练集，其中 $x</em>{n,i}$ 是第$D<em>n$ 中的第 $i$个输入样本（ 即输入文本，根据应用程序是用户查询或响应的场景），而 $y</em>{n,i}$ 是$x_{n,i}$ 的标签。</p><p>在大规模的EUIC设置中，考虑了我们面临无线序列的UIC任务 $T_1,T_2,…$ 的情况。在实际应用程序中，最开始我们通常有少量UIC任务可用。</p><p>因此让 $T<em>1,T_2,…T_N$ 是 $N$ 现有的基本UIC任务， $T</em>{N+1},T<em>{N+2},..$ 是新UIC任务的无限序列。我们的目标是构建一个学习系统 $F = {f_1,f_2,…,f_N,f</em>{N+1}, f<em>{N+2},…}$ 不断支持为新的UIC任务获取分类器 $f</em>{N+1},f_{N+2}$ 同时保持现有分类器 $(f_1,f_2,…,f_N)$ 的性能。</p><p>更具体的说，在初始阶段，我们给定了$N$ 训练集 $D<em>1,D_2,…,D_N$ ，N个基础任务来训练多任务UIC模型。之后模型可以自动扩展到无线数量的新任务 $T</em>{N+1},T_{N+2},…$ 新任务依次到达。</p><p>为了缓解灾难性遗忘和参数爆炸的问题， MeLL 的模型结构在训练和推理过程中具有不同的计算图。 总的来说，它有四个主要组成部分：</p><ul><li>Text Encoder</li><li>Global Memory Network</li><li>Local Memory Network</li><li>Task-specific Network</li></ul><p><img src="https://z3.ax1x.com/2021/10/02/4bS4BT.png" alt=""></p><p>UIC的特征是由缓慢更新的 TextEncoder 和快速更新的 Global Memory Network 生成的。</p><p>在特定任务的训练过程之后，相应的类表示从全局内存复制到特定任务的 Local Memory Network。在推理过程中，用文本编码器的特定于任务的 Local Memory来生成用于预测的特征。</p><h3 id="Text-Encoder"><a href="#Text-Encoder" class="headerlink" title="Text Encoder"></a>Text Encoder</h3><p>使用 Bert作为 作为模型的主干来学习跨任务的输入文本的通用、深度表示。在这里将 $x<em>{n,i}$ 表示为 $Q(x</em>{n,i})$。  随着新的 UIC 任务不断到来，BERT参数会缓慢更新以消化多个任务的可迁移知识。</p><p>请注意，在终身学习阶段，应将编码器参数的学习率设置为较小的值，以避免灾难性地忘记先前学习的任务。</p><h3 id="Global-and-Local-Memory-Networks"><a href="#Global-and-Local-Memory-Networks" class="headerlink" title="Global and Local Memory Networks"></a>Global and Local Memory Networks</h3><p>全局记忆网络存储 $K$ 个类别表示的 “ slots “ 槽。令 $y<em>N$ 为跨 $N$ 任务类的集合。即 $y_N = \cup</em>{n=1}^N y_n$ ， $K \ge |y_N|$</p><p>在初始学习阶段，我们设置 global memory G 如下：</p><p>对于类别标签 $y^{(m)}\in y_{N}$， 设 $T^{(m)}$ 是涉及 $y^{(m)}$ 的任务的集合。即 $T^{m} = {T_n | n\in {1,…,N} \ ,\  y^{(m)} \in y_n }$</p><p>$D<em>n^{(m)}$ 是 $D_n$ 的子集，$D^{(m)}_n = {(x</em>{n,i},y<em>{n,i}) \in D_n |y</em>{n,i} = y^{(m)}} $</p><p>类标签 $y^{(m)}$ 的原型表示向量 $G_N^{(m)}$ 为：</p><script type="math/tex; mode=display">G_N^{(m)} = \frac{1}{|T^{(m)}|} \sum_{T_n\in T^{(m)}} \frac{1}{|D_n^{(m)}|}\sum_{(x_{n,i},y_{n,i})\in D_n^{(m)}} Q(x_{n,i})</script><p>$G_N^{(m)}$ 是所有任务 $T^{(m)}$ 的原型向量的平均池化结果。通过聚合所有 $y_N$ 类表示 $G_N^{(m)}$，完成了 $G$ 的初始计算，将其视为多有$N$ 任务的高级表示。</p><p>我们进一步考虑终身学习的情况，一般而言，我们假设模型已经训练了 $j-1$ 个任务 $T<em>1,…,T</em>{j-1}$ 其中 $j&gt;N$ ,并且有一个新任务 $T_j$ 到达。</p><p>对于类 $y^{(m)} \in y<em>j$ , 如果对应的类表示 $G</em>{j-1}^{(m)}$ 存在于 $G$ 中，更新规则如下：</p><script type="math/tex; mode=display">G_j^{(m)} = (1-\gamma) G^{(m)}_{j-1} + \frac{\gamma}{|D_j^{(m)}|} \sum_{(x_{n,i},y_{n,i})\in D_j^{(m)}}  Q(x_{n,i})</script><p>其中 $\gamma \in (0,1)$ 是预定义的超参数，平衡已有的任务和新任务的相关重要性。</p><p>Global memory 的大小有 $K$ 的限制。当它满时，删除 $G$ 中最近最少访问的一项。</p><p>新插入$G$ 的类别表示计算为 ：</p><script type="math/tex; mode=display">G_j^{(m)} = \frac{1}{|D_j^{(m)}|} \sum_{(x_{n,i}, y_{n,i})\in D_j^{(m)}} Q(x_{n,i})</script><p>应用LRU替换策略，因为任务的主题趋势可能会随着时间的推移而漂移。最近更新的类表示在不久的将来很有可能再次使用。示例如下图：</p><p><img src="https://z3.ax1x.com/2021/10/02/4bkzQJ.png" alt=""></p><p>在任务感知学习过程结束时，对于当前任务 $T_n$，复制 $G$ 对应类的表示  $y_n$ 到它自己的本地内存 $L_n$ 用于推理，所有参数都被冻结。因此当全局记忆网络快速更新时，对 $G$ 的更改不会影响对现有任务的推理。</p><h3 id="Feature-Fusion-and-Model-Output"><a href="#Feature-Fusion-and-Model-Output" class="headerlink" title="Feature Fusion and Model Output"></a>Feature Fusion and Model Output</h3><p>在介绍了 $Q(x_{n,i})$ 和 $G$ 的生成后，现在讨论 MeLL中的前向传播。</p><p>假设我们正在学习任务 $T<em>n$， 当前训练实例为$(x</em>{n,i}, y_{n,i})\in D_n$。我们使用类标签集 $y_n$ 查询 $G$, 为每个类 $y^{(m)}\in y_n$ 生成当前类表示 $G_n^{(m)}$ 。 </p><p>注意力分数  $ \alpha ^{(m)}(x<em>{n,i}) = softmax(Q(x</em>{n,i})^T \cdot G_n^{(m)})$</p><p>请注意，注意力分数的计算与标准做法略有不同。 发送到task-specific output layer $Att(x_{n,i})$的最终注意力特征集计算如下：</p><script type="math/tex; mode=display">Att(x_{n,i}) = Q(x_{n,i}) + \sum_{y^{(m)}\in y_n} \alpha^{(m)} (x_{n,i}) \cdot G_n^{(m)}</script><p>其中$Q(x<em>{n,i})$ 被视为残差。预测结果由 $\hat y</em>{n,i} = f<em>n(Att(x</em>{n,i}))$ 给出。</p><p>由于输出层、 text encoder 和 global memory 中参数的梯度完全不同，我们通过反向传播更新这些参数。 local memory networks中的参数在反向传播期间不会更新。</p><h3 id="Algorithmic-Analysis"><a href="#Algorithmic-Analysis" class="headerlink" title="Algorithmic Analysis"></a>Algorithmic Analysis</h3><p><img src="https://z3.ax1x.com/2021/10/02/4bZRmj.png" alt=""></p><p>进一步对 MeLL 进行了更深入的分析，重点关注终身学习如何影响计算复杂性。 </p><p>假设我们正在学习一个新任务 $T_j (j&gt;N)$。设 $M$ 是BERT编码器中的参数总数， $d$ 是token嵌入的维数。</p><p>推导出全局记忆 、$T_j$ 的全局记忆、注意力融合层和 $T_j$ 的输出赠分别具有 参数 $K\cdot d$ 、 $|y_j|\cdot d$ 、0 和 $(d+1)|y_j|$ 参数</p><p>与所有第一个 𝑗 任务相关的参数总数为 $M+K\cdot d + (2d+1)\cdot |\cup<em>{n=1}^j y_j|$ ，其中 $M+(d+1)\cdot |\cup</em>{n=1}^j y_j|$ 个参数在反向传播期间是可训练的。</p><p>由于 BERT 编码器具有最多的参数，因此越来越多的任务对模型大小的影响很小。 因此，MeLL 成功解决了参数爆炸问题。此外，与具有重放策略的终身学习算法不同 ，我们的方法不需要任何重放操作。 相反，我们采用复制机制和文本编码器的缓慢更新来避免灾难性的遗忘。</p><h2 id="EXPERIMENTS"><a href="#EXPERIMENTS" class="headerlink" title="EXPERIMENTS"></a>EXPERIMENTS</h2><p><img src="https://z3.ax1x.com/2021/10/02/4b7QSS.png" alt=""></p><h3 id="Baselines"><a href="#Baselines" class="headerlink" title="Baselines"></a>Baselines</h3><ul><li>MTL：对所有任务使用多任务微调方法。在此设置中，我们假设所有任务的数据集都可供我们使用，并且不应用终身学习设置。该模型可以产生我们工作中的上界模型性能。</li><li>Single：为每个任务训练一个BERT分类器。当任务数较大时，不可避免地会出现参数爆炸问题。</li><li>Lifelong-freeze：首先在𝑁基本任务上使用多任务微调方法。接下来，它冻结BERT编码器，并且只调优每个新任务的特定于任务的输出层。</li><li>Lifelong-seq: 与“Lifelong-freeze”类似，不同之处在于当新任务到达时，BERT编码器也将以顺序方式进行调优。因此，它可能会遭受灾难性的遗忘问题。</li><li>Lifelong-replay: 是“Lifelong-seq”的扩展，它使用从先前任务中随机抽样的数据作为经验回放来重新训练先前任务的模型。</li></ul><p><img src="https://z3.ax1x.com/2021/10/02/4bHu7R.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/10/02/4bL2HH.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/10/02/4bO1VH.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MeLL-Large-scale-Extensible-User-Intent-Classification-for-Dialogue-Systems-with-Meta-Lifelong-Learning&quot;&gt;&lt;a href=&quot;#MeLL-Large-scale-</summary>
      
    
    
    
    
    <category term="context detection" scheme="http://example.com/tags/context-detection/"/>
    
  </entry>
  
  <entry>
    <title>第五届达观杯——风险事件标签识别比赛复盘</title>
    <link href="http://example.com/2021/10/01/%E7%AC%AC%E4%BA%94%E5%B1%8A%E8%BE%BE%E8%A7%82%E6%9D%AF%E2%80%94%E2%80%94%E9%A3%8E%E9%99%A9%E4%BA%8B%E4%BB%B6%E6%A0%87%E7%AD%BE%E8%AF%86%E5%88%AB%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%9B%98/"/>
    <id>http://example.com/2021/10/01/%E7%AC%AC%E4%BA%94%E5%B1%8A%E8%BE%BE%E8%A7%82%E6%9D%AF%E2%80%94%E2%80%94%E9%A3%8E%E9%99%A9%E4%BA%8B%E4%BB%B6%E6%A0%87%E7%AD%BE%E8%AF%86%E5%88%AB%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%9B%98/</id>
    <published>2021-10-01T07:25:41.000Z</published>
    <updated>2021-10-03T14:26:03.625Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第五届达观杯Rank4——风险事件标签识别比赛复盘"><a href="#第五届达观杯Rank4——风险事件标签识别比赛复盘" class="headerlink" title="第五届达观杯Rank4——风险事件标签识别比赛复盘"></a>第五届达观杯Rank4——风险事件标签识别比赛复盘</h1><p>成绩：A榜第5，B榜第4，最终分数分别为：0.62411600、0.58140504</p><p>比赛链接：<a href="https://www.datafountain.cn/competitions/512">https://www.datafountain.cn/competitions/512</a></p><p>代码：<a href="https://github.com/Coding-Zuo/DaguanFengxian">https://github.com/Coding-Zuo/DaguanFengxian</a></p><h2 id="赛题任务"><a href="#赛题任务" class="headerlink" title="赛题任务"></a>赛题任务</h2><p>这个比赛的全名是叫：基于大规模预训练模型的风险事件标签识别，在技术层面上可以提取为两个任务，一个是预训练一个是文本分类。</p><p>针对预训练赛题方给了一个70g的无标注预训练文本，训练集有14009条，测试集6004条（包含AB榜数据）</p><p>赛题全部为脱敏数据（所有文字都转换成了数字表达）脱敏前的数据样例为：</p><div class="table-container"><table><thead><tr><th style="text-align:center">资讯文本</th><th style="text-align:center">风险事件标签</th></tr></thead><tbody><tr><td style="text-align:center">新冠肺炎疫情给美国劳动力市场造成巨大冲击，首次申请失业救济人数已经连续19周超过100万人，约为疫情暴发前平均水平的6倍</td><td style="text-align:center">宏观_经济数据下滑</td></tr><tr><td style="text-align:center">石化公司双苯厂发生爆炸事故，造成大量苯类污染物进入江河水体，造成重大环境污染</td><td style="text-align:center">事故_生产设施</td></tr><tr><td style="text-align:center">市场监管局执法人员对5家品牌奶茶店进行了检查，发现多家门店存在工作人员健康证不齐全、原材料管理不善等问题</td><td style="text-align:center">卫生_食品安全</td></tr><tr><td style="text-align:center">脱敏后</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">210 21048 4210 751252 10 21048 4210 75 125210 21048 4210 75125…..</td><td style="text-align:center">1-3</td></tr></tbody></table></div><p>在标签列可以看到样本有一级和二级标签之分，共有10个一级，35个二级标签。评价指标为macro F1。</p><p>我们尝试过一级标签和二级标签的联合预测，效果不好。</p><p>标签类别很多而且不平衡，多的类别上千条，少的类别只有十几个：</p><p><img src="https://z3.ax1x.com/2021/10/01/47Mv7j.png" alt=""></p><p>接下来我将分别从预训练模型、模型结构、提分技巧、模型融合复盘整个比赛过程。</p><h2 id="预训练模型"><a href="#预训练模型" class="headerlink" title="预训练模型"></a>预训练模型</h2><p>预训练模型百度网盘地址：链接：<a href="https://pan.baidu.com/s/1GCs1m6HiXenurGbjUBetFw">https://pan.baidu.com/s/1GCs1m6HiXenurGbjUBetFw</a> 提取码：fxth</p><p>对应代码部分：<a href="https://github.com/Coding-Zuo/DaguanFengxian/tree/main/bert_model/pretrain">https://github.com/Coding-Zuo/DaguanFengxian/tree/main/bert_model/pretrain</a></p><p>运行过程 处理数据 process_data —&gt; 构建词表 build_vocab —&gt; run pretrain</p><p>我们在无标注数据中根据cosine距离选择了四万条和训练集中样本相似的数据进行预训练。</p><p>分别预训练了bert-base模型 nezha-base模型，nezha与bert的区别主要是</p><p>nezha相比于google开源中文bert使用了更大的预训练语料，还使用了相对位置编码是一种有效的位置编码方案，全字掩蔽策略，混合精度训练和LAMB优化器。</p><p>nezha首次将函数型的相对位置编码加入了模型中。好处：主要是因为它可以使模型外推到比训练中遇到的序列长的序列长度。Bert针对每个位置合并了绝对位置编码，该绝对位置编码是嵌入向量，并且直接添加到token embedding。</p><p>我们对每种模型保存不同训练步数的checkpoint，可以用于后面的模型融合。</p><p>其实预训练策略可以做很多花样的文章，但由于机器有限，我们将主要的精力放在了微调方面。预训练策略只是遵循mlm和nsp。</p><p>我们主要使用过的预训练模型有：</p><ul><li>Bert-base-wwm-ext : 哈工大开源版本</li><li>Nezha-wwm-base: 哪吒官方开源版本</li><li>Bert120k: 预训练12万step</li><li>Bert150k: 预训练15万step</li><li>Bert80k: 预训练8万step</li><li>Nezha80k：预训练8万step</li><li>Nezha110k：预训练11万step</li><li>Nezha150k：预训练15万step</li></ul><p>最一开始是使用了word2vec在语料库上进行训练，代码：<a href="https://github.com/Coding-Zuo/DaguanFengxian/tree/main/baseline/src/classic_models/word2vec">https://github.com/Coding-Zuo/DaguanFengxian/tree/main/baseline/src/classic_models/word2vec</a> 线上第一次提交是 48点多分 排了七十多名。</p><p>然后开始使用bert等开源的权重，那么问题来了脱敏数据里词都是那样的，bert词表用不了怎么办？</p><ul><li>统计脱敏数据的词频，将对应词频与开源词表上的词频进行对换 (最开始使用的是这种) 线上可达50分左右</li><li>将word2vec训练好的embedding替换到bert上</li></ul><p>虽然无法还原句子，但频率估计可以还原一部分词，两个频率高的文本，在同一种语境下出现的概率更大，从语义相关性角度来说，可能会有一些语义相关性，改用明文后就可以随便用预训练语言模型了。</p><h2 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h2><p>我们最终的模型结构大致是：</p><p>Bert  —&gt;  BiLSTM 1层 —&gt; BiGRU 1层 —&gt; bert_pooler + 胶囊网络 —&gt; Multi-Sample Dropout预测输出</p><p>同时加BiLSTM和BiGRU大概有接近一个点的提高。胶囊网络有的预训练模型有一点点提高，但有的有负效果。</p><p>还尝试过 用 max_pooling + avg_pooling + 胶囊网络 + bert_pooling等组合，效果均不如直接使用bert_pooler和胶囊网络。</p><h2 id="提分技巧"><a href="#提分技巧" class="headerlink" title="提分技巧"></a>提分技巧</h2><h3 id="面对不均衡-dice-loss-amp-focal-loss-amp-cross-entropy-loss"><a href="#面对不均衡-dice-loss-amp-focal-loss-amp-cross-entropy-loss" class="headerlink" title="面对不均衡 dice loss &amp; focal loss &amp; cross entropy loss"></a>面对不均衡 dice loss &amp; focal loss &amp; cross entropy loss</h3><p>代码位置：<a href="https://github.com/Coding-Zuo/DaguanFengxian/tree/main/bert_model/training">https://github.com/Coding-Zuo/DaguanFengxian/tree/main/bert_model/training</a></p><p>样本不均衡会带来什么问题呢？</p><p>模型训练的本质是最小化损失函数，当某个类别的样本数量非常庞大，损失函数的值大部分被样本数量较大的类别所影响，导致的结果就是模型分类会倾向于样本量较大的类别。</p><p>通过类别加权Loss解决, 下图截自香侬科技的论文《Dice Loss for Data-imbalanced NLP Tasks》，分别列举了加权loss，Focal loss（FL）和他们提出的dice loss。我们的实验效果是：FL &lt; Weigth CE &lt; dice loss。所以主要采用了weight ce和dice loss。</p><p><img src="https://i.loli.net/2021/09/01/YkHOMIlVSPjG5aw.png" alt=""></p><p>Weight CE通过基于类别的加权的方式可以从不同类别的样本数量角度来控制Loss值，从而一定程度上解决了样本不均衡的问题。</p><p>基于类别加权Loss虽然在一定程度上解决了样本不均衡的问题，但是实际的情况是不仅样本不均衡会影响Loss，而且样本的难易区分程度也会影响Loss。</p><p>何恺明在论文《Focal Loss for Dense Object Detection》中提出了的Focal Loss，上图第三个公式。对于模型预测为正例的样本也就是p&gt;0.5的样本来说，如果样本越容易区分那么(1-p)的部分就会越小，相当于乘了一个系数很小的值使得Loss被缩小，也就是说对于那些比较容易区分的样本Loss会被抑制，同理对于那些比较难区分的样本Loss会被放大，这就是Focal Loss的核心：<strong>通过一个合适的函数来度量简单样本和困难样本对总的损失函数的贡献。</strong></p><p>dice loss香侬科技的这篇论文可以参考：<a href="https://coding-zuo.github.io/2021/09/01/Dice-Loss-for-Data-imbalanced-NLP-Tasks/">Dice Loss for Data-imbalanced NLP Tasks</a></p><p>交叉熵“平等”地看待每一个样本，无论正负，都尽力把它们推向1（正例）或0（负例）。但实际上，对分类而言，将一个样本分类为负只需要它的概率＜0.5即可，完全没有必要将它推向0。Dice Loss的自适应损失——DSC，在训练时推动模型更加关注困难的样本，降低简单负例的学习度，从而在整体上提高基于F1值的效果。</p><h3 id="对比学习"><a href="#对比学习" class="headerlink" title="对比学习"></a>对比学习</h3><p>代码位置：<a href="https://github.com/Coding-Zuo/DaguanFengxian/blob/main/bert_model/models/modeling_nezha1.py">https://github.com/Coding-Zuo/DaguanFengxian/blob/main/bert_model/models/modeling_nezha1.py</a></p><p>对比损失可以关注判别更困难的样本。</p><p>Feature学习是各类深度学习模型的一个基础、重要的功能。好的feature，将有助于文本任务性能的提升。</p><p>表示学习的目标是为输入x 学习一个表示 z，那么如何衡量一个表示z 的好坏可以通过互信息的形式；</p><p>互信息：代表我们知道了 z 之后 x的信息量减少了多少，</p><p>InfoNCE （又称ntxent loss）</p><script type="math/tex; mode=display">L_q = - log\frac{exp(q\cdot k_+ /\tau)}{\sum_{i=0}^K exp(q\cdot k_i / \tau)}</script><p>实质：核心是通过计算样本表示的距离，拉近正样本，拉远负样本</p><p>自监督的时候可以自行构造正负样本，那么有监督的时候就可以根据不同的样本标签来构建正负样本。</p><p><img src="https://z3.ax1x.com/2021/10/03/4LineI.png" alt=""></p><p>最大化相同标签的样本相似度，让不同样本标签的相似度比较小。</p><p>参考论文 《Supervised Contrastive Learning》、《SUPERVISED CONTRASTIVE LEARNING FOR PRE-TRAINED LANGUAGE MODEL FINE-TUNING》</p><h3 id="对抗训练"><a href="#对抗训练" class="headerlink" title="对抗训练"></a>对抗训练</h3><p>代码位置：<a href="https://github.com/Coding-Zuo/DaguanFengxian/blob/main/bert_model/training/Adversarial.py">https://github.com/Coding-Zuo/DaguanFengxian/blob/main/bert_model/training/Adversarial.py</a></p><p>很多人反映对抗训练没有效果，我最一开始的结果也是这样的。在开源版的nezha和bert上都会降分。</p><p>但随着预训练模型越来越多，模型越来越稳定，对抗训练就可以提分了。在预训练后的nezha上基本上是pgd比较好，但比较耗时，在bert上fgm有时会好一点。每个预训练模型的使用效果都不太一样。</p><p>我们还尝试了，不仅在bert的word_embedding上做扰动，还在encoder的第0层做扰动，同时随机在某个batch上不扰动，效果相差不多。</p><p>在验证集的效果对比：</p><ul><li>Nezha110k_noAdv: 0.5598</li><li>Nezha110k_fgm: 0.5639</li><li>Nezha110k_pgd: 0.5687</li><li>Bert80k_noAdv: 0.5542</li><li>Bert80k_fgm:0.5557</li><li>Bert80k_pgd:0.5650</li><li>Bert80k_fgm_advEncoder_random:0.5585</li><li>Bert80k_pgd_advEncoder_random:0.5684</li></ul><h3 id="Multi-Exit"><a href="#Multi-Exit" class="headerlink" title="Multi-Exit"></a>Multi-Exit</h3><p>代码位置：<a href="https://github.com/Coding-Zuo/DaguanFengxian/blob/main/bert_model/models/modeling_bert_pabee.py">https://github.com/Coding-Zuo/DaguanFengxian/blob/main/bert_model/models/modeling_bert_pabee.py</a></p><p>Bert 究竟在哪一层做输出会比较好呢？下图是在nezha80k上进行的实验，普遍发现在第layer9，也就是第10层的输出下普遍较好。其实实验下来发现整体效果不好就放弃了，但后来想想可能是因为12层输出联合训练导致的F1值偏低。其实发现第10层可能比较好，就干脆只用第十层的输出计算loss就好。但后来没有继续尝试。</p><p><img src="https://z3.ax1x.com/2021/10/03/4qBq9x.png" alt=""></p><h3 id="flooding洪泛法"><a href="#flooding洪泛法" class="headerlink" title="flooding洪泛法"></a>flooding洪泛法</h3><p>在最开始使用开源未经预训练的bert进行探索的过程中发现，验证集loss上升，acc也上升。但随着预训练模型的越来越稳定，这种现象就不存在了。</p><p><img src="https://z3.ax1x.com/2021/10/03/4qwGKe.png" alt=""></p><p>这种现象很常见，原因是过拟合或者训练验证数据分布不一致导致，即在训练后期，预测的结果趋向于极端，使少数预测错的样本主导了loss，但同时少数样本不影响整体的验证acc情况。ICML2020发表了一篇文章：《<a href="https://link.zhihu.com/?target=https%3A//arxiv.org/pdf/2002.08709.pdf">Do We Need Zero Training Loss After Achieving Zero Training Error?</a>》，描述了上述现象出现的原因，同时提出了一种flooding策略，通过超参数b控制训练loss不要过小，阻止进一步过拟合，在此情况下，使model”random walk”至一个泛化能力更好的结果，参考 <a href="https://wmathor.com/index.php/archives/1551/">我们真的需要把训练集的损失降到零吗？</a> 。上图左是加洪泛之前， 上图右是加洪泛之后的，训练集验证集每轮的loss。超参数b的值大概0.2左右小一些。对于模型效果来说，整体影响不大，训练的稍微稳定一点，比赛后期没有再用。</p><h3 id="Multi-sample-Dropout"><a href="#Multi-sample-Dropout" class="headerlink" title="Multi-sample Dropout"></a>Multi-sample Dropout</h3><p>代码位置：<a href="https://github.com/Coding-Zuo/DaguanFengxian/blob/main/bert_model/models/layers.py">https://github.com/Coding-Zuo/DaguanFengxian/blob/main/bert_model/models/layers.py</a></p><p>dropout目前是NLP任务中很流行的数据扩充手段。Multi-Sample Dropout是对Dropout方法的一种改进，是2019年的一篇工作。Multi-Sample Dropout相比于dropout加快了模型训练过程的收敛速度和提高了泛化能力。</p><p><img src="https://z3.ax1x.com/2021/10/03/4L7NfP.png" alt=""></p><p>假设样本经过网络的编码层部分进行编码后得到一个向量表征。这时候，传统的Dropout会对向量表征作用一次，然后输入到分类层进行预测。而Multi-sample Dropout由多个Dropout操作完成。对一个向量表征进行多次dropout后，相当于形成了向量表征的多个版本的。这些不同版本的向量表征通过分类器得到标签的不同概率预测，最终的预测概率分布通过求和或者平均得到。</p><p>在比赛的实验中发现，dropout的数量为4，聚合的方式以加和的形式比average效果要好。dropout_rate最开始设为0.4。但后来慢慢发现有时，模型训着训着F1直接变成0了，而且只在bert模型上出现这种问题。找了几天原因发现dropout_rate不能设的太大，改成了0.2。</p><h3 id="伪标签"><a href="#伪标签" class="headerlink" title="伪标签"></a>伪标签</h3><p>关于伪标签，我个人认为总体指标达不到八十以上的比赛可能不太好管用。尤其这个赛题还是样本极其不均匀的就更不适合。因为第一，模型预测的把握度不大，根据我们线上59分的模型，预测概率为百分之40以上的测试集数据不到1500条，这在伪标签准确度上带来了不确定性。第二样本不均匀，如果直接把这1500条插入到训练集，可能会破坏训练集的一些分布，造成模型不稳定，学跑偏了。</p><p>测试结果：线上58.7的模型，在伪标签上重新训练后是58.3分。</p><h2 id="模型融合"><a href="#模型融合" class="headerlink" title="模型融合"></a>模型融合</h2><p>代码位置： <a href="https://github.com/Coding-Zuo/DaguanFengxian/tree/main/bert_model/ensemble">https://github.com/Coding-Zuo/DaguanFengxian/tree/main/bert_model/ensemble</a></p><h3 id="stacking"><a href="#stacking" class="headerlink" title="stacking"></a>stacking</h3><p><img src="https://z3.ax1x.com/2021/10/03/4qrZz6.png" alt=""></p><p>跑了四折的四种预训练模型的stacking。最后的第二层预测使用的是xgboost，整体效果没有达到预期，线上得分仅0.5707</p><p>四折的四种模型效果如下：</p><p><img src="https://z3.ax1x.com/2021/10/03/4qrqOO.png" alt=""></p><p>效果不佳的原因可能和拆分四折的数据分布有关，导致单模分数不是很高。由于样本不均衡，原先的拆分方法是针对不同类别有放回的随机取样做五折，随机性比较大，不容易过拟合。</p><p>为了让模型凑齐所有训练集的预测特征，且不让数据有重复，我使用了无放回的采样，针对不同类别的样本，按顺序分段提取每折样本，并且根据数据id去了一遍重。 在实验的时候发现不同折的数据分布对模型效果影响还蛮大的。</p><h3 id="投票-rank-概率平均"><a href="#投票-rank-概率平均" class="headerlink" title="投票+rank/概率平均"></a>投票+rank/概率平均</h3><p>投票在这次比赛效果非常好。</p><p>第一次融七个模型，模型平均分大概五十四五。</p><ul><li>投票线上结果：0.5809</li><li>投票，针对票数相同的结果，选择结果在每个模型的预测rank最靠前的作为结果：0.5852</li><li>投票，针对票数相同的结果，选择每个预测结果的概率平均值最大的作为结果：0.5850</li><li>根据七个模型的logits选最大的作为预测结果：0.5549</li><li>根据预测的概率加和取平均的线上结果：0.5618</li></ul><p>模型平均分大概57.5分左右</p><ul><li>投票+rank ：0.6201</li></ul><p>最后将所有线上得分超过60分的测试集结果再放到一起，再进行投票得到最后的最终成绩：0.6241</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://kexue.fm/archives/8213">短文本匹配Baseline：脱敏数据使用预训练模型的尝试</a></p><p><a href="https://github.com/823316627bandeng/2021-Daguan-Cup">https://github.com/823316627bandeng/2021-Daguan-Cup</a></p><p><a href="https://zhuanlan.zhihu.com/p/412897603/">【2021 第五届“达观杯” 基于大规模预训练模型的风险事件标签识别】1 初赛Rank12的总结与分析</a></p><p><a href="https://blog.csdn.net/u011630575/article/details/81302994">模型融合—— stacking详细讲解</a></p><p><a href="https://zhuanlan.zhihu.com/p/141172794?ivk_sa=1024320u">对比学习（Contrastive Learning）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第五届达观杯Rank4——风险事件标签识别比赛复盘&quot;&gt;&lt;a href=&quot;#第五届达观杯Rank4——风险事件标签识别比赛复盘&quot; class=&quot;headerlink&quot; title=&quot;第五届达观杯Rank4——风险事件标签识别比赛复盘&quot;&gt;&lt;/a&gt;第五届达观杯Rank4</summary>
      
    
    
    
    
    <category term="DataGame" scheme="http://example.com/tags/DataGame/"/>
    
  </entry>
  
  <entry>
    <title>22-括号生成(回溯&amp;深搜)</title>
    <link href="http://example.com/2021/09/30/22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90-%E5%9B%9E%E6%BA%AF-%E6%B7%B1%E6%90%9C/"/>
    <id>http://example.com/2021/09/30/22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90-%E5%9B%9E%E6%BA%AF-%E6%B7%B1%E6%90%9C/</id>
    <published>2021-09-30T01:24:20.000Z</published>
    <updated>2021-10-02T01:06:13.326Z</updated>
    
    <content type="html"><![CDATA[<h1 id="22-括号生成-回溯-amp-深搜"><a href="#22-括号生成-回溯-amp-深搜" class="headerlink" title="22-括号生成(回溯&amp;深搜)"></a>22-括号生成(回溯&amp;深搜)</h1><h4 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode-cn.com/problems/generate-parentheses/">22. 括号生成</a></h4><p>这一类问题是在一棵隐式的树上求解，可以用深度优先遍历，也可以用广度优先遍历。<br>一般用深度优先遍历。原因是：</p><ul><li>代码好写，使用递归的方法，直接借助系统栈完成状态的转移；</li><li>广度优先遍历得自己编写结点类和借助队列。</li></ul><p>这里的「状态」是指程序执行到 隐式树 的某个结点的语言描述，在程序中用不同的 变量 加以区分。</p><h2 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h2><p>减法</p><p><img src="https://z3.ax1x.com/2021/09/30/4IKLu9.png" alt=""></p><p>画图以后，可以分析出的结论：</p><ul><li>当前左右括号都有大于 0 个可以使用的时候，才产生分支；</li><li>产生左分支的时候，只看当前是否还有左括号可以使用；</li><li>产生右分支的时候，还受到左分支的限制，右边剩余可以使用的括号数量一定得在严格大于左边剩余的数量的时候，才可以产生分支；</li><li>在左边和右边剩余的括号数都等于 0 的时候结算。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 做减法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 特判</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行深度优先遍历，搜索可能的结果</span></span><br><span class="line">        dfs(<span class="string">&quot;&quot;</span>, n, n, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> curStr 当前递归得到的结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left   左括号还有几个可以使用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right  右括号还有几个可以使用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> res    结果集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String curStr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, List&lt;String&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 因为每一次尝试，都使用新的字符串变量，所以无需回溯</span></span><br><span class="line">        <span class="comment">// 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(curStr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节）</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dfs(curStr + <span class="string">&quot;(&quot;</span>, left - <span class="number">1</span>, right, res);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (right &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dfs(curStr + <span class="string">&quot;)&quot;</span>, left, right - <span class="number">1</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们不用减法，使用加法，即 <code>left</code> 表示「左括号使用了几个」，<code>right</code> 表示「右括号使用了几个」，可以画出另一棵递归树。</p><p><img src="https://z3.ax1x.com/2021/09/30/4IMFud.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 做加法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 特判</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(<span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, n, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> curStr 当前递归得到的结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left   左括号已经用了几个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right  右括号已经用了几个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n      左括号、右括号一共得用几个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> res    结果集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String curStr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> n, List&lt;String&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == n &amp;&amp; right == n) &#123;</span><br><span class="line">            res.add(curStr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 剪枝</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &lt; n) &#123;</span><br><span class="line">            dfs(curStr + <span class="string">&quot;(&quot;</span>, left + <span class="number">1</span>, right, n, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; n) &#123;</span><br><span class="line">            dfs(curStr + <span class="string">&quot;)&quot;</span>, left, right + <span class="number">1</span>, n, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="回溯算法与深度优先遍历"><a href="#回溯算法与深度优先遍历" class="headerlink" title="回溯算法与深度优先遍历"></a>回溯算法与深度优先遍历</h2><p>回溯法 采用试错的思想，它尝试分步去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其他的可能的分布解答再次尝试寻找问题的答案。回溯法 通常用递归方法来实现，在反复重复上述的步骤之后可能出现两种情况：</p><ul><li>找到一个可能存在的答案</li><li>在尝试了所有可能的分步方法后宣告该问题没有答案</li></ul><p><strong>深度优先搜索</strong> 算法（Depth-First-Search，DFS）是一种用于遍历或搜索树或图的算法。这个算法会尽可能深的搜索树的分支。当节点v的所在边都已被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点位置。如果还存咋未发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行指导所有节点都被访问为止。</p><p>「回溯算法」与「深度优先遍历」都有「不撞南墙不回头」的意思。「回溯算法」强调了「深度优先遍历」思想的用途，用一个 <strong>不断变化</strong> 的变量，在尝试各种可能的过程中，搜索需要的结果。强调了 回退操作 对于搜索的合理性。而「深度优先遍历」强调一种遍历的思想，与之对应的遍历思想是「广度优先遍历」。至于广度优先遍历为什么没有成为强大的搜索算法，我们在题解后面会提。</p><p>在「力扣」第 51 题的题解《<a href="https://leetcode-cn.com/problems/n-queens/solution/gen-ju-di-46-ti-quan-pai-lie-de-hui-su-suan-fa-si-/">回溯算法（第 46 题 + 剪枝）</a>》 中，展示了如何使用回溯算法搜索 4 皇后问题的一个解，相信对直观地理解「回溯算法」是有帮助。</p><h2 id="搜索与遍历"><a href="#搜索与遍历" class="headerlink" title="搜索与遍历"></a>搜索与遍历</h2><p>我们每天使用的搜索引擎帮助我们在庞大的互联网上搜索信息。搜索引擎的「搜索」和「回溯搜索」算法里「搜索」的意思是一样的。</p><p>搜索问题的解，可以通过 遍历 实现。所以很多教程把「回溯算法」称为爆搜（暴力解法）。因此回溯算法用于 搜索一个问题的所有的解 ，通过深度优先遍历的思想实现。</p><h2 id="与动态规划的区别"><a href="#与动态规划的区别" class="headerlink" title="与动态规划的区别"></a>与动态规划的区别</h2><p>共同点：用于求解多阶段决策问题。多阶段决策问题即：</p><ul><li>求解一个问题分为很多步骤(阶段)</li><li>每个步骤(阶段) 可以有多种选择</li></ul><p>不同点：</p><ul><li>动态规划只需要求我们评估的最优解是多少，最优解对应的具体解是什么并不要求。因此 很适合用于评估一个方案的效果。</li><li>回溯算法可以搜索 得到所有的方案(当然也包括最优解)，但是本质上它是一种遍历算法，时间复杂度很高。</li></ul><h2 id="从全排列问题开始理解回溯算法"><a href="#从全排列问题开始理解回溯算法" class="headerlink" title="从全排列问题开始理解回溯算法"></a>从全排列问题开始理解回溯算法</h2><p>我们尝试在纸上写 3 个数字、4 个数字、5 个数字的全排列，相信不难找到这样的方法。以数组 <code>[1, 2, 3]</code> 的全排列为例。</p><ul><li>先写以1开头的全排列，他们是: $[1,2,3],[1,3,2]$，即1 + $[2,3]$的全排列 （注意：递归结构体现在这里）</li><li>再写以2开头的全排列，他们是: $[2,1,3],[2,3,1]$  ,即 <code>2</code> + <code>[1, 3]</code> 的全排列；</li><li>最后写以 3 开头的全排列，它们是：<code>[3, 1, 2], [3, 2, 1]</code>，即 <code>3</code> + <code>[1, 2]</code> 的全排列。</li></ul><p>总结搜索的方法： 按顺手枚举每一位可能出现的情况，已经选择的数字在当前要选择的数字中不能出现。按照这种策略就能做到不重不漏。这样的思路可以用一个树形结构表示。</p><p><img src="https://z3.ax1x.com/2021/10/01/4Ts5cD.png" alt=""></p><p>说明：</p><ul><li><p>每一个节点表示了求解全排列问题的不同阶段 ，这些阶段通过变量的 「不同的值」体现，这些变量的不同的值，称之为「状态」；</p></li><li><p>使用深度优先遍历有「回头」的过程，在「回头」以后， 状态变量需要设置成为和先前一样 ，因此在回到上一层结点的过程中，需要撤销上一次的选择，这个操作称之为「状态重置」；</p></li><li><p>深度优先遍历，借助系统栈空间，保存所需要的状态变量，在编码中只需要注意遍历到相应的节点的时候，状态变量的值是正确的，具体做法是：往下走一层的时候，path遍历在尾部追加，而往回走的时候，需要撤销上一次的选择，也是在尾部操作， 因此path变量是一个栈</p></li><li><p>深度优先遍历通过回溯操作，实现了全局使用一份状态变量的效果</p></li></ul><p>使用编程的方法得到全排列，就是在这样的一个树形结构中完成 <strong>遍历</strong>，从树的根结点到叶子结点形成的路径就是其中一个全排列。</p><h2 id="设计状态变量"><a href="#设计状态变量" class="headerlink" title="设计状态变量"></a>设计状态变量</h2><ul><li>首先这棵树除了根节点和叶子结点以外，每一个结点做的事情其实是一样的，即：在已经选择了一些数的前提下，在剩下的还没有选择的数中，依次选择一个数，这样显然是一个递归的结构。</li><li>递归的终止条件是：一个排列的数字已经选够了，因此外卖需要一个变量来表示当前程序递归到第几层，外卖把这个变量叫做depath，或者index，表示当前要确定的是某个全排列中下标为index 的那个数是多少。</li><li>布尔数组 used，初始化的时候都为false 表示这些数还没有被选择，当我们选定一个数的时候，就将这个数组的对应位置设为 true，这样在考虑下一个位置的时候，就能以 $O(1)$ 的时间复杂度判断这个数是否被选择过，这是一种以空间换时间的思想。</li></ul><p>这些变量称为「状态变量」，它们表示了在求解一个问题的时候所处的阶段。需要根据问题的场景设计合适的状态变量。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">      <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="comment">// 使用一个动态数组保存所有可能的全排列</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[len];</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(nums, len, <span class="number">0</span>, path, used, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> len, <span class="keyword">int</span> depth, List&lt;Integer&gt; path, <span class="keyword">boolean</span>[] used,</span></span></span><br><span class="line"><span class="function"><span class="params">                    List&lt;List&lt;Integer&gt;&gt; res)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(depth == len)&#123;</span><br><span class="line">          res.add(path);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 在非叶子节点处，产生不同的分支，这一操作的语义是：在还未选择的数中依次选择一个元素作为下一个位置的元素，这显然是通过一个循环实现。</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(!used[i])&#123;</span><br><span class="line">              path.add(nums[i]);</span><br><span class="line">              used[i]=<span class="keyword">true</span>;</span><br><span class="line">              dfs(nums,len,depth+<span class="number">1</span>,path,used,res);</span><br><span class="line">              <span class="comment">//注意：下面这两行代码发生回溯，回溯发生从在深层节点回到浅层节点的过程，代码在形式上和递归前是对称的</span></span><br><span class="line">              used[i] = <span class="keyword">false</span>;</span><br><span class="line">              path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span>[] nums=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">      Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">      List&lt;List&lt;Integer&gt;&gt; lists = solution.permute(nums);</span><br><span class="line">      System.out.println(lists);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        used = [<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size)]</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">nums, size, depth, path, used, res</span>):</span></span><br><span class="line">            <span class="keyword">if</span> depth == size:</span><br><span class="line">                res.append(path)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> used[i]:</span><br><span class="line">                    used[i] = <span class="literal">True</span></span><br><span class="line">                    path.append(nums[i])</span><br><span class="line">                    dfs(nums, size, depth + <span class="number">1</span>, path, used, res);</span><br><span class="line">                    used[i] = <span class="literal">False</span></span><br><span class="line">                    path.pop()</span><br><span class="line"></span><br><span class="line">        dfs(nums, size, <span class="number">0</span>, [], used, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    solution = Solution()</span><br><span class="line">    res = solution.permute(nums)</span><br><span class="line">    print(res)</span><br></pre></td></tr></table></figure><p>执行 <code>main</code> 方法以后输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[], [], [], [], [], []]</span><br></pre></td></tr></table></figure><p>原因出现在递归终止条件这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (depth == len) &#123;</span><br><span class="line">    res.add(path);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> depth == size:</span><br><span class="line">res.append(path)</span><br><span class="line">    <span class="keyword">return</span> </span><br></pre></td></tr></table></figure><p>变量path 所指向的列表在深度优先遍历过程中只有一份，深度优先遍历完成以后，回到了根节点，成为空列表</p><p>在java中，参数传递是值传递，对象类型变量在传参的过程中，复制的是变量的地址。这些地址被添加到res变量，但实际上指向的是同一块内存地址，因此我们会看到6个空的列表对象。解决办法很简单，在 res.add(path)这里做一次拷贝即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(depth == len)&#123;</span><br><span class="line">  res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> depth == size:</span><br><span class="line">  res.append(path[:])</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>复杂度分析：</p><p>回溯算法由于其遍历的特点，时间复杂度一般都比较高，有些问题分析起来很复杂。一些问题剪枝剪得好的话，复杂度会降的很低，因此分析最坏时间复杂度的意义不是很大。但视情况而定</p><p>时间复杂度 $O(N\times N!)$</p><p>非叶子结点的个数，一次为(按层数来)：</p><script type="math/tex; mode=display">1+A_N^1 + A_N^2 +...+A_N^{N-1} = 1 + \frac{N!}{(N-1)!} + \frac{N!}{(N-2)!} +...+N!</script><p>1是根节点，在第一层，节点个数为 N个选一个的排列 故为$A_N^1$</p><p>空间复杂度： $O(N\times N!)$</p><p>递归树深度 $logN$ ，全排列个数 $N!$ , 每个全排列占空间$N$ 。取较大者</p><h3 id="为什么不是广度优先遍历"><a href="#为什么不是广度优先遍历" class="headerlink" title="为什么不是广度优先遍历"></a>为什么不是广度优先遍历</h3><ul><li>首先是正确性，只有遍历状态空间，才能得到所有符合条件的解，这一点 BFS 和 DFS 其实都可以；</li><li>在深度优先遍历的时候，不同状态之间的切换很容易 ，可以再看一下上面有很多箭头的那张图，每两个状态之间的差别只有 11 处，因此回退非常方便，这样全局才能使用一份状态变量完成搜索；</li><li>如果使用广度优先遍历，从浅层转到深层，状态的变化就很大，此时我们不得不在每一个状态都新建变量去保存它，从性能来说是不划算的；</li><li>如果使用广度优先遍历就得使用队列，然后编写结点类。队列中需要存储每一步的状态信息，需要存储的数据很大，真正能用到的很少 。</li><li>使用深度优先遍历，直接使用了系统栈，系统栈帮助我们保存了每一个结点的状态信息。我们不用编写结点类，不必手动编写栈完成深度优先遍历。</li></ul><p>做题的时候，建议 先画树形图 ，画图能帮助我们想清楚递归结构，想清楚如何剪枝。拿题目中的示例，想一想人是怎么做的，一般这样下来，这棵递归树都不难画出。</p><p>在画图的过程中思考清楚：</p><ul><li>分支如何产生；</li><li>题目需要的解在哪里？是在叶子结点、还是在非叶子结点、还是在从跟结点到叶子结点的路径？</li><li>哪些搜索会产生不需要的解的？例如：产生重复是什么原因，如果在浅层就知道这个分支不能产生需要的结果，应该提前剪枝，剪枝的条件是什么，代码怎么写？</li></ul><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="题型一：排列、组合、子集相关问题"><a href="#题型一：排列、组合、子集相关问题" class="headerlink" title="题型一：排列、组合、子集相关问题"></a>题型一：排列、组合、子集相关问题</h3><p>提示：这部分练习可以帮助我们熟悉「回溯算法」的一些概念和通用的解题思路。解题的步骤是：先画图，再编码。去思考可以剪枝的条件， 为什么有的时候用 used 数组，有的时候设置搜索起点 begin 变量，理解状态变量设计的想法。</p><ul><li><p><a href="https://leetcode-cn.com/problems/permutations/">46. 全排列（中等）</a></p></li><li><p><a href="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II（中等）</a>：思考为什么造成了重复，如何在搜索之前就判断这一支会产生重复；</p></li><li><p><a href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和（中等）</a></p></li><li><p><a href="https://leetcode-cn.com/problems/combination-sum-ii/">40. 组合总和 II（中等）</a></p></li><li><p><a href="https://leetcode-cn.com/problems/combinations/">77. 组合（中等）</a></p></li><li><p><a href="https://leetcode-cn.com/problems/subsets/">78. 子集（中等）</a></p></li><li><p><a href="https://leetcode-cn.com/problems/subsets-ii/">90. 子集 II（中等）</a>：剪枝技巧同 47 题、39 题、40 题；</p></li><li><p><a href="https://leetcode-cn.com/problems/permutation-sequence/">60. 第 k 个排列（中等）</a>：利用了剪枝的思想，减去了大量枝叶，直接来到需要的叶子结点；</p></li><li><p><a href="https://leetcode-cn.com/problems/restore-ip-addresses/">93. 复原 IP 地址（中等）</a></p></li></ul><h3 id="题型二：Flood-Fill"><a href="#题型二：Flood-Fill" class="headerlink" title="题型二：Flood Fill"></a>题型二：Flood Fill</h3><p>提示：Flood 是「洪水」的意思，Flood Fill 直译是「泛洪填充」的意思，体现了洪水能够从一点开始，迅速填满当前位置附近的地势低的区域。类似的应用还有：PS 软件中的「点一下把这一片区域的颜色都替换掉」，扫雷游戏「点一下打开一大片没有雷的区域」。</p><p>下面这几个问题，思想不难，但是初学的时候代码很不容易写对，并且也很难调试。我们的建议是多写几遍，忘记了就再写一次，参考规范的编写实现（设置 visited 数组，设置方向数组，抽取私有方法），把代码写对。</p><ul><li><p><a href="https://leetcode-cn.com/problems/flood-fill/">733. 图像渲染（Flood Fill，中等）</a></p></li><li><p><a href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量（中等）</a></p></li><li><p><a href="https://leetcode-cn.com/problems/surrounded-regions/">130. 被围绕的区域（中等）</a></p></li><li><p><a href="https://leetcode-cn.com/problems/word-search/">79. 单词搜索（中等）</a></p></li></ul><p>说明：以上问题都不建议修改输入数据，设置 <code>visited</code> 数组是标准的做法。可能会遇到参数很多，是不是都可以写成成员变量的问题，面试中拿不准的记得问一下面试官</p><h3 id="题型三：字符串中的回溯问题"><a href="#题型三：字符串中的回溯问题" class="headerlink" title="题型三：字符串中的回溯问题"></a>题型三：字符串中的回溯问题</h3><p>提示：字符串的问题的特殊之处在于，字符串的拼接生成新对象，因此在这一类问题上没有显示「回溯」的过程，但是如果使用 StringBuilder 拼接字符串就另当别论。<br>在这里把它们单独作为一个题型，是希望朋友们能够注意到这个非常细节的地方。</p><ul><li><p><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合（中等）</a>，<a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/solution/hui-su-sou-suo-wu-xian-shi-hui-su-yan-du-you-xian-/">题解</a>；</p></li><li><p><a href="https://leetcode-cn.com/problems/letter-case-permutation/">784. 字母大小写全排列（中等）</a>；</p></li><li><p><a href="https://leetcode-cn.com/problems/generate-parentheses/">22. 括号生成（中等）</a> ：这道题广度优先遍历也很好写，可以通过这个问题理解一下为什么回溯算法都是深度优先遍历，并且都用递归来写。</p></li></ul><h3 id="题型四：游戏问题"><a href="#题型四：游戏问题" class="headerlink" title="题型四：游戏问题"></a>题型四：游戏问题</h3><p>回溯算法是早期简单的人工智能，有些教程把回溯叫做暴力搜索，但回溯没有那么暴力，回溯是有方向地搜索。「力扣」上有一些简单的游戏类问题，解决它们有一定的难度，大家可以尝试一下。</p><ul><li><p><a href="https://leetcode-cn.com/problems/n-queens/">51. N 皇后（困难）</a>：其实就是全排列问题，注意设计清楚状态变量，在遍历的时候需要记住一些信息，空间换时间；</p></li><li><p><a href="https://leetcode-cn.com/problems/sudoku-solver/">37. 解数独（困难）</a>：思路同「N 皇后问题」；</p></li><li><p><a href="https://leetcode-cn.com/problems/zuma-game/">488. 祖玛游戏（困难）</a></p></li><li><p><a href="https://leetcode-cn.com/problems/minesweeper/">529. 扫雷游戏（困难）</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;22-括号生成-回溯-amp-深搜&quot;&gt;&lt;a href=&quot;#22-括号生成-回溯-amp-深搜&quot; class=&quot;headerlink&quot; title=&quot;22-括号生成(回溯&amp;amp;深搜)&quot;&gt;&lt;/a&gt;22-括号生成(回溯&amp;amp;深搜)&lt;/h1&gt;&lt;h4 id=&quot;22-</summary>
      
    
    
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Efficient lifelong learning with A-GEM</title>
    <link href="http://example.com/2021/09/28/EFFICIENT-LIFELONG-LEARNING-WITH-A-GEM/"/>
    <id>http://example.com/2021/09/28/EFFICIENT-LIFELONG-LEARNING-WITH-A-GEM/</id>
    <published>2021-09-28T03:26:24.000Z</published>
    <updated>2021-10-05T02:00:35.642Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Efficient-lifelong-learning-with-A-GEM"><a href="#Efficient-lifelong-learning-with-A-GEM" class="headerlink" title="Efficient lifelong learning with A-GEM"></a>Efficient lifelong learning with A-GEM</h1><p>从样本复杂度、计算和内存成本方面研究了当前终身学习方法的效率。</p><p>首先引入了一个新的、更现实的评估协议，学习者只观察每个例子一次，超参数选择是在一个小的、不相交的任务集上完成的，不用于实际的学习体验和评估 .</p><p>其次，引入了一个新的度量标准来衡量学习者获得一项新技能的速度。</p><p>第三，提出了 GEM 的改进版本，称为平均 GEM (A-GEM)，它具有与 GEM 相同甚至更好的性能，同时在计算和内存效率方面几乎与 EWC 和其他基于正则化的方法一样。</p><p>最后，包括A-GEM在内的所有算法，如果提供指定所考虑的分类任务的任务描述符，则可以更快地学习。</p><h2 id="Learning-protocol"><a href="#Learning-protocol" class="headerlink" title="Learning protocol"></a>Learning protocol</h2><p>一种新的学习范式，即学习者对一组与实际用于评估的任务集不相交的任务进行交叉验证。在这种情况下，学习者将必须学习并将在一个全新的任务序列上进行测试，并且它将仅在该数据流上执行一次。</p><p>以前关于终身学习的工作采用直接从监督学习中借用的学习范式。 有 T 个任务，每个任务由训练集、验证集和测试集组成。 在训练期间，学习者根据需要对每个任务的数据进行尽可能多的传递。</p><p>此外，通过根据交叉验证网格搜索所需的次数扫描整个任务序列来调整验证集上的超参数。最后，使用由先前交叉验证过程选择的模型在每个任务的测试集上报告度量。</p><p>由于当前范式违反了我们对 LLL 的更严格定义，即学习者只能对数据进行一次传递，因为我们想强调从数据中快速学习的重要性，因此现在引入了一种新的学习范式。</p><p>我们考虑由以下有序数据集序列描述的两个任务流：</p><p>$D^{CV}={D<em>1,…,D</em>{T^{CV}}}$  和 $D^{EV} = {D_{T^{CV}+1},…,D_T}$</p><p>其中 $D<em>k = {(x_i^k,t_i^k,y_i^k)</em>{i=1}^{n_k}}$  是第k个任务的数据集。 $T^{CV}&lt;T$ 在实验中 $T^{CV}=3,T=20$</p><p>我们假设所有数据集都来自相同的任务分布。 为了避免符号混乱，让上下文指定 $D_k$ 是指第 k 个数据集的训练集或测试集。</p><p>$D^{CV}$是交叉验证期间将使用的数据集的流。$D^{CV}$允许学习者出于模型超参数选择的目的多次重放所有样本。</p><p>相反，$D^{EV}$是用于测试集的最终训练和评估的实际数据集。学习者将观察 $D^{EV}$ 中的训练样本一次且仅一次，并且所有指标都将在 $D^{EV}$的测试集上报告。</p><p><img src="https://z3.ax1x.com/2021/09/28/4WN3Nt.png" style="zoom:150%;" /></p><h2 id="Metrics"><a href="#Metrics" class="headerlink" title="Metrics"></a>Metrics</h2><p>引入了一个新的度量标准来衡量学习速度，它有助于量化一个学习算法学习一个新任务的能力—— Learning Curve Area (LCA)</p><p>每个任务的训练数据集 $D_k$ 由总共 $B_k$个小批次组成。在每次呈现一小批任务 $k$ 之后，使用相应的测试集来评估学习者在所有任务上的表现。</p><p>设 $\alpha_{k,i,j}\in [0,1]$是用任务 $k$ 的第 $i$ 个小批次训练模型后，在任务 $j$ 的测试集上评估的准确度。</p><p>假设连续体中的第一个学习任务由1索引 ( $T^{CV}+1$ 对应于 $D^{EV}$ ) ,  $T$ 的最后一个(对于 $D^{CV}$ ，将是 $T^{CV}$)，我们定义了以下指标：</p><h3 id="Average-Accuracy"><a href="#Average-Accuracy" class="headerlink" title="Average Accuracy"></a>Average Accuracy</h3><p>$A\in [0,1]$ 用所有小批量连续训练模型后的平均精度，直到任务k被定义为：</p><script type="math/tex; mode=display">A_k = \frac{1}{k} \sum_{j=1}^k \alpha_{k, B_{k},j}</script><p>$A_T$ 是所有任务的平均准确率，是最后一个任务学习后得到的。这是LLL中最常用的度量。</p><h3 id="Forgetting-Measure"><a href="#Forgetting-Measure" class="headerlink" title="Forgetting Measure"></a>Forgetting Measure</h3><p>$F \in [-1,1]$  模型经过所有小批量连续训练后的平均遗忘，直到任务 k 被定义为：</p><script type="math/tex; mode=display">F_k = \frac{1}{k-1} \sum_{j=1}^{k-1} f_j^k</script><p>其中 $f_j^k$ 是在使用所有小批量训练模型直到任务 k 并计算为：</p><script type="math/tex; mode=display">f_j^k = max_{l\in \{1,...,k-1\}} \alpha_{l,B_l,j} - \alpha_{k, B_k, j}</script><p>在学习完所有任务后测量遗忘很重要，原因有两个。它量化了过去任务的准确率下降，并给出了模型学习新任务的速度的间接概念，因为健忘的模型几乎没有剩余的知识可以转移，特别是如果新任务与其中一个任务更密切相关 。</p><h3 id="Learning-Curve-Area"><a href="#Learning-Curve-Area" class="headerlink" title="Learning Curve Area"></a>Learning Curve Area</h3><p>$LCA \in [0,1]$ 让我们首先定义模型在所有 T 任务训练后的平均 b-shot 性能（其中 b 是小批量数）：</p><script type="math/tex; mode=display">Z_b = \frac{1}{T} \sum_{k=1}^T \alpha_{k,b,k}</script><p>$\beta$ 处的 LCA 是作为  $b \in [0, \beta]$ 函数的收敛曲线 $Z_b$ 的面积：</p><script type="math/tex; mode=display">LCA_{beta} = \frac{1}{\beta+1} \int_0^{\beta} Z_b db = \frac{1}{\beta+1} \sum_{b=0}^{\beta} Z_b</script><p>LCA 有一个直观的解释。 $LCA<em>0$ 是平均 0-shot 表现，与 GEM 中的前向转移相同。 $LCA</em>{\beta}$  是  $Z<em>b$ 曲线下的区域，如果 0-shot 性能好并且学习器学习速度快，则该区域很高。 特别是，可能有两个模型具有相同的 $Z_b$ 或 $A_T$ ，但 $LCA</em>{\beta}$ 非常不同，因为一个模型比另一个学习得快得多，而它们最终都获得了相同的最终精度。 该度量旨在区分这两种情况，并且对于相对较小的 $\beta$ 值是有意义的，因为我们对从少数示例中学习的模型感兴趣。</p><h2 id="Averaged-gradient-episodic-memory-A-GEM"><a href="#Averaged-gradient-episodic-memory-A-GEM" class="headerlink" title="Averaged gradient episodic memory (A-GEM)"></a>Averaged gradient episodic memory (A-GEM)</h2><p>A-GEM 建立在 GEM  的基础上，该算法利用小的情节记忆在单遍设置中表现良好，并对损失函数提出了一个小的改变，使 GEM 在 训练时间，同时保持相似的表现； </p><h3 id="回顾GEM"><a href="#回顾GEM" class="headerlink" title="回顾GEM"></a>回顾GEM</h3><p>GEM在计算和内存成本方面很高。GEM通过为每个任务 $k$ 存储情节记忆 $M_k$ 来避免灾难性遗忘。</p><p>在最小化当前任务 t 的损失的同时，GEM 将任务 k&lt;t 的情景记忆的损失视为不等式约束，避免其增加但允许其减少。</p><script type="math/tex; mode=display">l (f_{\theta}, M_k) = \frac{1}{|M_k|} \sum_{(x_i,k,y_i)\in M_k} l(f_{\theta}(x_i,k),y_i)</script><p>这有效地允许 GEM 进行其他 LLL 方法不支持的 积极反向迁移。 形式上，在任务 t，GEM 解决以下目标：</p><script type="math/tex; mode=display">minimize_{\theta} \ \ l (f_{\theta}, D_t)  \ \ s.t. \ \ l(f_{\theta}^{t-1}, M_k) \ \ \ \ \forall k<t</script><p>其中 $f_{\theta}^{t-1}$ 是训练到任务 $t−1$ 的网络，为了检查损失的增加，GEM 计算先前任务的损失梯度 $g_k$ 向量与当前任务 $g$ 的梯度更新之间的角度。只要与任何 $g_k$ 的角度大于 90°，它就会将建议的梯度投影到 L2 范数梯度 $\hat g$ 中最接近的，从而使角度保持在边界内。 形式上，GEM 解决的优化问题由下式给出：</p><script type="math/tex; mode=display">minimize_{\hat g} \ \ \frac{1}{2}||g-\hat g||_2^2  \ \ \ s.t. \ \ <\hat g,g_k> \ge0  \ \ \ \forall k<t</script><p>这是一个 凸优化中二次规划的问题， P 变量（网络中的参数数量）中的二次规划 (QP)，对于神经网络而言，可能是数百万。为了有效地解决这个问题，GEM 在对偶空间中工作，这导致只有 t − 1 个变量的更小的 QP：</p><script type="math/tex; mode=display">minimize_v \ \  \frac{1}{2}v^TGG^Tv + g^TG^Tv \ \ s.t. \ \ v\ge0</script><p>其中 $G = -(g<em>1,…,g</em>{t-1}) \in R^{(t-1)\times P}$ 是在训练的每个梯度步骤计算的。一旦上式找到最优解 $v^{<em>}$， 投影梯度可以计算为：$\hat g =G^Tv^{</em>} + g$</p><p>虽然 GEM 已被证明在单个 epoch 设置中非常有效，但性能提升的前提是训练时的计算负担很大。在每个训练步骤中，GEM使用情景记忆中的所有样本来计算矩阵 $G$ ，并且它还需要求解QP。当M的大小和任务数量很大时，此内循环优化变得令人望而却步。</p><p><img src="https://z3.ax1x.com/2021/09/28/4fSh5T.png" alt=""></p><h3 id="A-GEM"><a href="#A-GEM" class="headerlink" title="A-GEM"></a>A-GEM</h3><p>GEM 确保在每个训练步骤中，每个单独的先前任务的损失（由情景记忆中的样本近似）不会增加</p><p>而 A-GEM 试图确保在每个训练步骤中，先前任务的平均情景记忆损失不会增加。 形式上，在学习任务 t 时，A-GEM 的目标是：</p><script type="math/tex; mode=display">minimize_{\theta} \ \ \ l(f_{\theta}, D_t) \ \ \ s.t. \ \ l(f_{\theta}, M) \le l (f_{\theta}^{t-1}, M) \ \ where \ M =\cup_{k<t} M_{k}</script><p>相应的优化问题简化为：</p><script type="math/tex; mode=display">minimize_{\hat g} \ \ \frac{1}{2}||g-\hat g||_2^2 \ \ s.t. \ \ \hat g^Tg_{ref} \ge 0</script><p> 其中 $g<em>{ref}$ 是使用从情节记忆 $(x</em>{ref},y_{ref}) \sim M$ 中随机采样的批次计算得出的梯度。</p><p>换句话说，A-GEM 用单个约束替换了 GEM 的 t-1 约束，其中 $g_{ref}$ 是从情景记忆的随机子集计算出的先前任务的梯度的平均值。</p><p>现在可以非常快速地解决上面方程的约束优化问题； 当梯度 g 违反约束时，它通过以下方式进行投影：</p><script type="math/tex; mode=display">\hat g = g- \frac{g^Tg_{ref}}{g^{T}_{ref}g_{ref}} g_{ref}</script><p>这使得 A-GEM 不仅内存高效，因为它不需要存储矩阵 G，而且比 GEM 快几个数量级，因为 </p><ul><li><p>1）不需要计算矩阵 G 而只需要计算内存样本的随机子集的梯度 </p></li><li><p>2）它不需要解决任何 QP，只需要解决一个内积</p></li><li><p>3）它会产生更少的违背约束，特别是当任务数量很大时。 </p><p>所有这些因素一起使 A-GEM 更快，同时不会妨碍其在单程设置中的良好性能。</p></li></ul><h3 id="证明推导-A-GEM-update-rule"><a href="#证明推导-A-GEM-update-rule" class="headerlink" title="证明推导 A-GEM update rule"></a>证明推导 A-GEM update rule</h3><p>给出了A-GEM更新规则 $\hat g = g- \frac{g^Tg<em>{ref}}{g^{T}</em>{ref}g<em>{ref}} g</em>{ref}$ 的证明</p><p>A-GEM的优化目标:</p><script type="math/tex; mode=display">minimize_{\hat g} \ \ \frac{1}{2}||g-\hat g||_2^2 \ \ s.t. \ \ \hat g^Tg_{ref} \ge 0</script><p>将 $\hat g$ 替换为 $z$，并重写：</p><script type="math/tex; mode=display">minimize_{\hat g} \ \ \frac{1}{2} z^z -g^z \ \ s.t. \ -z^Tg_{ref}\le 0</script><p>请注意，目标中丢弃了项 $g^Tg$，并更改了不等式约束的符号。 上面定义的约束优化问题的拉格朗日可以写成：</p><script type="math/tex; mode=display">L(z,\alpha) = \frac{1}{2} z^Tz - g^z - \alpha z^Tg_{ref}</script><p>方程的对偶：</p><script type="math/tex; mode=display">\theta_D(\alpha) = min_z L(z,\alpha)</script><p>通过将 $L(z, \alpha)$ 相对于 z 的导数设置为零来找到最小化 $L(z, \alpha)$ 的值 $z^∗$：</p><script type="math/tex; mode=display">\nabla_z L(z,\alpha) = 0 \ ,\ z^* = g+\alpha g_{ref}</script><p>代入 $z^∗$ 值后的简化对偶:</p><script type="math/tex; mode=display">\theta_D(\alpha) = \frac{1}{2} (g^Tg +2\alpha g^Tg_{ref} +\alpha^2 g^Tg_{ref} ) - g^Tg-2\alpha g^Tg_{ref} - \alpha^2g_{ref}^Tg_{ref} \\= -\frac{1}{2}g^Tg - \alpha g^Tg_{ref} - \frac{1}{2}^2g_{ref}^Tg_{ref}</script><p>对偶的解 $\alpha^* = max<em>{\alpha;\alpha&gt;0} \theta</em>{D}(\alpha)$ ：</p><script type="math/tex; mode=display">\nabla_{\alpha} \theta_D(\alpha)  = 0 \ ,\ \alpha^* = -\frac{g^Tg_{ref}}{g^T_{ref}g_{ref}}</script><p>通过将$\alpha^*$放入上式中，A-GEM更新规则：</p><script type="math/tex; mode=display">z^{*} = g- \frac{g^Tg_{ref}}{g^T_{ref} g_{ref}} = \hat g</script><h2 id="Joint-embedding-model-using-compositional-task-descriptors"><a href="#Joint-embedding-model-using-compositional-task-descriptors" class="headerlink" title="Joint embedding model using compositional task descriptors"></a>Joint embedding model using compositional task descriptors</h2><p>在这一部分中，将讨论如何改进包括A-GEM在内的所有LLL方法的前向迁移。</p><p>为了加速新任务的学习，我们考虑使用组合任务描述符，其中组件在任务之间共享，从而允许迁移。</p><p>例如，组合任务描述符的示例是所考虑任务的自然语言描述或指定要在任务中识别的对象的属性值的矩阵。</p><p>如果模型已经学习并记住了两个独立的属性(例如，羽毛的颜色和喙的形状)，则它可以在提供指定其属性(黄色羽毛和红色喙)的值的描述符的情况下快速识别新的类，尽管这是完全不可见的组合。</p><p>借鉴小样本学习文献中的思想，我们学习了图像特征和属性嵌入之间的联合嵌入空间。</p><p>形式上，让 $x^k \in X$ 是输入（例如，图像），$t^k$ 是大小为 $C<em>k × A$ 的矩阵形式的任务描述符，其中 $C_k$ 是第 k 个任务中的类数，A 是 数据集中每个类的属性总数。 联合嵌入模型由特征提取模块 $\phi</em>{\theta}: x^k \to \phi<em>{\theta}(x^k)$，其中 $\phi</em>{\theta}(x^k)\in R^D$ 和任务嵌入模块 $\psi_w :t^k \to \psi_w(t^k)$，其中 $\psi_w(t^k)\in R^{C_k\times D}$ 组成 。</p><p>在这项工作中，$\phi_{\theta}(.)$ 被实现为标准的多层前馈网络，而 $\psi_w(.)$ 被实现为维度 A × D 的参数矩阵。这个矩阵可以解释为一个属性查找表，因为每个属性都与一个 D 维向量相关联，通过类中存在的属性的线性组合，从中构建类嵌入向量；</p><p>任务描述符嵌入然后是任务中存在的类的嵌入向量的串联。 在训练期间，通过最小化交叉熵损失来学习参数 θ 和 ω：</p><script type="math/tex; mode=display">l_k(\theta, w) = \frac{1}{N} \sum_{i=1}^N - log(p(y_i^k| x_i^k,t^k;\theta,w))</script><p>其中 $(x_i^k, t^k, y_i^k)$ 是第刻个任务的第i个样本， 如果 $y_i^k=c$ 概率分布为：</p><script type="math/tex; mode=display">p(c|x_i^k ,t^k;\theta, w) = \frac{exp([\phi_{\theta}(x_i^k) \psi_w(t^k)^T]_c) }{\sum_j exp([\phi_{\theta}(x_i^k) \psi_w(t^k)^T]_j)}</script><p>其中 $[a]_i$ 表示向量 a 的第 i 个元素。 请注意，架构和损失函数是通用的，不仅适用于 A-GEM，还适用于任何其他 LLL 模型（例如，基于正则化的方法）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Efficient-lifelong-learning-with-A-GEM&quot;&gt;&lt;a href=&quot;#Efficient-lifelong-learning-with-A-GEM&quot; class=&quot;headerlink&quot; title=&quot;Efficient lifelo</summary>
      
    
    
    
    
    <category term="context detection" scheme="http://example.com/tags/context-detection/"/>
    
  </entry>
  
  <entry>
    <title>14-最长公共前缀(二分、分治)</title>
    <link href="http://example.com/2021/09/25/14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80-%E4%BA%8C%E5%88%86%E3%80%81%E5%88%86%E6%B2%BB/"/>
    <id>http://example.com/2021/09/25/14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80-%E4%BA%8C%E5%88%86%E3%80%81%E5%88%86%E6%B2%BB/</id>
    <published>2021-09-25T01:05:01.000Z</published>
    <updated>2021-09-28T00:53:33.960Z</updated>
    
    <content type="html"><![CDATA[<h1 id="14-最长公共前缀-二分、分治"><a href="#14-最长公共前缀-二分、分治" class="headerlink" title="14-最长公共前缀(二分、分治)"></a>14-最长公共前缀(二分、分治)</h1><h4 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a><a href="https://leetcode-cn.com/problems/longest-common-prefix/">14. 最长公共前缀</a></h4><h2 id="法一：横向扫描"><a href="#法一：横向扫描" class="headerlink" title="法一：横向扫描"></a>法一：横向扫描</h2><p>用 $LCP(S_1,…,S_n)$ 表示字符串 $S_1,…,S_n$的最长公共前缀，可得</p><script type="math/tex; mode=display">LCP(S_1,...,S_n) = LCP(LCP (LCP(S_1,S_2), S_3),...,S_n)</script><p>基于该结论可得到一种查找字符串数组中的最长前缀的简单方法。依次遍历字符串中的每个字符串。对于每个遍历到的字符串，更新最长公共前缀，当遍历完所有的字符串以后，即可得到字符串数组中的最长公共前缀。</p><p><img src="https://i.loli.net/2021/09/25/nxdtFq4bUIczGSC.png" alt=""></p><p>如果在尚未遍历完所有的字符串时，最长公共前缀已经是空串，则最长公共前缀一定是空串，因此不需要继续遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs == <span class="keyword">null</span> || strs.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String prefix = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> count = strs.length;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; count;i++)&#123;</span><br><span class="line">            prefix = longestCommonPrefix(prefix, strs[i]); </span><br><span class="line">            <span class="keyword">if</span>(prefix.length() == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String str1, String str2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = Math.min(str1.length(), str2.length());</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(index&lt;length &amp;&amp; str1.charAt(index) == str2.charAt(index))&#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str1.substring(<span class="number">0</span>,index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span>(<span class="params">self, strs: List[<span class="built_in">str</span>]</span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> strs:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        prifix , count = strs[<span class="number">0</span>], <span class="built_in">len</span>(strs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,count):</span><br><span class="line">            prifix = self.lcp(prifix, strs[i]);</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> prifix:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> prifix</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lcp</span>(<span class="params">self, str1,str2</span>):</span></span><br><span class="line">        length, index = <span class="built_in">min</span>(<span class="built_in">len</span>(str1), <span class="built_in">len</span>(str2)), <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> index &lt; length <span class="keyword">and</span> str1[index] == str2[index]:</span><br><span class="line">            index+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> str1[:index]</span><br></pre></td></tr></table></figure><p>复杂度：</p><ul><li>时间$O(mn)$ m是字符串数组中的字符串的平均长度，n是字符串的数量。最坏情况下，字符串数组中的每个字符串的每个字符都会被比较一次。</li><li>空间 $O(1)$</li></ul><h2 id="法二：纵向扫描"><a href="#法二：纵向扫描" class="headerlink" title="法二：纵向扫描"></a>法二：纵向扫描</h2><p>方法一是横向扫描，依次遍历每个字符串，更新最长公共前缀。另一种方法是纵向扫描。</p><p>纵向扫描时，从前往后遍历所有字符串的每一列，比较相同列上的字符是否相同。</p><p>如果相同则继续对下一列进行比较，如不相同则当前列不再属于公共前缀，当前列之前的部分为最长。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs==<span class="keyword">null</span> || strs.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = strs[<span class="number">0</span>].length();</span><br><span class="line">        <span class="keyword">int</span> count = strs.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = strs[<span class="number">0</span>].charAt(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;count;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==strs[j].length() || strs[j].charAt(i)!=c)&#123;</span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>,i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析</p><ul><li>时间复杂度 $O(mn)$ 其中 m 是字符串数组中的字符串的平均长度，n是字符串的数量</li><li>空间 $O(1)$</li></ul><h2 id="方法三：分治"><a href="#方法三：分治" class="headerlink" title="方法三：分治"></a>方法三：分治</h2><p>注意到 LCP 的计算满足结合律，有以下结论：</p><script type="math/tex; mode=display">LCP(S_1, ..., S_n) = LCP(LCP(S_1,...,S_k), LCP(S_{k+1},...,S_n))</script><p>其中$LCP(S_1,…,S_n)$ 是字符串 $S_1,…,S_n$ 的最长公共前缀，$1&lt;k&lt;n$</p><p>基于上述结论，可以使用分治法得到字符串数组中的最长公共前缀。对于问题 $LCP(S<em>i,…,S_j)$，可以分解成两个子问题 $LCP(S_i,…,S</em>{mid})$ 与$LCP(S_{mid+1},…,S_j)$</p><p>其中 $mid = \frac{i+j}{2}$ 对两个子问题分别求解，然后对两个子问题的解计算最长公共前缀，即原问题的解。</p><p><img src="https://i.loli.net/2021/09/26/QpVbrwdZINPjcty.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs==<span class="keyword">null</span> || strs.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longestCommonPrefix(strs, <span class="number">0</span>, strs.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == end)&#123;</span><br><span class="line">            <span class="keyword">return</span> strs[start];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (end - start) / <span class="number">2</span> + start;</span><br><span class="line">        String lcpLeft = longestCommonPrefix(strs, start, mid);</span><br><span class="line">        String lcpRight = longestCommonPrefix(strs, mid+<span class="number">1</span>, end);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> minLength = Math.min(lcpLeft.length(), lcpRight.length());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;minLength;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(lcpLeft.charAt(i) != lcpRight.charAt(i))&#123;</span><br><span class="line">                <span class="keyword">return</span> lcpLeft.substring(<span class="number">0</span>,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lcpLeft.substring(<span class="number">0</span>,minLength);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：</p><ul><li><p>时间复杂度：$O(mn)$ 其中m 是字符串数组中的字符串的平均长度，n是字符串的数量。</p><p>时间复杂度的递推式是 $T(n) = 2\cdot T(n/2) + O(m)$， 通过计算可得 $T(n) = O(mn)$</p></li><li><p>空间复杂度 $O(mlogn)$ ，n为字符串数量。空间复杂度取决于递归调用的层数，层数最大为 logn，每层需要 m 的空间存储返回结果。</p></li></ul><h2 id="方法四：二分查找"><a href="#方法四：二分查找" class="headerlink" title="方法四：二分查找"></a>方法四：二分查找</h2><p>虽然，最长公共前缀的长度不会超过字符串数组中的最短字符串的长度。</p><p>用 minLength 表示字符串数组中的最短字符串长度，则可以再 $[0,minLength]$ 的范围内通过二分查找找到最长公共前缀的长度。每次取查找范围的中间值mid， 判断每个字符串的长度为mid 的前缀是否相同，如果相同则最长公共前缀的长度一定大于或等于 mid， 如果不相同则最长公共前缀的长度一定小于mid， 通过上述方式将查找范围缩小一半，直到得到最长公共前缀的长度。</p><p><img src="https://i.loli.net/2021/09/26/32HvnS78gisxEcI.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs==<span class="keyword">null</span> || strs.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> minLength = Integer.MAX_VALUE</span><br><span class="line">        <span class="keyword">for</span>(String str:strs)&#123;</span><br><span class="line">            minLength = Math.min(minLength, str.length());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high=minLength;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (high - low + <span class="number">1</span>) /<span class="number">2</span> + low;</span><br><span class="line">            <span class="keyword">if</span>(isCommonPrefix(strs, mid))&#123;</span><br><span class="line">                low = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>,low);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCommonPrefix</span><span class="params">(String[] strs, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        String str0 = strs[<span class="number">0</span>].substring(<span class="number">0</span>, length);</span><br><span class="line">        <span class="keyword">int</span> count = strs.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;count;i++)&#123;</span><br><span class="line">            String str = strs[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(str0.charAt(j) != str.charAt(j))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;14-最长公共前缀-二分、分治&quot;&gt;&lt;a href=&quot;#14-最长公共前缀-二分、分治&quot; class=&quot;headerlink&quot; title=&quot;14-最长公共前缀(二分、分治)&quot;&gt;&lt;/a&gt;14-最长公共前缀(二分、分治)&lt;/h1&gt;&lt;h4 id=&quot;14-最长公共前缀&quot;&gt;</summary>
      
    
    
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>凸优化一</title>
    <link href="http://example.com/2021/09/24/%E5%87%B8%E4%BC%98%E5%8C%96%E4%B8%80/"/>
    <id>http://example.com/2021/09/24/%E5%87%B8%E4%BC%98%E5%8C%96%E4%B8%80/</id>
    <published>2021-09-24T11:32:10.000Z</published>
    <updated>2021-09-24T11:37:24.763Z</updated>
    
    <content type="html"><![CDATA[<h1 id="凸优化一"><a href="#凸优化一" class="headerlink" title="凸优化一"></a>凸优化一</h1><p>从一个可行解的集合中，寻找出最优的元素</p><p>任何一个优化问题都可以写成这个形式：</p><script type="math/tex; mode=display">minimize</script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;凸优化一&quot;&gt;&lt;a href=&quot;#凸优化一&quot; class=&quot;headerlink&quot; title=&quot;凸优化一&quot;&gt;&lt;/a&gt;凸优化一&lt;/h1&gt;&lt;p&gt;从一个可行解的集合中，寻找出最优的元素&lt;/p&gt;
&lt;p&gt;任何一个优化问题都可以写成这个形式：&lt;/p&gt;
&lt;script type</summary>
      
    
    
    
    
    <category term="Convex optimization" scheme="http://example.com/tags/Convex-optimization/"/>
    
  </entry>
  
  <entry>
    <title>Gradient Episodic Memory for Continual Learning</title>
    <link href="http://example.com/2021/09/24/Gradient-Episodic-Memory-for-Continual-Learning/"/>
    <id>http://example.com/2021/09/24/Gradient-Episodic-Memory-for-Continual-Learning/</id>
    <published>2021-09-24T06:59:03.000Z</published>
    <updated>2021-09-24T13:09:46.644Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Gradient-Episodic-Memory-for-Continual-Learning"><a href="#Gradient-Episodic-Memory-for-Continual-Learning" class="headerlink" title="Gradient Episodic Memory for Continual Learning"></a>Gradient Episodic Memory for Continual Learning</h1><p>人工智能的一个主要障碍是模型在不忘记先前获得的知识的情况下，更快地解决新问题的能力很差。</p><p>首先，提出了一套度量标准来评估在数据连续体上学习的模型。这些度量不仅通过它们的测试准确性来表征模型，而且还根据它们在任务之间传输知识的能力来表征模型。</p><p>其次，提出了一个持续学习的模型，称为梯度情节记忆(GEM)，它可以减轻遗忘，同时允许知识有益地转移到以前的任务中。</p><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>有监督学习的设置 $D<em>{tr} = {(x_i,y_i)}</em>{i=1}^n$ , 其中每个示例 $(x_i，y_i)$ 由特征向量 $x_i\in X$ 和目标向量 $y_i\in Y$组成。</p><p>大多数监督学习方法假设每个示例 $(x_i，y_i)$ 是来自描述单个学习任务的固定概率分布 $P$ 的独立同分布(IID)样本。目标是构造一个模型 $f:X \rightarrow Y$ ，用于预测目标向量 $y$ 与未见的特征向量 $x$ ,其中$(x,y) \sim P$</p><p>为了实现这一点，监督学习方法通常采用 经验风险最小化 (ERM) 原则 [Vapnik, 1998]，其中 f 是通过最小化这个式子：</p><script type="math/tex; mode=display">\frac{1}{|D_u|} \sum_{x_i,y_i \in D_u} l(f(x_i), y_i)</script><p>在实践中，ERM通常需要多次遍历训练集。<a href="https://zhuanlan.zhihu.com/p/103786559">经验风险最小化(Empirical Risk Minimization)</a></p><p>将逐个样本地观察数据的连续体：</p><script type="math/tex; mode=display">(x_1,t_1,y_1), ...,(x_i,t_i,y_i),...,(x_n,t_n,y_n)</script><p>$t<em>i \in T$ 该任务描述符标识与 $(x_i，y_i)\sim P</em>{t_i}$ 相关联的任务。</p><p>重要的是，样本不是从三元组 $(x，t，y)$上的固定概率分布中提取的，因为在切换到下一任务之前可以观察到来自当前任务的整个示例序列。</p><p>连续学习的目标是构造一个能够预测与测试对 $(x，t)$ 相关的目标 $y$ 的模型 $f: X\times T$，其中 $(x,y)\sim P_t$。</p><p>在这种情况下，ERM面临着未知的挑战：</p><ul><li>Non-iid input data : 数据连续体相对于任何固定概率分布 $P(X,T,Y)$ 不是独立同分布的，因为一旦任务切换，就可以观察到来自新任务的整个样本序列。</li><li>Catastrophic forgetting : 学习新任务可能会损害学习者在以前解决的任务中的表现。 </li><li>Transfer learning :  当连续体中的任务相关时，就存在迁移学习的机会。这将转化为更快地学习新任务，以及提高旧任务的性能。</li></ul><h2 id="A-Framework-for-Continual-Learning"><a href="#A-Framework-for-Continual-Learning" class="headerlink" title="A Framework for Continual Learning"></a>A Framework for Continual Learning</h2><p>连续体的数据三元组 $(x<em>i,t_i,y_i)$ 由特征向量 $x_i\in X</em>{t<em>i}$ , 任务描述符 $t_i\in T$ , 目标向量 $y_i\in Y</em>{t_i}$</p><p>为简单起见，我们假设连续体是局部 iid，即每个三元组 $(x<em>i，t_i，y_i)$ 都满足 $(x_i,y_i) \sim^{iid} P</em>{t_i}(X,Y)$</p><p>目标是学习一个预测器 $f:X\times T \to Y$，它可以在任何时候被查询以预测与测试对 $(x，t)$ 相关联的目标向量 $y$，其中$(x,y)\sim P_t$。这样的测试对可以属于我们在过去观察到的任务，可以属于当前的任务，也可以属于我们将在未来体验的任务。</p><h3 id="Task-descriptors"><a href="#Task-descriptors" class="headerlink" title="Task descriptors"></a>Task descriptors</h3><p>框架中的一个重要组成部分是任务描述符  $t_1, . . . , t_n \in T$ 。在最简单的情况下，任务描述符是整数 $t_i = i \in Z$，枚举出现在数据连续集中的不同任务。更一般地说，任务描述符 $t_i$ 可以是结构化对象，例如一段自然语言，解释如何解决第 $i$ 个任务。丰富的任务描述符为  zero-shot learning 提供了机会，因为可以单独使用新的任务描述符来推断任务之间的关系。此外，任务描述符消除了类似学习任务的歧义。特别是，相同的输入 $x_i$ 可能出现在两个不同的任务中，但需要不同的目标。任务描述符可以引用多个学习环境的存在，或提供有关每个示例的附加（可能是分层的）上下文信息。然而，在本文中，作者专注于减轻从连续数据中学习时的灾难性遗忘，并将 zero-shot learning  留给未来的研究。</p><h3 id="Training-Protocol-and-Evaluation-Metrics"><a href="#Training-Protocol-and-Evaluation-Metrics" class="headerlink" title="Training Protocol and Evaluation Metrics"></a>Training Protocol and Evaluation Metrics</h3><p>大多数关于学习一系列任务的文献描述了一种设置</p><ul><li>i) 任务数量 很小</li><li>ii) 每个任务的示例数量很大</li><li>iii) 学习者对每个任务的样本执行多次传递</li><li>iv) 报告的唯一指标是所有任务的平均性能。 </li></ul><p>相比之下，本文:</p><ul><li>i) 任务数量很大，</li><li>ii) 每个任务的训练样本数量很少</li><li>iii) 学习者只观察与每个任务相关的样本一次</li><li>iv) 报告了衡量转移和遗忘的指标。</li></ul><p>除了监控其跨任务的表现外，评估模型传递知识的能力也很重要。更具体地说：</p><ul><li>Backward transfer (BWT) ：学习任务 t 对前一任务 k ≺ t 的性能的影响。当学习任务 t 时，提高了先前任务 k 的性能(存在正面的反向迁移)。当学习任务 t 会降低先前任务 k 的性能时(存在负面的反向迁移)。 越大意味着灾难性遗忘越严重。<script type="math/tex; mode=display">\frac{1}{T} \sum_{i=1}^T R_{T,i}\frac{1}{T-1} \sum_{i=1}^{T-1} R_{T,i} - R_{i,i}</script></li></ul><ul><li>Forwardtransfer(FWT) ：学习任务t 对未来任务 k&gt;t 的性能的影响。 $\hat b$是每个任务在随机初始化时的测试精度向量。<script type="math/tex; mode=display">\frac{1}{T-1} \sum_{i=2}^{T-1} R_{i-1,i} - \hat b_i</script></li></ul><ul><li>Retained Accuracy(RA) 是模型在训练结束时跨任务的平均准确率。<script type="math/tex; mode=display"> \frac{1}{T} \sum_{i=1}^T R_{T,i}</script></li></ul><p>讨论第一个任务的向后转移或最后一个任务的正向转移是没有意义的。</p><p>考虑为每一个 $T$ 任务访问测试集。在模型学习完任务 $t<em>i$之后，我们评估了它在所有 $T$ 个任务上的测试性能。通过这样做，我们构造了矩阵 $R \in R^{T\times T}$，其中 $R</em>{i,j}$ 是在观察到来自任务 $t_i$ 的最后一个样本之后，模型对任务 $t_j$ 的测试分类精度。</p><h3 id="Gradient-of-Episodic-Memory-GEM"><a href="#Gradient-of-Episodic-Memory-GEM" class="headerlink" title="Gradient of Episodic Memory (GEM)"></a>Gradient of Episodic Memory (GEM)</h3><p>梯度情景记忆（GEM），一种持续学习的模型。 GEM 的主要特征是情景记忆 $M_t$，它存储来自任务 t 的观察示例的子集。 为简单起见，我们假设整数任务描述符，并使用它们来索引情节记忆。 当使用整数任务描述符时，不能期望显着的正向转移（zero-shot learning）。 相反，我们专注于通过有效使用情景记忆来最小化负向后迁移（灾难性遗忘）。</p><p>实际上，学习者总共有 $M$ 个存储单元的预算。如果总任务数 $T$ 已知，我们可以为每个任务分配 $m=M/T$个存储器。如果总任务数 $T$ 未知，我们可以在观察新任务时逐渐减小 $m$ 值</p><p>为简单起见，假设内存中填充了来自每个任务的最后 $m$ 个示例，尽管可以采用更好的内存更新策略(例如为每个任务构建核心重置)。在下文中，我们考虑由 $\theta \in R^P$参数化的预测因子 $f_\theta$，并将第k个任务的记忆损失定义为:</p><script type="math/tex; mode=display">l(f_{\theta} ,M_k) = \frac{1}{|M_k|} \sum_{(x_i,k,y_i)\in M_k} l(f_{\theta}(x_i,k),y_i)</script><p>显然，将当前示例中的损失与上式一起最小化会导致过度拟合存储在 $M_k$中的示例。作为另一种选择，我们可以通过蒸馏的方法来保持过去任务的预测不变 —— iCaRL: Incremental classifier and representation</p><p>然而，这将认为正向后向转移是不可能的。 相反，我们将使用 上面的损失 作为不等式约束，避免它们的增加但允许它们的减少。 与最先进的 [Kirkpatrick et al., 2017, Rebuffi et al., 2017] 相比，我们的模型允许正向后向转移。</p><p>更具体地说，在观察三元组 $(x,t,y)$时，我们解决了以下问题：</p><script type="math/tex; mode=display">minimize_{\theta}  \ \ \ l(f_{\theta}(x,t) ,y)</script><script type="math/tex; mode=display">\text{subject to (受制于)}  \ \ \ l(f_{\theta}, M_k) \le l(f_{\theta}^{t-1},M_k) \ \  for \ all \ k\lt t</script><p>其中 $f_{\theta}^{t-1}$ 是任务 t−1学习结束时的预测器状态。</p><p>首先，在每次参数更新g之后，只要我们保证以前任务的损失不增加，就没有必要存储旧的预测值 $f_{\theta}^{t-1}$。</p><p>其次，假设函数是局部线性的（因为它发生在小优化步骤周围）并且memory代表过去任务的样本，我们可以通过计算它们的损失梯度向量之间的角度来 ，判断先前任务损失的增加 和建议的更新。在数学上，我们将上面式子的约束重新表述为：</p><script type="math/tex; mode=display"><g, g_k> := <\frac{\partial l(f_{\theta}(x,t),y)}{\partial \theta} , \frac{\partial l(f_{\theta},M_k)}{ \partial\theta}> \ge 0 , \ for \ all \ k <t</script><p>如果满足上面的不等式，则参数更新 $g$ 不太可能增加先前任务的损失。</p><p>另一方面，如果违反了一个或多个不等式约束，那么至少有一个先前的任务在参数更新后损失会增加。 如果违反不等式，我们建议将梯度 g 投影到满足所有上式约束 的最近梯度  $\hat g$（以平方 $l2$ 范数表示）。 因此：</p><script type="math/tex; mode=display">minimize_{\hat g}  \ \ \ \frac{1}{2} ||g-\hat g||^2_2</script><script type="math/tex; mode=display">\text{subject to (受制于)}  \ \ \ <\hat g,g_k> \ge 0 \ for \ all \ k <t</script><p>为了有效地解决上式，回想一下具有不等式约束的二次规划Quadratic Program （QP）的原始值：</p><p><a href="https://zhuanlan.zhihu.com/p/36081404">凸优化笔记(3)Quadratic Programming简介</a></p><script type="math/tex; mode=display">minimize_{z} \ \ \frac{1}{2} z^TCz + p^Tz</script><script type="math/tex; mode=display">\text{subject to (受制于)}  \ \ \ Az\ge b</script><p>其中$C\in R^{p\times p}, p\in R^p,A\in R^{(t-1)\times p} ,b\in R^{t-1}$ , 上式的对偶问题是：</p><script type="math/tex; mode=display">minimize_{u,v} \ \ \frac{1}{2} u^TCu -b^Tv</script><script type="math/tex; mode=display">\text{subject to (受制于)}  \ \ \ A^Tv -Cu=p \ ,\ v\ge 0</script><p> 如果 $(u^⋆,v^⋆)$是上个式子的解，则存在解 $z^⋆$ 满足 $Cz^⋆=Cu^⋆$</p><p>有了这些符号，我们将原始GEM QP 写成：</p><script type="math/tex; mode=display">minimize_{z} \ \ \frac{1}{2} z^Tz -g^Tz + \frac{1}{2}g^Tg</script><script type="math/tex; mode=display">\text{subject to (受制于)}  \ \ \ Gz \ge 0</script><p>其中 $G = -(g<em>1,…,g</em>{t-1})$ 并且去掉常数项 $g^Tg$ 。这是 p 个变量（神经网络的参数数量）上的 QP，可以以数百万计。 但是，我们可以将 GEM QP 的对偶假设为：</p><script type="math/tex; mode=display">minimize_{v} \ \ \frac{1}{2} v^TGG^Tv + g^TG^Tv</script><script type="math/tex; mode=display">\text{subject to (受制于)}  \ \ \ v \ge 0</script><p>由于 $u  = G^Tv + g$ 并且 $g^T g$ 是常数，这是在 $t − 1 ≪ p$ 个变量上的 QP，即目前观察到的任务数量。一旦我们解决了 $v^<em>$ 的对偶问题(上式) ，我们就可以将投影梯度更新恢复为 $\hat g = G^Tv^</em> + g$。 在实践中，我们发现添加一个小的常数 $\gamma \ge 0 $ 到 $v^⋆$ 会使梯度投影偏向于有利于有益向后转移的更新。</p><p><img src="https://i.loli.net/2021/09/24/bDAQzaEYd6gPOIy.png" alt=""></p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p><img src="https://i.loli.net/2021/09/24/gDpRaMANdbhT9kc.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Gradient-Episodic-Memory-for-Continual-Learning&quot;&gt;&lt;a href=&quot;#Gradient-Episodic-Memory-for-Continual-Learning&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    
    <category term="context detection" scheme="http://example.com/tags/context-detection/"/>
    
  </entry>
  
  <entry>
    <title>12,13-整数互换罗马数字</title>
    <link href="http://example.com/2021/09/24/12-13-%E6%95%B4%E6%95%B0%E4%BA%92%E6%8D%A2%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/"/>
    <id>http://example.com/2021/09/24/12-13-%E6%95%B4%E6%95%B0%E4%BA%92%E6%8D%A2%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</id>
    <published>2021-09-24T04:34:19.000Z</published>
    <updated>2021-09-24T05:13:58.677Z</updated>
    
    <content type="html"><![CDATA[<h1 id="12-13-整数互换罗马数字"><a href="#12-13-整数互换罗马数字" class="headerlink" title="12,13-整数互换罗马数字"></a>12,13-整数互换罗马数字</h1><h4 id="12-整数转罗马数字"><a href="#12-整数转罗马数字" class="headerlink" title="12. 整数转罗马数字"></a><a href="https://leetcode-cn.com/problems/integer-to-roman/">12. 整数转罗马数字</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] values=&#123;<span class="number">1000</span>,<span class="number">900</span>,<span class="number">500</span>,<span class="number">400</span>,<span class="number">100</span>,<span class="number">90</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        String[] rom=&#123;<span class="string">&quot;M&quot;</span>,<span class="string">&quot;CM&quot;</span>,<span class="string">&quot;D&quot;</span>,<span class="string">&quot;CD&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;XC&quot;</span>,<span class="string">&quot;L&quot;</span>,<span class="string">&quot;XL&quot;</span>,<span class="string">&quot;X&quot;</span>,<span class="string">&quot;IX&quot;</span>,<span class="string">&quot;V&quot;</span>,<span class="string">&quot;IV&quot;</span>,<span class="string">&quot;I&quot;</span>&#125;;</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;values.length;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(num&gt;=values[i])&#123;</span><br><span class="line">                sb.append(rom[i]);</span><br><span class="line">                num-=values[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13. 罗马数字转整数"></a><a href="https://leetcode-cn.com/problems/roman-to-integer/">13. 罗马数字转整数</a></h4><p>通常情况下，罗马数字中小的数字在大的数字的右边。若输入的字符串满足该情况，那么可以将每个字符视作一个单独的值，累加每个字符对应的数值即可。</p><p>例如 $\texttt{XXVII}$ 可视作 X+X+V+I+I=10+10+5+1+1=27。</p><p>若存在小的数字在大的数字的左边的情况，根据规则需要减去小的数字。对于这种情况，我们也可以将每个字符视作一个单独的值，若一个数字右侧的数字比它大，则将该数字的符号取反。</p><p>例如 XIV 可视作 X−I+V=10−1+5=14。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Character, Integer&gt; symbolValues = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;() &#123;&#123;</span><br><span class="line">        put(<span class="string">&#x27;I&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">        put(<span class="string">&#x27;V&#x27;</span>, <span class="number">5</span>);</span><br><span class="line">        put(<span class="string">&#x27;X&#x27;</span>, <span class="number">10</span>);</span><br><span class="line">        put(<span class="string">&#x27;L&#x27;</span>, <span class="number">50</span>);</span><br><span class="line">        put(<span class="string">&#x27;C&#x27;</span>, <span class="number">100</span>);</span><br><span class="line">        put(<span class="string">&#x27;D&#x27;</span>, <span class="number">500</span>);</span><br><span class="line">        put(<span class="string">&#x27;M&#x27;</span>, <span class="number">1000</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> value = symbolValues.get(s.charAt(i));</span><br><span class="line">            <span class="keyword">if</span> (i &lt; n - <span class="number">1</span> &amp;&amp; value &lt; symbolValues.get(s.charAt(i + <span class="number">1</span>))) &#123;</span><br><span class="line">                ans -= value;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;12-13-整数互换罗马数字&quot;&gt;&lt;a href=&quot;#12-13-整数互换罗马数字&quot; class=&quot;headerlink&quot; title=&quot;12,13-整数互换罗马数字&quot;&gt;&lt;/a&gt;12,13-整数互换罗马数字&lt;/h1&gt;&lt;h4 id=&quot;12-整数转罗马数字&quot;&gt;&lt;a hr</summary>
      
    
    
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>10-正则表达式</title>
    <link href="http://example.com/2021/09/23/10-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://example.com/2021/09/23/10-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2021-09-23T01:15:02.000Z</published>
    <updated>2021-09-23T03:12:03.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="10-正则表达式"><a href="#10-正则表达式" class="headerlink" title="10-正则表达式"></a>10-正则表达式</h1><h4 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10. 正则表达式匹配"></a><a href="https://leetcode-cn.com/problems/regular-expression-matching/">10. 正则表达式匹配</a></h4><h2 id="定义状态"><a href="#定义状态" class="headerlink" title="定义状态"></a>定义状态</h2><ul><li>定义动态数组$dp[m][n]$ （n为字符串p的长度+1，m为字符串s的长度+1）</li><li><ul><li>为什么要加1</li><li>因为我们还要处理空字符串的情况，比如p为空，s为空，或者p为空，s不为空</li></ul></li><li>$dp[m][n]$ 的含义：p的前$n-1$ 个字符能否匹配s的前$m-1$个字符</li><li><ul><li>为什么是n-1和m-1?</li><li>因为动态数组里面加了一列和一行空字符的匹配情况，故需要-1才能对应相应字符串</li></ul></li></ul><p>因此创建好的dp数组如下图：</p><p><img src="https://i.loli.net/2021/09/23/UDWLfZIH8nmwYCX.jpg" alt=""></p><h2 id="确定动态转移方程"><a href="#确定动态转移方程" class="headerlink" title="确定动态转移方程"></a>确定动态转移方程</h2><p>说明：为了区别dp数组与字符串索引的区别(因为相差1)，我们设 $i=r-1,j=c-1$ （r为dp里面的行索引，c为dp里面的列索引）</p><p>有以下几种情况是需要我们处理的：</p><ul><li>当 $s[i]=p[j] \ || \  p[j]==’.’$ （即正好能够匹配或者相对应的是一个 $.$）</li></ul><p>那么我们只需要看一下前面 $dp[r-1][c-1]$的状态，$dp[r][c]$继续延续即可</p><p>即状态转移方程为 $dp[r][c]=dp[r-1][c-1]$</p><p><img src="https://i.loli.net/2021/09/23/wzgDScn6VBvR93J.jpg" alt=""></p><ul><li><p>当 $p[j] ==’<em>‘$ （即匹配到了万能字符 $</em>$）</p><p>两种情况分别对应的处理方式为：</p><p>如果 $*$ 的前一个字符正好对应了$s$，状态转移过程为：$dp[r][c] = dp[r-1][c]$</p><p>如果是$*$的前一个字符为 $.$ 那么只需看$.$的前面字符匹配情况，状态转移过程为: $dp[r][c]=dp[r][c-2]$</p></li></ul><p>  边界：</p><ul><li><p>首先我们要确定 $dp[0][0]$，当p为空，s为空时，肯定匹配成功。那么$dp[0][0]=true$</p></li><li><p>当 p 为空字符串，而s不为空时，dp数组必定为False，正好初始化dp数组的时候设置的是False；即dp数组的第一列为False可以确定</p></li><li><p>当s为空字符串，而p不为空时，我们无需判断p里面的第一个值是否为””，如果为””,那肯定匹配不到为Fasle,原数组正好是Fasle，所以直接从2开始判断即可。如果遇到了*,只要判断其对应的前面两个元素的dp值</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> m = p.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp=<span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        s = <span class="string">&#x27; &#x27;</span>+s;</span><br><span class="line">        p = <span class="string">&#x27; &#x27;</span>+p;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span> &amp;&amp; j==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(p.charAt(j) != <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(p.charAt(j)==<span class="string">&#x27;.&#x27;</span> || s.charAt(i)==p.charAt(j))&#123;</span><br><span class="line">                        <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                            dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j&gt;=<span class="number">2</span>) dp[i][j] = dp[i][j-<span class="number">2</span>];</span><br><span class="line">                    <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>) == <span class="string">&#x27;.&#x27;</span> || s.charAt(i)==p.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                            <span class="keyword">if</span>(dp[i-<span class="number">1</span>][j]) dp[i][j]=<span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;10-正则表达式&quot;&gt;&lt;a href=&quot;#10-正则表达式&quot; class=&quot;headerlink&quot; title=&quot;10-正则表达式&quot;&gt;&lt;/a&gt;10-正则表达式&lt;/h1&gt;&lt;h4 id=&quot;10-正则表达式匹配&quot;&gt;&lt;a href=&quot;#10-正则表达式匹配&quot; class=&quot;</summary>
      
    
    
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Learning to learn without forgetting by maximizing transfer and minimizing interference</title>
    <link href="http://example.com/2021/09/22/LEARNING-TO-LEARN-WITHOUT-FORGETTING-BY-MAXIMIZING-TRANSFER-AND-MINIMIZING-INTERFERENCE/"/>
    <id>http://example.com/2021/09/22/LEARNING-TO-LEARN-WITHOUT-FORGETTING-BY-MAXIMIZING-TRANSFER-AND-MINIMIZING-INTERFERENCE/</id>
    <published>2021-09-22T10:58:55.394Z</published>
    <updated>2021-10-09T07:41:10.391Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Learning-to-learn-without-forgetting-by-maximizing-transfer-and-minimizing-interference"><a href="#Learning-to-learn-without-forgetting-by-maximizing-transfer-and-minimizing-interference" class="headerlink" title="Learning to learn without forgetting by maximizing transfer and minimizing interference"></a>Learning to learn without forgetting by maximizing transfer and minimizing interference</h1><p>在对非平稳数据分布进行持续学习方面，仍然是将神经网络扩展到人类现实环境的主要挑战。</p><p>在这项工作中，我们提出了一种关于连续学习的新概念，即迁移和干扰之间的对称权衡，可以通过实施跨样本的梯度对齐来优化该权重。</p><p>Meta-Experience Replay (MER) 通过将经验回放与基于优化的元学习相结合。</p><p>该方法学习使基于未来梯度的干扰可能性较小，而基于未来梯度的迁移可能性更大的参数。</p><p>作者在连续终身监督学习基准和非静态强化学习环境中进行了实验，实验表明，MER算法和基线算法之间的性能差距随着环境变得更加不平稳和存储的经验在总经验中所占的比例变小而增大。</p><h2 id="Continual-learning-problem"><a href="#Continual-learning-problem" class="headerlink" title="Continual learning problem"></a>Continual learning problem</h2><p>人工智能的一个长期目标是建立能够长期自主操作的代理。这样的代理必须渐进地学习并适应不断变化的环境，同时保持对以前所学知识的记忆，这种设置称为终身学习。本文是持续学习的一个变体。</p><p>在持续学习中，假设学习者接触到一系列任务，其中每个任务都是来自相同分布的一系列经验。</p><p>作者希望在这种情况下开发一种解决方案，在无监督的情况下发现任务的概念，同时在每次体验后逐步学习。</p><p>这很有挑战性，因为在标准的离线单任务和多任务学习中，隐含地假设数据是独立同分布的平稳分布。不幸的是，每当情况不是这样的时候，神经网络往往都会举步维艰。</p><p>持续学习面临的最大问题是灾难性的遗忘(干扰)，其中最主要的担忧是神经网络缺乏稳定性，而主要的解决方案是通过专注于保留过去的知识来限制经验之间的权重共享程度。</p><p>另一个问题是稳定性-可塑性两难问题，在这种观点下，首要关注的是：网络稳定性(保存过去的知识)和可塑性(快速学习当前经验)之间的平衡。</p><p>以前的持续学习技术侧重于平衡有限的权重共享和某种机制以确保快速学。在本文中，作者扩展了这一观点，指出——对于在无限数量的分布上的连续学习，需要及时考虑前向和后向的权重共享和稳定性-塑性权衡，如下图：</p><p><img src="https://i.loli.net/2021/09/22/iCN3JmMckXxLfHy.png" alt=""></p><p>稳定性-可塑性困境考虑了当前学习的可塑性以及它如何降低旧学习。 迁移-干扰权衡考虑了稳定性-可塑性困境及其对前向和后向权重共享的依赖。这种对称的观点是至关重要的，因为单纯专注于降低权重共享程度的解决方案不太可能在未来产生迁移。</p><p>本文提出的迁移-干扰权衡为持续学习问题的梯度对齐目标提供了一个新的视角。这是问题的核心，因为这些梯度是学习期间基于 SGD 的优化器的更新步骤，并且梯度的角度和管理权重共享的程度之间存在明显的联系。</p><p>与过去对持续学习的概念观点的关键区别在于，我们不仅关注相对于过去例子的当前迁移和干扰，而且还关注随着我们学习而向前发展的迁移和干扰的动态。</p><p>然而，在过去的工作中，基于当前的学习和过去的学习，对权重共享的动态进行了临时更改，而没有制定关于最佳权重共享动态的一致理论。就我们对未来的元学习进行推广而言，这应该使模型更容易在非平稳环境中执行持续学习。</p><p>作者通过在过去关于经验回放的工作的基础上实现这一点，经验重播一直是用神经网络解决非平稳问题的中流砥柱。</p><p>作者提出了一种新的meta-experience replay(MER)算法，它结合了经验回放和基于优化的元学习。MER在各种有监督的持续学习和持续强化学习环境中显示出巨大的潜力。</p><h2 id="The-transfer-interference-trade-off-for-continual-learning"><a href="#The-transfer-interference-trade-off-for-continual-learning" class="headerlink" title="The transfer-interference trade-off for continual learning"></a>The transfer-interference trade-off for continual learning</h2><p>在参数 $\theta$ 和损失 $L$ 的瞬间，我们可以在使用 SGD 训练时定义两个任意不同样本 $(x_i,y_i)$ 和 $(x_j,y_j)$ 之间的迁移和干扰的操作度量。 迁移发生在：</p><script type="math/tex; mode=display">\frac{\partial L(x_i,y_i)}{\partial \theta} \cdot \frac{\partial(x_j,y_j)}{\partial\theta} \gt 0</script><p>这意味着学习样本 $ i$ 将在不重复的情况下提高示例 $j$ 的表现，反之亦然。干扰发生在：</p><script type="math/tex; mode=display">\frac{\partial L(x_i,y_i)}{\partial \theta} \cdot \frac{\partial(x_j,y_j)}{\partial\theta} \lt 0</script><p>当 $i$ 和 $j$ 使用一组重叠参数进行学习时，它们之间存在权重共享。因此，当权重共享最大化时，迁移潜力最大化，而当权重共享最小化时，干扰潜力最小化。</p><p>持续学习中稳定性-可塑性困境的过去解决方案在简化的时间环境中运行，其中学习分为两个阶段：</p><ul><li>所有过去的经历都被归结为<strong>旧记忆</strong></li><li>而目前正在学习的数据则是<strong>新学习</strong></li></ul><p>在此设置中，目标是简单地最小化时间上向后投影的干扰，这通常是通过显式或隐式地降低权重共享的程度来实现的。</p><p>然而，这种观点的重要问题是，这个系统仍然需要学习，未来会带来什么在很大程度上是未知的。这使得我们有责任不采取任何措施来潜在地破坏网络在不确定的未来有效学习的能力。这种考虑使我们将稳定性-可塑性问题的时间范围向前扩展，更一般地说，将其转变为一个持续学习问题，我们将其标记为解决迁移-干扰权衡问题。如上图A。</p><p>具体来说，重要的是不仅要减少来自我们当前时间点的反向干扰，而且我们必须以不限制我们未来学习能力的方式这样做。这种更普遍的观点承认问题中的一个微妙之处：梯度对齐的问题以及因此跨样本的权重共享在时间上向后和向前出现。</p><p>在这里，作者提出了一个潜在的解决方案，我们学习以一种在每个时间点促进梯度对齐的方式进行学习。 跨样本的权重共享可以通过迁移来提高对未来的性能，但不破坏之前的性能。 因此，我们的工作对持续学习问题采用了元学习的观点。 希望学习以一种从整体分布中推广到其他样本的方式来学习每个样本。</p><h2 id="A-system-for-learning-to-learn-without-forgetting"><a href="#A-system-for-learning-to-learn-without-forgetting" class="headerlink" title="A system for learning to learn without forgetting"></a>A system for learning to learn without forgetting</h2><p>在典型的离线监督学习中，我们可以在数据集 $D$ 内$x, y$ 的平稳分布上表达我们的优化目标：</p><script type="math/tex; mode=display">\theta = \text{argmin}_{\theta} E_{(x,y)\sim D}[L(x,y)]</script><p>如果我们想要最大限度地迁移和最小化干扰，我们可以想象在目标上增加辅助损失以使学习过程偏向那个方向是有用的。</p><p>考虑公式1和2，一个明显有益的选择将是还直接考虑相对于在随机选择的数据点评估的损失函数的梯度。</p><p>如果我们可以最大化这些不同点的梯度之间的点积，它将直接鼓励网络在梯度方向对齐的地方共享参数，并在相反方向的梯度引起干扰的地方保持参数分开。</p><p>因此，理想情况下，针对以下目标进行优化:</p><script type="math/tex; mode=display">\theta  = argmin_{\theta} E_{[(x_i,y_i),(x_j,y_j)] \sim D} [L(x_i,y_i)+L(x_j,y_j)] - \alpha\frac{\partial L(x_i,y_i)}{\partial \theta}\cdot \frac{\partial L(x_j,y_j)}{\partial \theta}</script><p>其中 $(x_i，y_i)$和 $(x_j，y_j)$是随机抽样的唯一数据点。我们将尝试设计一个针对这一目标进行优化的持续学习系统。然而，要在实践中实施这种学习过程，还必须解决多方面的问题。</p><p>第一个问题是，持续学习处理的是对非平稳数据流的学习。我们通过实现一个经验回放模块来解决这个问题，该模块增强了在线学习，这样我们就可以对到目前为止看到的所有样本的固定分布进行近似优化。</p><p>另一个实际问题是，这种损失的梯度取决于损失函数的二阶导数，这一点计算效率不高。通过使用具有最小计算开销的元学习算法间接地将目标近似为一阶Tayor展开来解决这一问题。</p><h3 id="Experience-replay"><a href="#Experience-replay" class="headerlink" title="Experience replay"></a>Experience replay</h3><p><strong>Learning objective:</strong> 持续的终身学习环境对神经网络的优化提出了挑战，非平稳流中的样本层出不穷。反而，我们希望我们的网络在目前为止看到的所有样本平稳分布上进行优化。经验回放 (1992) 是一种古老的技术，它仍然是尝试在非平稳环境中学习的深度学习系统的核心组成部分，我们将在这里采用最近工作中的约定 (A deeper look at experience replay2017) ; Scalable recollections for continual lifelong learning2017) 利用这种方法。</p><p>经验回放的中心特征是保持对所见样本的记忆 $M$，该记忆与当前样本的训练交织在一起，目的是使训练更稳定。因此，经验回放在 $M$ 逼近 $D$ 的程度上逼近等式 3 中的目标：</p><script type="math/tex; mode=display">\theta = argmin_{\theta} E_{(x,y)\sim M} [L(x,y)]</script><p>$M$ 具有当前大小 $M<em>{size}$和最大大小$M</em>{max}$。 使用reservoir sampling来更新缓冲区。这确保在每个时间步，看到的 N 个示例中的任何一个在缓冲区中的概率都等于 $M_{size}/N$。</p><p>缓冲区的内容类似于所有样本的平稳分布，以至于存储的项目捕获了过去样本的变化。 遵循离线学习的标准做法，我们通过从 M 捕获的分布中随机抽样一批 B 来进行训练。</p><p><strong>Prioritizing the current example:</strong> 我们探索的经验回放变体与离线学习的不同之处在于，当前样本具有特殊作用，可确保它始终与从回放缓冲区采样的样本交错。这是因为在我们继续下一个样本之前，我们希望确保我们的算法能够针对当前样本进行优化(特别是如果它没有添加到记忆中)。在看到的N个样本上，这仍然意味着我们已经将每个样本作为当前样本进行了训练，每步的概率为1/N。我们提供了进一步详细说明在这项工作中如何使用经验回放的算法在附录G中。</p><p><img src="https://i.loli.net/2021/09/23/d5yaHjVocX6Qki1.png" alt=""></p><p><img src="https://i.loli.net/2021/09/23/RnH3td1zVFSY4yW.png" alt=""></p><p><img src="https://i.loli.net/2021/09/23/8UvcJVqlsBICPD3.png" alt=""></p><p><strong>Concerns about storing examples: </strong>显然，将所有经验都存储在内存中是不可行的。因此，在这项工作中，我们重点展示当每种方法只提供很小的内存缓冲区时，我们可以获得比基线技术更高的性能。</p><h3 id="Combining-experience-replay-with-optimization-based-meta-learning"><a href="#Combining-experience-replay-with-optimization-based-meta-learning" class="headerlink" title="Combining experience replay with optimization based meta-learning"></a>Combining experience replay with optimization based meta-learning</h3><p><strong>First order meta-learning:</strong> </p><p>FOMAML  和 Reptile</p><p>Reptile通过泰勒展开指出，这两个算法对于相同的损失函数是近似优化的。Reptile可以有效地针对大致相同的目标进行优化，同时不需要像 MAML 那样针对每个学习的任务将数据拆分为训练和测试拆分。Reptile 是通过使用基于 SGD 的优化器和学习率 $\alpha$ 顺序优化 s batch数据来实现的。在对这些批进行训练之后，我们在训练 $\theta_0$ 之前获取初始参数，并将它们更新为 $\theta_0 \leftarrow \theta_0 + \beta *(\theta_k-\theta_0)$，其中 $\beta$ 是元学习更新的学习率。</p><p>该过程对每个系列的s批进行重复（算法2）。Reptile在一组s批次中大致优化了以下目标：</p><script type="math/tex; mode=display">\theta = argmin_{\theta} E_{B_1,...,B_s \sim  D} [2\sum_{i=1}^s [L(B_i) - \sum_{j-1}^{i-1}\alpha\frac{\partial L(B_i)}{\partial\theta} \cdot \frac{\partial L(B_j)}{\partial\theta}]]</script><p><img src="https://i.loli.net/2021/09/23/EOur37U1qD8GiWw.png" alt=""></p><p><strong>The MER learning objective:</strong> 在这项工作中，我们修改了Reptile算法，将其与经验回放模块适当地集成在一起，在最大化迁移和最小化干扰的同时，促进了持续学习。</p><p>正如我们在附录I中的推导过程中更详细地描述的那样，在按顺序提供样本的在线设置中实现 Reptile 目标并非易事，并且只能部分实现，因为我们对缓冲区和批次的采样策略。根据上一节关于体验回放的评论，这允许我们使用MER算法在持续学习环境中针对以下目标进行优化：</p><script type="math/tex; mode=display">\theta = argmin_{\theta} E_{[(x_{11},y_{11}),..., (x_{sk},y_{sk})] \sim M}[2\sum_{i=1}^s\sum_{j-1}^k[L(x_{ij},y_{ij}) - \sum_{q=1}^{i-1} \sum_{r=1}^{j-1} \alpha\frac{\partial L(x_{ij},y_{ij})}{\partial \theta} \cdot \frac{\partial  L(x_{qr},y_{qr})}{\partial\theta}] ]</script><p><strong>The MER algorithm:</strong> MER 使用储层采样维护经验回放式记忆 M，并在每个时间步从缓冲区中抽取 s 个批次，包括 k-1 个随机样本，以与当前示例一起训练。每个批次内的k个样本中的每一个都被视为其自己的大小为1的Reptile批次，在该批次被处理之后具有内循环爬行动物元更新。然后，我们在外部循环中跨s个批次再次应用Reptile元更新。我们在算法1中提供了关于MER的更多细节。当β=1时，该过程近似于上面的目标。采样函数生成 s 个更新批次。 通过首先添加当前示例然后从 M 中交错 k - 1 个随机样本来创建每个批次。</p><p><img src="https://i.loli.net/2021/09/23/v6gkTQhElaUqI91.png" alt=""></p><p><strong>Prioritizing current learning:</strong> 为了确保强正则化，我们希望在 Reptile 更新中处理的批次数量足够大 - 足以让经验重播开始过拟合 M。因此，我们还需要确保我们提供足够的优先级来学习当前样本，特别是因为我们可能不会将其存储在 M 中。为了在算法 1 中实现这一点，我们从 M 中采样 s 个单独的批次，这些批次按顺序处理并且每个批次都与当样本交错。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>How does MER perform on supervised continual learning benchmarks?</p><p><img src="https://i.loli.net/2021/09/23/y5uKOL7wV9R6JFT.png" alt=""></p><p>How do the performance gains from MER vary as a function of the buffer size?</p><p><img src="https://i.loli.net/2021/09/23/oGej8vdghWEXN3i.png" alt=""></p><p>How effective is MER at dealing with increasingly non-stationary settings?</p><p><img src="https://i.loli.net/2021/09/23/XGjxz7R5edQa3vL.png" alt=""></p><p>Does MER lead to a shift in the distribution of gradient dot products?</p><p><img src="https://i.loli.net/2021/09/23/EuLksbjeQTSCYRh.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Learning-to-learn-without-forgetting-by-maximizing-transfer-and-minimizing-interference&quot;&gt;&lt;a href=&quot;#Learning-to-learn-without-forgett</summary>
      
    
    
    
    
    <category term="context detection" scheme="http://example.com/tags/context-detection/"/>
    
  </entry>
  
  <entry>
    <title>5-最长回文子串</title>
    <link href="http://example.com/2021/09/19/5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>http://example.com/2021/09/19/5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</id>
    <published>2021-09-19T01:29:13.000Z</published>
    <updated>2021-09-20T01:21:35.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5-最长回文子串"></a>5-最长回文子串</h1><h4 id="5-最长回文子串-1"><a href="#5-最长回文子串-1" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串</a></h4><h2 id="动态规划DP"><a href="#动态规划DP" class="headerlink" title="动态规划DP"></a>动态规划DP</h2><ul><li>思想：对于一个子串而言，如果它是回文串，并且长度大于2，那么它首尾的两个字母去掉之后，它仍然是个回文串</li><li>状态转移方程： $(s[i]==s[j])\ \&amp;\&amp; \ dp[i+1][j-1]$ ，$dp[i][j]$ 表示子串$s[i..j]$是否是回文</li><li>边界条件,即子串的长度为 1 或 2。： $dp(i,i)=true$ 单个字符串， $dp(i,i+1) = (Si==Si+1)$两个字符</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">        String ans=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+k&lt;n;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> j = i+k;</span><br><span class="line">                <span class="comment">// 先处理两种临界情况</span></span><br><span class="line">                <span class="keyword">if</span>(k==<span class="number">0</span>) &#123; <span class="comment">//k=0时，j=i, dp[i][j]相当于一个字符串，一定是回文串</span></span><br><span class="line">                    dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(k==<span class="number">1</span>)&#123; <span class="comment">// k=1时，j=i+1 dp[i][j]相当于连续两个字符，相同时，一定是回文串</span></span><br><span class="line">                    dp[i][j] = (s.charAt(i)==s.charAt(j));</span><br><span class="line">                &#125; <span class="keyword">else</span>&#123; <span class="comment">// k&gt;1 时，需满足状态转移方程，dp[i,j] = dp[i+1][j-1] &amp;&amp; (si==sj)</span></span><br><span class="line">                    dp[i][j] = (s.charAt(i)==s.charAt(j) &amp;&amp; dp[i+<span class="number">1</span>][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &amp;&amp; k+<span class="number">1</span>&gt;ans.length())&#123; <span class="comment">//更新回文串长度</span></span><br><span class="line">                    ans = s.substring(i, i+k+<span class="number">1</span>); <span class="comment">// 注意子串方法的具体用法</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(n^2)$ 其中n是字符串长度，动态规划的状态总数为$O(n^2)$，对于每个状态，我们需要转移的实际为$O(1)$</p><p>空间复杂度: $O(n^2)$ 即存储动态规划需要的空间</p><h2 id="中心扩展"><a href="#中心扩展" class="headerlink" title="中心扩展"></a>中心扩展</h2><p>思想</p><ul><li>前提条件:</li><li><ul><li>根据状态转移方程，可以发现所有的状态，在转移的时候可能性都是唯一的。也就是说，我们可以从每一种边界情况开始扩展，也可以得出所有状态对应的答案。</li><li>边界情况，对应的子串实际上就是我们扩展出的回文串的回文中心</li></ul></li><li>本质：</li><li><ul><li>枚举所有的回文中心，并尝试扩展，直到无法扩展为止，此时的回文串长度即为回文中心下的最长回文串长度。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中心扩展</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span> || s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end=<span class="number">0</span>; <span class="comment">// 初始化最大回文串的起点和终点</span></span><br><span class="line">        <span class="comment">// 遍历每个位置，当做中心</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="comment">// 分别拿到奇数偶数的回文串长度</span></span><br><span class="line">            <span class="keyword">int</span> len_odd = expandCenter(s,i,i);</span><br><span class="line">            <span class="keyword">int</span> len_even = expandCenter(s,i,i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> len = Math.max(len_odd,len_even);</span><br><span class="line">            <span class="comment">// 计算对应最大回文子串的起点和终点</span></span><br><span class="line">            <span class="keyword">if</span>(len &gt; end-start)&#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                    这里为什么要len-1？ ，因为for循环是从0开始的，</span></span><br><span class="line"><span class="comment">                    如果是奇数回文，假设有个回文是3个，那么len=3，此时中心i是下标1（从0开始），那么(len-1)/2和len/2的结果都是1，因为整数会向下取整</span></span><br><span class="line"><span class="comment">                    但是如果是偶数回文，假设和有个回文是4个，那么len=4，此时的中心是一条虚线，但是i的位置在1，因为s是从左向右遍历的，</span></span><br><span class="line"><span class="comment">                    如果从左向右i的位置就会在2，这个时候 (len-1)/2 =1 ,len/2=2 ,很明显为了保证下标正确，我们需要的是(len-1)/2，原因是i在中心线的左边一位。</span></span><br><span class="line"><span class="comment">                    所以要少减一个1</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                start = i-(len-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">                end = i+len/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start, end+<span class="number">1</span>);<span class="comment">//注意这里end+1是因为java自带左闭右开的原因</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expandCenter</span><span class="params">(String s,<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;<span class="comment">//起始的左右边界</span></span><br><span class="line">        <span class="comment">// left = right的时候，此时回文中心是一个字符，回文串的长度是奇数</span></span><br><span class="line">        <span class="comment">// right = left+1的时候，此时回文中心是一个空隙，回文串的长度是偶数</span></span><br><span class="line">        <span class="comment">// 跳出循环的时候恰好满足 s.charAt(left)!=s.charAt(right)</span></span><br><span class="line">        <span class="keyword">while</span>(left &gt;=<span class="number">0</span> &amp;&amp; right&lt;s.length() &amp;&amp; s.charAt(left)==s.charAt(right))&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right-left-<span class="number">1</span>; <span class="comment">//回文串的长度是right-left+1-2 = right -left -1</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(n^2)$ 其中n是字符串长度，长度为1和2的回文中心分别有n和n-1个，每个回文中心最多会向外扩展$O(n)$次</p><p>空间复杂度：$O(1)$</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;5-最长回文子串&quot;&gt;&lt;a href=&quot;#5-最长回文子串&quot; class=&quot;headerlink&quot; title=&quot;5-最长回文子串&quot;&gt;&lt;/a&gt;5-最长回文子串&lt;/h1&gt;&lt;h4 id=&quot;5-最长回文子串-1&quot;&gt;&lt;a href=&quot;#5-最长回文子串-1&quot; class=&quot;</summary>
      
    
    
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>7,8-整数反转,字符串转换整数(atoi)</title>
    <link href="http://example.com/2021/09/18/7,8-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC,%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0(atoi)/"/>
    <id>http://example.com/2021/09/18/7,8-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC,%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0(atoi)/</id>
    <published>2021-09-18T12:24:07.000Z</published>
    <updated>2021-09-20T16:09:43.005Z</updated>
    
    <content type="html"><![CDATA[<h1 id="7-8-整数反转-字符串转换整数-atoi"><a href="#7-8-整数反转-字符串转换整数-atoi" class="headerlink" title="7,8-整数反转,字符串转换整数(atoi)"></a>7,8-整数反转,字符串转换整数(atoi)</h1><h4 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7. 整数反转"></a><a href="https://leetcode-cn.com/problems/reverse-integer/">7. 整数反转</a></h4><h2 id="法一：按位转换"><a href="#法一：按位转换" class="headerlink" title="法一：按位转换"></a>法一：按位转换</h2><ul><li>弹出 和 推入数字</li><li><ul><li>弹出：num = x%10;   x/=10</li><li>推入：result = result x 10 + num  (这里有可能溢出)</li></ul></li><li>模式识别：整数运算注意溢出</li><li><ul><li>转换为 INT_MAX / INT_MIN的逆运算</li></ul></li></ul><p>判断某数乘十是否会溢出，就把该数 和  INT_MAX 除10 进行比较</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(rev &lt; Integer.MIN_VALUE /<span class="number">10</span> || rev &gt; Integer.MAX_VALUE/<span class="number">10</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">int</span> digit = x % <span class="number">10</span>;</span><br><span class="line">          x /= <span class="number">10</span>;</span><br><span class="line">          rev = rev * <span class="number">10</span> + digit;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">return</span> rev;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">self, x</span>):</span></span><br><span class="line">      INT_MIN, INT_MAX = -<span class="number">2</span>**<span class="number">31</span> , <span class="number">2</span>**<span class="number">31</span>-<span class="number">1</span></span><br><span class="line">        rev = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> x!=<span class="number">0</span>:</span><br><span class="line">          <span class="comment"># INT_MIN也是一个负数，不能写成 rev &lt; INT_MIN //10</span></span><br><span class="line">            <span class="keyword">if</span> rev &lt; INT_MIN//<span class="number">10</span> +<span class="number">1</span> <span class="keyword">or</span> rev &gt; INT_MAX//<span class="number">10</span>:</span><br><span class="line">              <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            digit =x %<span class="number">10</span></span><br><span class="line">            <span class="comment"># python3 的 取模运算在x为负时也会返回[0,9) 以内的数，因此需要进行特殊判断</span></span><br><span class="line">            <span class="keyword">if</span> x&lt;<span class="number">0</span> <span class="keyword">and</span> digit &gt;<span class="number">0</span>:</span><br><span class="line">              digit -= <span class="number">10</span></span><br><span class="line">            <span class="comment"># 同理python3的整数除法在x为负数时会向下(更小的负数)取整，因此不能写成 x//=10</span></span><br><span class="line">            x = (x - digit) // <span class="number">10</span></span><br><span class="line">            rev = rev * <span class="number">10</span> + digit</span><br><span class="line">     <span class="keyword">return</span> rev</span><br><span class="line">       </span><br></pre></td></tr></table></figure><h4 id="8-字符串转换整数-atoi"><a href="#8-字符串转换整数-atoi" class="headerlink" title="8. 字符串转换整数 (atoi)"></a><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/">8. 字符串转换整数 (atoi)</a></h4><p>这道题的难点在于要考虑到各种边界问题，一不留神少了一步判断可能执行就报错了。<br>根据题目描述，可能会出现各种输入条件，比如：</p><p>“ 123”<br>“ -345 “<br>“ -+7890”<br>“11223344556677889900”<br>“ -112233.44.55aabb”<br>等等…<br>我们总结一下，字符串可能包含下面三种类型:</p><p><img src="https://i.loli.net/2021/09/20/ScF8Ka7fytjEh9g.jpg" alt=""></p><p>紫色的第一部分是空格，在转换的时候需要过滤掉<br>黄色的部分是正负号，如果是正号则忽略，是负号则需要记录这个正负号状态<br>蓝色是第三部分，这部分字符串中会包含任意字符，但我们只需要”0”到”9”这几个字符</p><p>此外，对于11223344556677889900这样的字符串，明显是超长了，所以当字符串大于最大的32位整数，或者小于最小的32位整数，后面就不用判断了。<br>题目要求是只能存储32位大小的有符号整数，所以不能用long做存储，而且需要提前判断整数的大小。</p><p><img src="https://i.loli.net/2021/09/20/Na5lE2B9p8mO3DG.jpg" alt=""></p><p>上图绿色的是最大的32位整数，三个蓝色的数组代表三种不同的输入。<br>如果是第一种2147483650，这个值本身就比最大32位整数要大了，存到int里面就溢出了，所以提前一位判断，也就是到黄色格子那一位的时候就要判断了。<br>第一种情况当前的值大于214748364直接返回最大值即可。<br>对于第二种、第三种情况，如果当的值等于214748364，即前面若干位都一样，再单端判断最后一位，也就是橙色格子那一位。如果最后一位大于等于7，同样也是直接返回最大值。</p><p>对于负数也是类似的判断方式:</p><p><img src="https://i.loli.net/2021/09/20/aT2Ueq6OHWIJX43.jpg" alt=""></p><p>如果当前值小于-214748364，直接返回最小值即可。<br>如果当前值等于-214748364，再判断最后一位，如果大于等于8，返回最小值。</p><p>总结一下整个执行流程:</p><p>过滤掉前面若干个空格(如果有的话)<br>判断正号、负号位，如果是负号则记录下状态，表示输入的是负数。<br>循环判断后面的字符串是否是0到9，如果是则累加这个值<br>当前的值跟最大、最小32位整数比较看是否溢出<br>如果是正数，且大于214748364，直接返回最大值<br>如果是正数，且等于214748364，再判断最后一位是否大于7<br>如果是负数，且小于-214748364，直接返回最小值<br>如果是负数，且等于-214748364，再判断最后一位是否大于8<br>循环结束后，根据负号的标志位返回对应的正数或负数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(str==<span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n = str.length();</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">boolean</span> is_negative = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//第一步，跳过前面若干个空格</span></span><br><span class="line"><span class="keyword">while</span>(i&lt;n &amp;&amp; str.charAt(i)==<span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">++i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果字符串全是空格直接返回</span></span><br><span class="line"><span class="keyword">if</span>(i==n) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二步，判断正负号</span></span><br><span class="line"><span class="keyword">if</span>(str.charAt(i)==<span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">is_negative = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果是正负号，还需要将指针i，跳过一位</span></span><br><span class="line"><span class="keyword">if</span>(str.charAt(i)==<span class="string">&#x27;-&#x27;</span> || str.charAt(i)==<span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">++i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第三步，循环判断字符是否在 0~9之间</span></span><br><span class="line"><span class="keyword">while</span>(i&lt;n &amp;&amp; str.charAt(i)&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; str.charAt(i)&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line"><span class="comment">//&#x27;0&#x27;的ASCII码是48，&#x27;1&#x27;的是49，这么一减就从就可以得到真正的整数值</span></span><br><span class="line"><span class="keyword">int</span> tmp = str.charAt(i)-<span class="number">48</span>;</span><br><span class="line"><span class="comment">//判断是否大于 最大32位整数</span></span><br><span class="line"><span class="keyword">if</span>(!is_negative &amp;&amp;(res&gt;<span class="number">214748364</span> ||(res==<span class="number">214748364</span> &amp;&amp; tmp&gt;=<span class="number">7</span>))) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2147483647</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否小于 最小32位整数</span></span><br><span class="line"><span class="keyword">if</span>(is_negative &amp;&amp;(-res&lt;-<span class="number">214748364</span> || (-res==-<span class="number">214748364</span> &amp;&amp; tmp&gt;=<span class="number">8</span>))) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">2147483648</span>;</span><br><span class="line">&#125;</span><br><span class="line">res = res*<span class="number">10</span> + tmp;</span><br><span class="line">++i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果有负号标记则返回负数</span></span><br><span class="line"><span class="keyword">if</span>(is_negative) &#123;</span><br><span class="line"><span class="keyword">return</span> -res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;7-8-整数反转-字符串转换整数-atoi&quot;&gt;&lt;a href=&quot;#7-8-整数反转-字符串转换整数-atoi&quot; class=&quot;headerlink&quot; title=&quot;7,8-整数反转,字符串转换整数(atoi)&quot;&gt;&lt;/a&gt;7,8-整数反转,字符串转换整数(atoi)</summary>
      
    
    
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>La-MAML: Look-ahead Meta Learning for Continual Learning</title>
    <link href="http://example.com/2021/09/17/La-MAML-Look-ahead-Meta-Learning-for-Continual-Learning/"/>
    <id>http://example.com/2021/09/17/La-MAML-Look-ahead-Meta-Learning-for-Continual-Learning/</id>
    <published>2021-09-17T06:37:09.000Z</published>
    <updated>2021-10-10T06:29:22.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="La-MAML-Look-ahead-Meta-Learning-for-Continual-Learning"><a href="#La-MAML-Look-ahead-Meta-Learning-for-Continual-Learning" class="headerlink" title="La-MAML: Look-ahead Meta Learning for Continual Learning"></a>La-MAML: Look-ahead Meta Learning for Continual Learning</h1><p>持续学习问题涉及能力有限的训练模型，这些模型在一组未知数量的顺序到达的任务上表现良好。</p><p>虽然元学习在减少新旧任务之间的干扰方面显展示出潜力，但目前的训练过程往往要么很慢，要么离线，而且对许多超参数很敏感。</p><p>作者提出<em>Look-ahead MAML (La-MAML)</em> 一种optimisation-based的快速元学习算法，用于在线持续学习，并辅之以小情节记忆。</p><p>作者在元学习更新中提出的对每个参数学习率的调制，并将其与先前关于超梯度 <em>hypergradients</em> 和元下降 <em>meta-descent</em> 的工作联系起来。</p><p>与传统的基于先验的方法相比，这提供了一种更灵活和更有效的方式来减轻灾难性遗忘。</p><p>作者开发了一种基于梯度的元学习算法，以实现高效的在线持续学习。先提出了一种连续元学习的基本算法，称为连续MAML(C-MAML)，它利用replay-buffer并优化了一个减轻遗忘的元目标。随后提出了一种对C-MAML的改进，称为La-MAML，它包括对每参数学习率(LRs)的调制，以跨任务和时间调整模型的学习速度。</p><h2 id="连续学习与元学习"><a href="#连续学习与元学习" class="headerlink" title="连续学习与元学习"></a>连续学习与元学习</h2><h3 id="涉及论文"><a href="#涉及论文" class="headerlink" title="涉及论文"></a>涉及论文</h3><ul><li>GEM：Gradient episodic memory for continual learning.</li><li>MER：Learning to learn without forgetting by maximizing transfer and minimizing interference (2019)</li><li>Reptile：On first-order meta-learning algorithms  (2017)</li><li>12：Meta-learning representations for continual learning.  (2019)</li><li>Generative-replay：Continual learning with deep generative replay. (2019)</li><li>A-GEM：Efficient lifelong learning with a-GEM  (2019)</li><li>Online-aware Meta Learning (OML) : Meta-learning representations for continual learning (2019)</li><li>2 : Continuous adaptation via meta-learning in nonstationary and competitive environments (2018)</li><li>10 : Online meta-learning (2019)</li><li>19:Continual adaptation for model-based RL (2019)</li><li>BGD：Task Agnostic Continual Learning Using Online Variational Bayes</li><li>UCB：Uncertainty-guided continual learning with bayesian neural networks</li><li>AlphaMAML : Adaptive Model-Agnostic Meta-Learning.</li></ul><p>灾难性的遗忘是Continual Learning的最大的挑战之一，当随机梯度下降（SGD）所需的i.i.d.采样条件被违反时，可能会发生这种情况，因为属于要学习的不同任务的数据按顺序到达。</p><p>连续学习(CL)算法还必须有效地利用其有限的模型容量，因为未来任务的数量是未知的。因此，确保各任务之间的梯度对齐至关重要，以便在实现其目标方面取得共同进展。</p><p>梯度情节记忆(GEM)研究了CL中权重分担和遗忘之间的关系，并开发了一种显式尝试最小化梯度干扰的算法。</p><p>Meta Experience Replay(MER)形式化了迁移-干扰权衡，并表明GEM的梯度排列目标与一阶元学习算法Reptile优化的目标一致。</p><p>除了对齐梯度外，元学习算法对 CL 也很有前景，因为它们可以直接使用元目标来影响模型优化并改进泛化或迁移等辅助目标。这避免了为了更好的CL而定义诸如稀疏性这样的启发式激励。缺点是它们通常很慢，很难调整，使它们更适合离线继续学习[12]。</p><h3 id="持续学习"><a href="#持续学习" class="headerlink" title="持续学习"></a>持续学习</h3><p>方法大致三种类型 replay-based, regularisation (or prior-based) 和  meta-learning-based .</p><ul><li>replay-based：为了避免灾难性遗忘的问题，replay-based的方法在内存中维护以前任务的样本集合。利用情节缓冲器（<em>episodic-buffer</em>）统一采样旧数据以模拟独立同分布的方法。<em>Generative-replay</em>训练生成模型能够重放过去的样本，但由于复杂的非平稳分布建模的困难而引起的可扩展性问题。GEM和A-GEM将存储器样本考虑在内，来确定改变的低干扰梯度以更新参数。</li><li>Regularisation-based：是一种启发式的方法，确保保留先前任务的性能的来约束网络权重，从而完全避免使用重放。这包括惩罚被认为对旧任务很重要的权重的改变，或者强制实施权重或表征稀疏性，以确保在任何时间点只有一部分神经元保持活跃。</li><li>Meta-Learning-based：这些方法是最近才出现的。MER 受 GEM 的启发，利用重放来激励新旧任务之间的梯度对齐。 OML引入了用于预训练算法的元目标，以离线学习最优表示，该最优表示随后被冻结并用于CL。[2，10，19]研究正交设置，其中学习代理使用所有先前看到的数据来快速适应传入的数据流，从而忽略灾难性遗忘的问题。</li></ul><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>首先通过顺序地观察 $T$ 个任务的训练数据$[D_1,D_2,…,D_T]$ 来学习 $T$ 个任务的序列 $[\tau_1,\tau_2 ,…,\tau_T]$  </p><p>定义$X^i,Y^i = {(x<em>n^i,y_n^i)}</em>{n=0}^{N_i}$ 为$N_i$个输入标签集合从数据 $D_i$ 中随机抽取。</p><p>在在线学习过程中的任意时间步长 $j$，我们的目标是最小化模型在迄今看到的所有 $t$ 个任务上的经验风险 $(τ_{1:t})$，给定对来自先前任务 $τ_i(i&lt;t)$ 的数据 $(X_i，Y_i)$ 限制访问。我们将这一目标称为累积风险，具体如下：</p><script type="math/tex; mode=display">\sum_{i=1}^t \mathbf{E}_{(X^i,Y^i)}[l_i(f_i(X^i;\theta) ,Y^i)] = \mathbf{E}_{(X^{1:t},Y^{1:t})}[L_t(f(X^{1:t};\theta), Y^{1:t})]</script><p>其中 $l_i$ 是在任务$\tau_i$上的loss， $f_i$ 是学习器，参数 $θ_0^j$ 是从输入到输出的特定任务映射参数。</p><p>$L<em>t = \sum</em>{i=1}^t l<em>i$  是任务 $τ</em>{1:t}$ 的所有任务损失之和，其中 $t$ 从 1到 $T$ 。设 $l$ 表示要最小化的某些损失目标。</p><p>作用于参数$θ_0^j$ (由 $U(θ_0^j)$ ) 表示的SGD运算定义为：</p><script type="math/tex; mode=display">U(\theta^j_0)=\theta_1^j = \theta_0^j-\alpha \nabla_{\theta_0^j} l(\theta_0^j) = \theta_0^j - \alpha g_0^j</script><p>$U$ 可以为 $U_k(\theta_0^j) = U…\circ U\circ U(\theta_0^j) =\theta_k^j$</p><h3 id="Model-Agnostic-Meta-Learning-MAML"><a href="#Model-Agnostic-Meta-Learning-MAML" class="headerlink" title="Model-Agnostic Meta-Learning (MAML):"></a>Model-Agnostic Meta-Learning (MAML):</h3><p>meta learning 成为一种流行的训练模型的方法，能够在有限的数据上进行快速调整。MAML建议优化模型参数，以学习一组任务，同时改进辅助目标，如任务分布中的few-shot 少样本泛化。</p><p>基于梯度的元学习中使用的一些常用术语：</p><ul><li><p>初始化：在训练期间的给定时间步长 $j$ 处，模型参数 $θ_0^j$ (或为简单起见，$θ_0$)通常被称为初始化，因为其目的是找到对不可见数据进行 few-shot 基于梯度的适配的理想起点。</p></li><li><p>inner-updates 快速或内部更新：是对 $θ_0$ 的副本进行基于梯度的更新，以优化某些内部目标(在本例中，对于某些$τ_i$，为$l_i$)。</p></li><li><p>meta-update：元更新涉及从 $θ<em>0$ 到 $θ_k$ 的快速更新的轨迹，然后进行到 $θ_0$的永久梯度更新(或缓慢更新)。该缓慢更新是通过评估 $θ_k$ 上的辅助目标(或元损失meta loss $L</em>{meta}$)并通过轨迹微分以获得$\nabla<em>{\theta_k}L</em>{meta}(\theta<em>k)$来计算的。因此，MAML在时间步 $j$ 优化 $θ_0^j$，以便在对它们的样本进行几次梯度更新之后，对 ${\tau</em>{1:t}}$中的任务执行最佳性能。它在每一次元更新中都进行了优化，目标是：</p><script type="math/tex; mode=display">min_{\theta_0^j}\mathbf{E}_{\tau_{1:t}}[L_{meta}(U_k(\theta_0^j))] = min_{\theta_0^j}\mathbf{E}_{\tau_{1:t}}[L_{meta}(\theta_k^j)]</script></li></ul><h3 id="元学习与持续学习目标的等价性"><a href="#元学习与持续学习目标的等价性" class="headerlink" title="元学习与持续学习目标的等价性:"></a>元学习与持续学习目标的等价性:</h3><p>Reptile证明了Reptile算法和MAML算法等一阶和二阶元学习算法的近似等价性</p><p>MER随后表明，他们的CL目标是在一组任务$\tau_{1:t}$之间最小化损失并调整梯度，直到任何时间 $j$（在左边），可以通过Reptile目标（在右边）进行优化，即：</p><script type="math/tex; mode=display">min_{\theta_0^j} (\sum_{i=1}^t(l_i(\theta_0^j)) - \alpha\sum_{p,q\le t}(\frac{\partial l_p(\theta_0^j)} {\partial\theta_0^j} \cdot \frac{\partial l_q(\theta_0^j)}{\partial\theta_0^j})) =min_{\theta_{0}^j }\mathbf{E_{\tau_{1:t}}}[L_t(U_k(\theta_0^j))]</script><p>其中 meta-loss $L<em>t = \sum</em>{i=1}^t l<em>i$  根据Tasks $\tau</em>{1:t}$中的样本进行评估。这意味着元学习初始化的过程与学习CL的最优参数一致。</p><h3 id="在线感知元学习-OML-："><a href="#在线感知元学习-OML-：" class="headerlink" title="在线感知元学习(OML)："></a>在线感知元学习(OML)：</h3><p>[12]提出了元学习 <em>Representation-Learning Network</em>  网络(RLN)的概念，为<em>Task-Learning Network</em> (TLN)提供适合协作学习的表示。</p><p>RLN的表示是在离线阶段学习的，在该阶段使用灾难性遗忘作为学习信号进行训练。当TLN经历时间相关更新时，来自固定任务集（$\tau_{val}$）的数据被反复用于评估RLN和TLN。</p><p>在每个元更新的内循环中，TLN使用冻结的RLN对流式任务数据进行快速更新。然后，通过根据来自$\tau_{val}$的数据以及当前任务计算的 meta loss来评估RLN和更新的TLN。</p><p>这将测试在尝试学习流任务的过程中，模型在 $\tau_{val}$ 上的性能发生了怎样的变化。然后对meta loss进行微分，以获得针对TLN和RLN的缓慢更新的梯度。</p><p>这两个loss的组合被称为OML目标，以模拟内环中的CL和测试外环中的遗忘。RLN学习最终为CL的TLN提供更好的表示，该表示被证明具有紧急稀疏性。</p><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><p>在上一节中，我们看到OML目标可以直接规范CL行为，并且MER利用了元学习和CL目标的近似等价性。我们注意到，OML离线训练静态表示和MER算法慢得令人望而却步。</p><p>作者表明，通过多步MAML过程在线优化OML目标等同于更有效的样本效率CL目标。</p><h3 id="Continual-MAML-C-MAML"><a href="#Continual-MAML-C-MAML" class="headerlink" title="Continual-MAML (C-MAML)"></a>Continual-MAML (C-MAML)</h3><p>C-MAML旨在在线优化OML目标，这样学习当前任务就不会导致忘记以前见过的任务。我们定义了这个目标，适用于优化模型的参数 θ 而不是时间步 j 的表示，如下所示：</p><script type="math/tex; mode=display">min_{\theta_0^j} OML(\theta_0^j,t) = min_{\theta_0^j} \sum_{S_k^j\sim D_t}[L_t(U_k(\theta_0^j,S_k^j))]</script><p>其中 $S<em>k^j$ 是来自前任务$\tau</em>{t}$ 中的k个数据元组的流 $(X<em>{j+l}^t,Y</em>{j+l}^t)^k$ ，这是模型在时间 $j$ 处看到的。</p><p>Meta loss $L<em>t = \sum</em>{i=1}^l l<em>i$ 在 $\theta</em>{k}^j = U<em>k(\theta</em>{0}^j ,S_k^j)$ 上评估。它评估 $\theta_k^j$ 对于上面第一个公式中定义的持续学习预测任务的适合性，直到$\tau_t$.</p><p>省略了隐含的数据参数 $(x^i,y^i) \sim (X^i,Y^i)$ 这是任何任务$\tau_i$的 $L_t$ 中每个损失 $l_i$ 的输入。附录B</p><script type="math/tex; mode=display">min_{\theta_0^j}\mathbf{E}_{\tau_{1:t}} [L_t(U_k(\theta_0^j))] = min_{\theta_0^j} \sum_{i=1}^t(l_i(\theta_0^j) - \alpha \frac{\partial l_i(\theta_0^j)} {\partial\theta_0^j} \cdot \frac{\partial l_t(\theta_0^j)}{\partial\theta_0^j})</script><p>与上文元学习与合作学习目标的等价性那个公式不同它是不对称的，它集中于对其$\tau<em>t$的梯度和$\tau</em>{1:t}$的平均梯度，而不是在任务$\tau_{1:t}$之间对齐所有成对梯度。附录D</p><p>作者的经验表明，旧任务之间的梯度对齐不会退化，而学习了新任务，避免了重复优化它们之间的任务间对齐的需要。</p><p>这导致MER目标的显著加速，该目标试图将所有$\tau_{1:t}$ 上相乘均匀分布的批次。由于每个s 在梯度更新中有 $1/t-th$ 次贡献，因此MER有必要对包括s在内的许多此类均匀批次进行多次传递。</p><p>在训练期间，如MER中所示，通过对输入数据流的存储采样来填充重放缓冲器R。</p><p>在每次元更新开始时，从当前任务中采batch b。b还与从R采样的批次组合以形成元批次meta-batch $b<em>m$，其表示来自旧任务和新任务的样本。$\theta_0^j$通过k个基于sgd的内部更新进行更新，每次从b查看一个当前任务的样本。外部损失或元损失$L_t(\theta_k^j)$是在$b_m$上评估的。它指示参数 $\theta_k^j$ 在时间 $j$ 之前看到的所有任务 $\tau</em>{1:t}$上的性能。 附录C</p><h3 id="Lookahead-MAML-La-MAML"><a href="#Lookahead-MAML-La-MAML" class="headerlink" title="Lookahead-MAML (La-MAML)"></a>Lookahead-MAML (La-MAML)</h3><p>尽管元学习激励了任务内和任务间组的梯度对齐，但在新旧任务的梯度之间仍然可能有一些干扰，$\tau<em>{1:t−1}$和 $\tau</em>{t}$。</p><p>这将导致忘记 $\tau<em>{1:t−1}$，因为它的数据不再对我们完全可用。在训练新任务的开始阶段尤其如此，因为新任务的梯度不一定与旧任务一致。因此，需要一种机制来确保元更新相对于$\tau</em>{1:t-1}$是保守的、避免负迁移。元更新的幅度和方向需要根据更新对 $\tau_{1:t-1}$ 损失的影响程度进行调整。La-MAML包括一组可学习的pre-parameter学习率(LR)，用于内部更新，如图1所示。</p><p><img src="https://i.loli.net/2021/09/18/LhcnFOblKsCEPAZ.png" alt=""></p><p>对于每批数据，初始权重经历一系列 $k$ 次快速更新以获得 $\theta_k^j$ (这里 $j=0$)，其针对元损失进行评估以相对于权重 $\theta_0$ 和LRs $\alpha_0$ 反向传播梯度。首先，$\alpha^0$更新为$\alpha^1$，然后用于将 $\theta_0^0$更新为 $\theta_0^1$，蓝色框表示快速权重，绿色框表示慢速更新的梯度。LRs和权重以异步方式更新。</p><p>这是因为我们观察到上面OML的方程的梯度相对于内循环的 LR 的表达式直接反映了旧任务和新任务之间的对齐情况。扩充的学习目标被定义为:</p><script type="math/tex; mode=display">min_{\theta_0^j,\alpha^j} \sum_{S_k^j\sim D_t}[L_t(U_k(\alpha^j,\theta_0^j,S_k^j))]</script><p>以及该目标在时间 $j$ 的梯度，相对于 LR 向量 $\alpha^j$ （定义为$g_{MAML}(\alpha^j)$）:</p><script type="math/tex; mode=display">g_{MAML}(\alpha^j) = \frac{\partial}{\partial\alpha^j} L_t(\theta^j_k) = \frac{\partial}{\partial\theta^j_k}L_t(\theta^j_k) \cdot (-\sum_{k'=0}^{k-1}\frac{\partial}{\partial\theta_k^j} l_t(\theta_{k'}^j))</script><p>附录A推导</p><p>$g<em>{MAML}(\alpha)$ 中的第一项对应于元损失的梯度在batch上 $b_m:g</em>{meta}$。第二项表示来自内部更新的累积梯度：$g_{traj}$。</p><p>该表达式表明，当$g<em>{meta}$和 $g</em>{traj}$之间的内积较高时，LRs的梯度将为负，即两者对齐；当两者正交（不干扰）时为零，当两者之间存在干扰时为正。</p><p>负的(正的)LR梯度会拉高(降低)LR的大小。如下图：</p><p><img src="https://i.loli.net/2021/09/18/jQSTzt4dbLsVyqa.png" alt=""></p><p>$g<em>{traj}$ (蓝色虚线)和 $g</em>{meta}$对齐的不同场景，从扰动(左)到对齐(右)。黄色箭头表示内部更新。当梯度对齐(扰动)时，LR $\alpha$ </p><p>增加(减少)。</p><p>我们建议在元更新中异步更新网络权重和LRs。设$\alpha^{j+1}$ 为更新的LR 向量，该向量通过在时间 $j$ 处采用上一个等式中的LR梯度进行SGD而获得。然后，我们将权重更新为：</p><script type="math/tex; mode=display">\theta_0^{j+1} \leftarrow \theta_0^j - max(0,\alpha^{j+1}) \cdot \nabla_{\theta_0^j} L_t(\theta_k^j)</script><p>其中k是在内循环中采取的步数。 将 LRs $\alpha^{j+1}$ 修剪为正值，以避免上升梯度，并且也避免进行扰动的参数更新，从而减轻灾难性遗忘。因此，元目标保守地调节学习的速度和方向，以便在新任务上取得更快的学习进度，同时促进旧任务的迁移。</p><p><img src="https://i.loli.net/2021/09/18/oB2XVDnMRjteq3b.png" alt=""></p><p>Line(a)，(b)是C-MAML和La-MAML之间的唯一区别，C-MAML使用固定标量LR $\alpha$ 进行元更新到 $\theta_0^j$，而不是 $\alpha^{j+1}$。</p><p>作者的基于元学习的算法结合了基于先验和基于回放的方法的概念。LR在重放样本上的梯度和流任务之间的相互作用的指导下，以数据驱动的方式调制参数更新。然而，由于LR随着每次元更新而演变，它们的衰变是暂时的。这与许多基于先验的方法不同，在这些方法中，对参数更改的惩罚逐渐变得非常高，以至于网络容量饱和。</p><p>随着任务的到来，可学习的LR可以调整为高值和低值，因此是一种更简单、灵活和优雅的约束权重的方法。这种异步更新类似于信任区域优化或前瞻搜索，因为每个参数的步长是根据对它们应用假设更新后产生的损失进行调整的。</p><h3 id="与其他工作的联系"><a href="#与其他工作的联系" class="headerlink" title="与其他工作的联系"></a>与其他工作的联系</h3><h4 id="Stochastic-Meta-Descent-SMD"><a href="#Stochastic-Meta-Descent-SMD" class="headerlink" title="Stochastic Meta-Descent (SMD)"></a>Stochastic Meta-Descent (SMD)</h4><p>当学习非平稳数据分布时，使用衰减的LR策略并不常见。严格递减 LR 策略旨在更接近收敛于固定分布的固定 mimima，这与在线学习的目标不一致。由于数据分布的范围未知，因此也不可能手动调整这些计划。</p><p>然而，LRS的适应性仍然是非常需要的，以适应优化的场景，加速学习，调节适应的程度，以减少灾难性遗忘。我们的自适应LRS可以连接到离线监督学习(OSL)中的元下降。虽然存在几种不同的变种，但它们背后的核心思想和我们的方法是获得适应。当我们根据新旧任务梯度之间的相关性调整增益以在所有任务上共享进展时，[4，25]利用两个连续随机梯度之间的相关性来更快地收敛。我们利用元目标关于LRS的可微性，自动获得LR超梯度。</p><h4 id="Learning-LRs-in-meta-learning"><a href="#Learning-LRs-in-meta-learning" class="headerlink" title="Learning LRs in meta-learning"></a>Learning LRs in meta-learning</h4><p>Meta-SGD 建议学习MAML中的LRS以进行few-shot学习。他们的更新和我们的更新有一些显著的不同。它们同步更新权重和LR，而我们对LRS的异步更新用于执行更保守的权重更新。</p><p>我们更新的直觉来自于需要减轻梯度干扰及其与持续学习中普遍存在的转移-干扰权衡的联系。α-MAML解析地更新了MAML更新中的两个标量LR，以实现更自适应的few-shot学习。我们的每个参数的LR通过反向传播被隐式地调制，以基于它们在任务之间的排列来调节参数的变化，为我们的模型在CL领域提供了更强大的适应性。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>指标</p><p>使用保留精度retained accuracy（RA）度量来比较各种方法。RA 是模型在训练结束时跨任务的平均准确率。</p><p>反向迁移和干扰 <em>backward-transfer and interference</em>(BTI)值，它衡量每个任务从学习到最后一个任务结束的准确性的平均变化。 较小的 BTI 意味着训练期间遗忘较少。</p><p><em>Efficient Lifelong Learning (ELL)</em>:  高效终身学习 (LLL)：在A-GAM中形式化，高效终身学习的设置假设每个任务的传入数据必须仅通过一次处理：一旦处理，数据样本将不再可访问，除非它们被添加到 回放记忆。</p><p><img src="https://i.loli.net/2021/09/18/DrAbfMtzHEpoaBP.png" alt=""></p><p>随着训练的进行，模型会演变成对遗忘的抵抗力。这意味着超过一个点，它可以在传入样本的一个小窗口上持续进行梯度更新，而不需要进行元更新。</p><p><img src="https://i.loli.net/2021/09/18/mdJEbSojDI7aBvf.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;La-MAML-Look-ahead-Meta-Learning-for-Continual-Learning&quot;&gt;&lt;a href=&quot;#La-MAML-Look-ahead-Meta-Learning-for-Continual-Learning&quot; class=&quot;h</summary>
      
    
    
    
    
    <category term="context detection" scheme="http://example.com/tags/context-detection/"/>
    
  </entry>
  
  <entry>
    <title>4-三种方法彻底解决中位数问题</title>
    <link href="http://example.com/2021/09/15/4-%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%E5%BD%BB%E5%BA%95%E8%A7%A3%E5%86%B3%E4%B8%AD%E4%BD%8D%E6%95%B0%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2021/09/15/4-%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%E5%BD%BB%E5%BA%95%E8%A7%A3%E5%86%B3%E4%B8%AD%E4%BD%8D%E6%95%B0%E9%97%AE%E9%A2%98/</id>
    <published>2021-09-15T01:31:49.000Z</published>
    <updated>2021-09-16T03:23:36.548Z</updated>
    
    <content type="html"><![CDATA[<h1 id="4-三种方法彻底解决中位数问题"><a href="#4-三种方法彻底解决中位数问题" class="headerlink" title="4-三种方法彻底解决中位数问题"></a>4-三种方法彻底解决中位数问题</h1><h4 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a>4. 寻找两个正序数组的中位数</h4><h2 id="两种思想"><a href="#两种思想" class="headerlink" title="两种思想"></a>两种思想</h2><ul><li>真合并：使用归并的方式，合并两个有序数组，得到一个大的有序数组，大的有序数组中的中间位置的元素即为中位数。$O(n+m),O(n+m)$</li><li>假合并：不需要合并两个有序数组，只要找到中位数的位置即可。由于两个数组的长度已知，因此中位数对应的两个数组下标之和也是已知的。维护两个指针，初始时分别指向两个数组的下标为0的位置，每次将指向较小的指针后移一位（如果一个指针已经到达数组末尾，则只需要移动另一个数组的指针），直到达到中位数的位置。$O(n+m),O(1)$</li></ul><h2 id="常见的思想改进：假合并、奇偶合并"><a href="#常见的思想改进：假合并、奇偶合并" class="headerlink" title="常见的思想改进：假合并、奇偶合并"></a>常见的思想改进：假合并、奇偶合并</h2><p>通过假合并的思想可以将空间复杂度优化到$O(1)$但对于时间复杂度并没有什么优化，此方法代码复杂，不仅要考虑奇偶问题，更需要高了一个数组遍历后的各种边界问题。</p><p>假合并的一个优化点是 将奇偶两种情况合并到了一起：</p><ul><li>如果是奇数，我们需要知道第(len+1)/2 个数就可以了，如果遍历的话需要遍历int(len/2)+1次</li><li>如果是偶数，需要知道第(len/2) 和 len/2 + 1个数，也是需要遍历len/2 + 1次</li><li>返回中位数，奇数需要最后一次遍历结果就可以，偶数需要最后一次和上一次的结果。所以用两个变量left和right。right保存当前循环的结果，在每次循环前将right赋值给left。这样在最后一次循环的时候，left将得到right的值，也就是上一次的循环结果，加下来right更新为最后一次的结果len/2+1次</li></ul><p>另一种合并的思想是: 我们可以在奇数的时候, 在<strong>末尾等处添加一个占位符</strong>#等, 这样也是可以将奇数合并成偶数的情况的.此方法的另一个优化点就是 通过在if条件中<strong>加入大量的限制条件</strong>, 从而实现了对于各种边界问题的处理, 这也是一种很重要的思想.</p><p><img src="https://i.loli.net/2021/09/15/rwI2miAu4SPgOX7.jpg" alt=""></p><p><img src="https://i.loli.net/2021/09/15/G1OiltFhg24JmY8.jpg" alt=""></p><p>此方法的时间复杂度相对于下面两种思想还是太高了, 大家不用特意掌握此方法, 但是这两个优化的思想还是很重要的, 要好好的理解一下.</p><p>接下来我们就来详细讲解两个时间复杂度超低的算法代码思想.</p><h2 id="寻找第k小数-记住这个"><a href="#寻找第k小数-记住这个" class="headerlink" title="寻找第k小数(记住这个)"></a>寻找第k小数(记住这个)</h2><p> 主要就是根据两个数的三种比较结果, 不断地去除不满足的元素的过程.</p><p><img src="https://i.loli.net/2021/09/15/hKBdPugr5fRxXeC.jpg" alt=""></p><p>这个思想最难的点在于 <strong>三种特殊情况的处理</strong>, 我们能否想到这三种情况, 并将他们<strong>完美的融入到代码之中</strong>, 我感觉这才是真正的难点所在.</p><p><img src="https://i.loli.net/2021/09/15/AdgYMm3xTtQSup8.jpg" alt=""></p><p>最开始对于奇数和偶数的两种情况进行了判断, 其实是可以将两种情况合并的, 只需要在奇数时求两次同样的k就可以了.</p><p><img src="https://i.loli.net/2021/09/15/rmU7B5WJRGELvjd.jpg" alt=""></p><p>接下来处理了三种特殊情况中的两种特殊情况: 一个数组为空 和 k=1.</p><p><img src="https://i.loli.net/2021/09/15/XGbolki98Dv6BCK.jpg" alt=""></p><p>下面的<strong>几个定义</strong>就非常重要了, 一定要弄清这些定义的含义, 才能更轻松的理解代码.</p><p><img src="https://i.loli.net/2021/09/15/vkMmQjqNbPZGIwn.jpg" alt=""></p><p>index1, index2作为数组的起始点的下标, 初值都是0, 但是随着两个数组不断被删除元素, 这两个起始点也是在不断的进行变化, 具体变化方式就是 index1 = newIndex1 + 1, 因为在删除元素的时候 连同比较位置也一同删去了, 所以新的开始是 比较位置 的后一位.</p><p>newindex1, newindex2作为比较点就是图中被框中的两个数的下标, 它的赋值过程就涉及到了 最后一个边界情况. 因为当一个数组较短时, 其中一个比较点可能已经到达了数组的最后, 所以它的值是 两种情况下较小的那个数.</p><p><img src="https://i.loli.net/2021/09/15/mAW7YsNX5GBcKgH.jpg" alt=""></p><p>接下来就是根据两个比较点的大小来进行不同的操作过程了, 这里最难理解的点就是 k -= (newIndex1 - index1 + 1), 也就是减去元素的个数问题了. 我们根据上面的图来举例, 图中index1的值为0, newindex1的值经过计算为1, 通过比较后, 可以看到 红色的数 就是被删除的数, 也就是两个, 所以我们需要在最后+1才是真实被删去的个数. 对于此类问题在确定最终个数的时候, 我们都可以通过这样的特例来决定代码的书写, 至此代码就全部讲解完成了.</p><p><img src="https://i.loli.net/2021/09/15/1hmHAU4Ets7iFJ9.jpg" alt=""></p><h2 id="理解中位数作用进行划分数组"><a href="#理解中位数作用进行划分数组" class="headerlink" title="理解中位数作用进行划分数组"></a>理解中位数作用进行划分数组</h2><p>最后这种思想时间复杂度比上面的还低，上面的思想每一轮循环可以将查找范围减少一半，因此时间复杂度是$O(log(m+n))$ ，但这种思想可以对确定的较短的数组进行二分查找，所以它的时间复杂度是$O(logmin(m,n))$</p><p>划分数组正好和上面算法完全相反，它的思想特别复杂，但思想理解了，代码写起来倒是没太大难度。</p><p>首先要明白中位数的作用：将一个集合划分为两个长度相等的子集，其中一个子集中的元素总是大于另一个子集中的元素。这种思想无论是在机构数组中都是适用的，这就衍生出了下面的思想。</p><p>首先讨论奇偶两种不同情况的不同划分方式，</p><p><img src="https://i.loli.net/2021/09/16/8n9sSjVk7C3GKZM.jpg" alt=""></p><p>然后在写代码时，由于计算机的取整操作，我们是可以将这两种情况合并成一种代码书写方式，其中的$i$和$j$分别是两个数组的划分位置。</p><p><img src="https://i.loli.net/2021/09/16/LzOv1Zxn8pBUVQo.jpg" alt=""></p><p>同样我们也会遇到复杂的边界问题, 但下面这种处理方式是真的非常优秀.</p><p><img src="https://i.loli.net/2021/09/16/bBhSzkpAOunIXNj.jpg" alt=""></p><p>上面问题都考虑完了, 其实就可以写代码了, 但是我们需要进行两个条件的判断: B[j−1]≤A[i] 以及A[i−1]≤B[j], 为了优化代码, 经过分析后, 我们发现这两种情况是可以等价转换的. 也就是只需要进行一个条件的判断即可.</p><p><img src="https://i.loli.net/2021/09/16/YZ2lJiL9IomnaKH.jpg" alt=""></p><p>代码中有个注意点就是java中的<strong>三目运算符? :</strong> 在Python中是没有引入这个符号的, 但是Python利用了已有的关键字if…else实现了这个功能.</p><p><img src="https://i.loli.net/2021/09/16/gRSNcoWaidyOnhz.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//常规思想 假合并</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n = nums2.length;</span><br><span class="line">        <span class="keyword">int</span> len = m+n;</span><br><span class="line">        <span class="keyword">int</span> left = -<span class="number">1</span>, right= -<span class="number">1</span>; <span class="comment">// 记录前后两个数</span></span><br><span class="line">        <span class="keyword">int</span> aStart=<span class="number">0</span>, bStart=<span class="number">0</span>;  <span class="comment">// 记录两个数组的移动</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=len/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            left = right; <span class="comment">// 每次循环前将right的值赋给left</span></span><br><span class="line">            <span class="comment">// A移动的条件：B遍历到最后 或当前 A&lt;B 满足一个即可</span></span><br><span class="line">            <span class="keyword">if</span>(aStart &lt; m &amp;&amp; (bStart&gt;=n || nums1[aStart] &lt; nums2[bStart]))&#123;</span><br><span class="line">                right = nums1[aStart++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right= nums2[bStart++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((len &amp; <span class="number">1</span>) == <span class="number">0</span>) <span class="comment">// 与1交，判断奇偶数，更快速</span></span><br><span class="line">            <span class="keyword">return</span> (left+right)/<span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第k小数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length1 = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> length2 = nums2.length;</span><br><span class="line">        <span class="keyword">int</span> totallength = length1+ length2;</span><br><span class="line">        <span class="keyword">if</span>(totallength % <span class="number">2</span> == <span class="number">1</span>)&#123; <span class="comment">// 可以将两种情况合并，奇数会求两次同样的k</span></span><br><span class="line">            <span class="keyword">int</span> midIndex = totallength/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">double</span> median = getKthElement(nums1, nums2, midIndex+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> median;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> midIndex1 = totallength/<span class="number">2</span> -<span class="number">1</span> , midIndex2 = totallength/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">double</span> median = (getKthElement(nums1, nums2, midIndex1 + <span class="number">1</span>) + getKthElement(nums1, nums2, midIndex2 + <span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">            <span class="keyword">return</span> median;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getKthElement</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        主要思路：要找到第k(k&gt;1)小的元素，那么就取pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较</span></span><br><span class="line"><span class="comment">        这里的“/” 表示整除</span></span><br><span class="line"><span class="comment">        nums1 中小于等于pivot1的元素有 nums1[0..k/2-2] 共计k/2-1个</span></span><br><span class="line"><span class="comment">        nums2 中小于等于pivot2的元素有 nums2[0..k/2-2] 共计k/2-1个</span></span><br><span class="line"><span class="comment">        取 pivot = min(pivot1 , pivot2) 两个数组中小于等于 pivot的元素共计不会超过(k/2-1)+(k/2-1) &lt;=k-2个</span></span><br><span class="line"><span class="comment">        这样pivot本身最大也只能是第k-1小的元素</span></span><br><span class="line"><span class="comment">        * 如果 pivot = pivot1,那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;,剩下的作为新的 nums1 数组</span></span><br><span class="line"><span class="comment">         * 如果 pivot = pivot2,那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;,剩下的作为新的 nums2 数组</span></span><br><span class="line"><span class="comment">        由于我们 &quot;删除&quot; 了一些元素（这些元素都比第 k 小的元素要小）,因此需要修改 k 的值,减去删除的数的个数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> length1 = nums1.length, length2=nums2.length;</span><br><span class="line">        <span class="keyword">int</span> index1 = <span class="number">0</span>, index2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> kthElemnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//特殊情况</span></span><br><span class="line">            <span class="keyword">if</span>(index1==length1)&#123;<span class="comment">//第二种特殊情况，一个数组为空</span></span><br><span class="line">                <span class="keyword">return</span> nums2[index2+k-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(index2==length2)&#123;<span class="comment">//一个数组为空</span></span><br><span class="line">                <span class="keyword">return</span> nums1[index1+k-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">1</span>)&#123; <span class="comment">// 第三种情况，k=1</span></span><br><span class="line">                <span class="keyword">return</span> Math.min(nums1[index1], nums2[index2]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 正常情况， index1，index2作为起始点，newindex1,newindex2作为比较点 在不停的更新</span></span><br><span class="line">            <span class="keyword">int</span> half = k/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> newIndex1 = Math.min(index1 + half, length1) -<span class="number">1</span>;<span class="comment">// 第一种情况，发生越界，需要记录比较的位置</span></span><br><span class="line">            <span class="keyword">int</span> newIndex2 = Math.min(index2 + half, length2) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> pivot1 = nums1[newIndex1], pivot2=nums2[newIndex2]; <span class="comment">//获取两个需要比较的数</span></span><br><span class="line">            <span class="keyword">if</span>(pivot1&lt;=pivot2)&#123;</span><br><span class="line">                <span class="comment">// 将两种情况合并</span></span><br><span class="line">                k -= (newIndex1 -index1 +<span class="number">1</span>); <span class="comment">//两者相减后+1，这才是真正减去的长度</span></span><br><span class="line">                index1 = newIndex1+<span class="number">1</span>; <span class="comment">//连同比较位置也一同删去了，所以新的开始是 比较位置的后一位</span></span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                k -= (newIndex2-index2+<span class="number">1</span>);</span><br><span class="line">                index2 = newIndex2+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1.length &gt; nums2.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> findMedianSortedArrays(nums2, nums1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n = nums2.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = m;</span><br><span class="line">        <span class="comment">// median1：前一部分的最大值</span></span><br><span class="line">        <span class="comment">// median2：后一部分的最小值</span></span><br><span class="line">        <span class="keyword">int</span> median1 = <span class="number">0</span>, median2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123; <span class="comment">// 一直循环找到一个最大的i满足A[i-1]≤B[j]</span></span><br><span class="line">            <span class="comment">// 前一部分包含 nums1[0 .. i-1] 和 nums2[0 .. j-1]</span></span><br><span class="line">            <span class="comment">// 后一部分包含 nums1[i .. m-1] 和 nums2[j .. n-1]</span></span><br><span class="line">            <span class="keyword">int</span> i = (left + right) / <span class="number">2</span>; <span class="comment">//二分法,i从区间中间开始</span></span><br><span class="line">            <span class="keyword">int</span> j = (m + n + <span class="number">1</span>) / <span class="number">2</span> - i;<span class="comment">//+1的操作将总数为奇数和偶数合并为一种情况</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//nums_im1, nums_i, nums_jm1, nums_j 分别表示 nums1[i-1], nums1[i], nums2[j-1], nums2[j]</span></span><br><span class="line">            <span class="comment">//当一个数组不出现在前一部分时,对应的值为负无穷,就不会对前一部分的最大值产生影响</span></span><br><span class="line">            <span class="keyword">int</span> nums_im1 = (i == <span class="number">0</span> ? Integer.MIN_VALUE : nums1[i - <span class="number">1</span>]);</span><br><span class="line">            <span class="comment">//当一个数组不出现在后一部分时,对应的值为正无穷,就不会对后一部分的最小值产生影响</span></span><br><span class="line">            <span class="keyword">int</span> nums_i = (i == m ? Integer.MAX_VALUE : nums1[i]);</span><br><span class="line">            <span class="keyword">int</span> nums_jm1 = (j == <span class="number">0</span> ? Integer.MIN_VALUE : nums2[j - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">int</span> nums_j = (j == n ? Integer.MAX_VALUE : nums2[j]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums_im1 &lt;= nums_j) &#123;</span><br><span class="line">                median1 = Math.max(nums_im1, nums_jm1);</span><br><span class="line">                median2 = Math.min(nums_i, nums_j);</span><br><span class="line">                left = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = i - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (m + n) % <span class="number">2</span> == <span class="number">0</span> ? (median1 + median2) / <span class="number">2.0</span> : median1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="comment"># 常规思想</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays1</span>(<span class="params">self, nums1, nums2</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m = <span class="built_in">len</span>(nums1)</span><br><span class="line">        n = <span class="built_in">len</span>(nums2)</span><br><span class="line">        lens = m+n</span><br><span class="line">        left, right = -<span class="number">1</span>, -<span class="number">1</span></span><br><span class="line">        aStart,bStart = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(lens//<span class="number">2</span>+<span class="number">1</span>):</span><br><span class="line">            left = right  <span class="comment"># 每次循环将right的值赋值给left</span></span><br><span class="line">            <span class="comment"># A移动的条件，B遍历到最后 或A&lt;B满足一个</span></span><br><span class="line">            <span class="keyword">if</span> aStart&lt;m <span class="keyword">and</span> (bStart &gt;= n <span class="keyword">or</span> nums1[aStart] &lt; nums2[bStart]):</span><br><span class="line">                right = nums1[aStart]</span><br><span class="line">                aStart+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = nums2[bStart]</span><br><span class="line">                bStart+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (lens &amp; <span class="number">1</span>)  == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> (left+right)/<span class="number">2.0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> right</span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">    <span class="comment"># 第k小数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span>(<span class="params">self, nums1, nums2</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getKthElemnt</span>(<span class="params">k</span>):</span></span><br><span class="line">            index1, index2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="comment"># 特殊情况</span></span><br><span class="line">                <span class="keyword">if</span> index1 == m:</span><br><span class="line">                    <span class="keyword">return</span> nums2[index2+k-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> index2 == n:</span><br><span class="line">                    <span class="keyword">return</span> nums1[index1+k-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> k==<span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">min</span>(nums1[index1], nums2[index2])</span><br><span class="line"></span><br><span class="line">                newIndex1 = <span class="built_in">min</span>(index1 + k//<span class="number">2</span> -<span class="number">1</span>, m-<span class="number">1</span>)</span><br><span class="line">                newIndex2 = <span class="built_in">min</span>(index2 + k//<span class="number">2</span> -<span class="number">1</span>, n-<span class="number">1</span>)</span><br><span class="line">                privot1,privot2 =nums1[newIndex1], nums2[newIndex2]</span><br><span class="line">                <span class="keyword">if</span> privot1&lt;=privot2:</span><br><span class="line">                    k-=newIndex2-index1 +<span class="number">1</span></span><br><span class="line">                    index1 = newIndex2 + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    k -= newIndex2 - index2 +<span class="number">1</span></span><br><span class="line">                    index2 = newIndex2 +<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        m,n = <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">        totalLength = m+n</span><br><span class="line">        <span class="keyword">if</span> totalLength % <span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> getKthElemnt((totalLength+<span class="number">1</span>)//<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (getKthElemnt(totalLength//<span class="number">2</span>)+ getKthElemnt(totalLength//<span class="number">2</span>+<span class="number">1</span>)) /<span class="number">2</span> </span><br><span class="line">          </span><br><span class="line">    <span class="comment"># 划分数组</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span>(<span class="params">self, nums1: List[<span class="built_in">int</span>], nums2: List[<span class="built_in">int</span>]</span>) -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums1) &gt; <span class="built_in">len</span>(nums2):</span><br><span class="line">            <span class="keyword">return</span> self.findMedianSortedArrays(nums2, nums1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        infinty = <span class="number">2</span>**<span class="number">40</span>  <span class="comment"># 代表正无穷</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">        left, right = <span class="number">0</span>, m</span><br><span class="line">        <span class="comment"># median1：前一部分的最大值</span></span><br><span class="line">        <span class="comment"># median2：后一部分的最小值</span></span><br><span class="line">        median1, median2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right: <span class="comment"># 一直循环找到一个最大的i满足A[i−1]≤B[j]</span></span><br><span class="line">            <span class="comment"># 前一部分包含 nums1[0 .. i-1] 和 nums2[0 .. j-1]</span></span><br><span class="line">            <span class="comment"># // 后一部分包含 nums1[i .. m-1] 和 nums2[j .. n-1]</span></span><br><span class="line">            i = (left + right) // <span class="number">2</span></span><br><span class="line">            j = (m + n + <span class="number">1</span>) // <span class="number">2</span> - i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment"># nums_im1, nums_i, nums_jm1, nums_j 分别表示 nums1[i-1], nums1[i], nums2[j-1], nums2[j]</span></span><br><span class="line">            <span class="comment"># 当一个数组不出现在前一部分时,对应的值为负无穷,就不会对前一部分的最大值产生影响</span></span><br><span class="line">            nums_im1 = (-infinty <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">else</span> nums1[i - <span class="number">1</span>]) <span class="comment"># 注意写法与java不同</span></span><br><span class="line">            <span class="comment"># 当一个数组不出现在后一部分时,对应的值为正无穷,就不会对后一部分的最小值产生影响</span></span><br><span class="line">            nums_i = (infinty <span class="keyword">if</span> i == m <span class="keyword">else</span> nums1[i])</span><br><span class="line">            nums_jm1 = (-infinty <span class="keyword">if</span> j == <span class="number">0</span> <span class="keyword">else</span> nums2[j - <span class="number">1</span>])</span><br><span class="line">            nums_j = (infinty <span class="keyword">if</span> j == n <span class="keyword">else</span> nums2[j])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> nums_im1 &lt;= nums_j:</span><br><span class="line">                median1, median2 = <span class="built_in">max</span>(nums_im1, nums_jm1), <span class="built_in">min</span>(nums_i, nums_j)</span><br><span class="line">                left = i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = i - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (median1 + median2) / <span class="number">2</span> <span class="keyword">if</span> (m + n) % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> median1</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/"></a></h4><p><img src="https://i.loli.net/2021/09/15/roqxyuNvdGnAlX7.jpg" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;4-三种方法彻底解决中位数问题&quot;&gt;&lt;a href=&quot;#4-三种方法彻底解决中位数问题&quot; class=&quot;headerlink&quot; title=&quot;4-三种方法彻底解决中位数问题&quot;&gt;&lt;/a&gt;4-三种方法彻底解决中位数问题&lt;/h1&gt;&lt;h4 id=&quot;4-寻找两个正序数组的中位</summary>
      
    
    
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
  </entry>
  
</feed>
