<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Coding-Zuo</title>
  
  <subtitle>Coding And Studying</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-09-28T06:41:24.256Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Coding-Zuo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Efficient lifelong learning with A-GEM</title>
    <link href="http://example.com/2021/09/28/EFFICIENT-LIFELONG-LEARNING-WITH-A-GEM/"/>
    <id>http://example.com/2021/09/28/EFFICIENT-LIFELONG-LEARNING-WITH-A-GEM/</id>
    <published>2021-09-28T03:26:24.000Z</published>
    <updated>2021-09-28T06:41:24.256Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Efficient-lifelong-learning-with-A-GEM"><a href="#Efficient-lifelong-learning-with-A-GEM" class="headerlink" title="Efficient lifelong learning with A-GEM"></a>Efficient lifelong learning with A-GEM</h1><p>从样本复杂度、计算和内存成本方面研究了当前终身学习方法的效率。</p><p>首先引入了一个新的、更现实的评估协议，学习者只观察每个例子一次，超参数选择是在一个小的、不相交的任务集上完成的，不用于实际的学习体验和评估 .</p><p>其次，引入了一个新的度量标准来衡量学习者获得一项新技能的速度。</p><p>第三，提出了 GEM 的改进版本，称为平均 GEM (A-GEM)，它具有与 GEM 相同甚至更好的性能，同时在计算和内存效率方面几乎与 EWC 和其他基于正则化的方法一样。</p><p>最后，包括A-GEM在内的所有算法，如果提供指定所考虑的分类任务的任务描述符，则可以更快地学习。</p><h2 id="Learning-protocol"><a href="#Learning-protocol" class="headerlink" title="Learning protocol"></a>Learning protocol</h2><p>一种新的学习范式，即学习者对一组与实际用于评估的任务集不相交的任务进行交叉验证。在这种情况下，学习者将必须学习并将在一个全新的任务序列上进行测试，并且它将仅在该数据流上执行一次。</p><p>以前关于终身学习的工作采用直接从监督学习中借用的学习范式。 有 T 个任务，每个任务由训练集、验证集和测试集组成。 在训练期间，学习者根据需要对每个任务的数据进行尽可能多的传递。</p><p>此外，通过根据交叉验证网格搜索所需的次数扫描整个任务序列来调整验证集上的超参数。最后，使用由先前交叉验证过程选择的模型在每个任务的测试集上报告度量。</p><p>由于当前范式违反了我们对 LLL 的更严格定义，即学习者只能对数据进行一次传递，因为我们想强调从数据中快速学习的重要性，因此现在引入了一种新的学习范式。</p><p>我们考虑由以下有序数据集序列描述的两个任务流：</p><p>$D^{CV}={D<em>1,…,D</em>{T^{CV}}}$  和 $D^{EV} = {D_{T^{CV}+1},…,D_T}$</p><p>其中 $D<em>k = {(x_i^k,t_i^k,y_i^k)</em>{i=1}^{n_k}}$  是第k个任务的数据集。 $T^{CV}&lt;T$ 在实验中 $T^{CV}=3,T=20$</p><p>我们假设所有数据集都来自相同的任务分布。 为了避免符号混乱，让上下文指定 $D_k$ 是指第 k 个数据集的训练集或测试集。</p><p>$D^{CV}$是交叉验证期间将使用的数据集的流。$D^{CV}$允许学习者出于模型超参数选择的目的多次重放所有样本。</p><p>相反，$D^{EV}$是用于测试集的最终训练和评估的实际数据集。学习者将观察 $D^{EV}$ 中的训练样本一次且仅一次，并且所有指标都将在 $D^{EV}$的测试集上报告。</p><p><img src="https://z3.ax1x.com/2021/09/28/4WN3Nt.png" style="zoom:150%;" /></p><h2 id="Metrics"><a href="#Metrics" class="headerlink" title="Metrics"></a>Metrics</h2><p>引入了一个新的度量标准来衡量学习速度，它有助于量化一个学习算法学习一个新任务的能力—— Learning Curve Area (LCA)</p><p>每个任务的训练数据集 $D_k$ 由总共 $B_k$个小批次组成。在每次呈现一小批任务 $k$ 之后，使用相应的测试集来评估学习者在所有任务上的表现。</p><p>设 $\alpha_{k,i,j}\in [0,1]$是用任务 $k$ 的第 $i$ 个小批次训练模型后，在任务 $j$ 的测试集上评估的准确度。</p><p>假设连续体中的第一个学习任务由1索引 ( $T^{CV}+1$ 对应于 $D^{EV}$ ) ,  $T$ 的最后一个(对于 $D^{CV}$ ，将是 $T^{CV}$)，我们定义了以下指标：</p><h3 id="Average-Accuracy"><a href="#Average-Accuracy" class="headerlink" title="Average Accuracy"></a>Average Accuracy</h3><p>$A\in [0,1]$ 用所有小批量连续训练模型后的平均精度，直到任务k被定义为：</p><script type="math/tex; mode=display">A_k = \frac{1}{k} \sum_{j=1}^k \alpha_{k, B_{k},j}</script><p>$A_T$ 是所有任务的平均准确率，是最后一个任务学习后得到的。这是LLL中最常用的度量。</p><h3 id="Forgetting-Measure"><a href="#Forgetting-Measure" class="headerlink" title="Forgetting Measure"></a>Forgetting Measure</h3><p>$F \in [-1,1]$  模型经过所有小批量连续训练后的平均遗忘，直到任务 k 被定义为：</p><script type="math/tex; mode=display">F_k = \frac{1}{k-1} \sum_{j=1}^{k-1} f_j^k</script><p>其中 $f_j^k$ 是在使用所有小批量训练模型直到任务 k 并计算为：</p><script type="math/tex; mode=display">f_j^k = max_{l\in \{1,...,k-1\}} \alpha_{l,B_l,j} - \alpha_{k, B_k, j}</script><p>在学习完所有任务后测量遗忘很重要，原因有两个。它量化了过去任务的准确率下降，并给出了模型学习新任务的速度的间接概念，因为健忘的模型几乎没有剩余的知识可以转移，特别是如果新任务与其中一个任务更密切相关 。</p><h3 id="Learning-Curve-Area"><a href="#Learning-Curve-Area" class="headerlink" title="Learning Curve Area"></a>Learning Curve Area</h3><p>$LCA \in [0,1]$ 让我们首先定义模型在所有 T 任务训练后的平均 b-shot 性能（其中 b 是小批量数）：</p><script type="math/tex; mode=display">Z_b = \frac{1}{T} \sum_{k=1}^T \alpha_{k,b,k}</script><p>$\beta$ 处的 LCA 是作为  $b \in [0, \beta]$ 函数的收敛曲线 $Z_b$ 的面积：</p><script type="math/tex; mode=display">LCA_{beta} = \frac{1}{\beta+1} \int_0^{\beta} Z_b db = \frac{1}{\beta+1} \sum_{b=0}^{\beta} Z_b</script><p>LCA 有一个直观的解释。 $LCA<em>0$ 是平均 0-shot 表现，与 GEM 中的前锋转移相同。 $LCA</em>{\beta}$  是  $Z<em>b$ 曲线下的区域，如果 0-shot 性能好并且学习器学习速度快，则该区域很高。 特别是，可能有两个模型具有相同的 $Z_b$ 或 $A_T$ ，但 $LCA</em>{\beta}$ 非常不同，因为一个模型比另一个学习得快得多，而它们最终都获得了相同的最终精度。 该度量旨在区分这两种情况，并且对于相对较小的 $\beta$ 值是有意义的，因为我们对从少数示例中学习的模型感兴趣。</p><h2 id="Averaged-gradient-episodic-memory-A-GEM"><a href="#Averaged-gradient-episodic-memory-A-GEM" class="headerlink" title="Averaged gradient episodic memory (A-GEM)"></a>Averaged gradient episodic memory (A-GEM)</h2><p>A-GEM 建立在 GEM  的基础上，该算法利用小的情节记忆在单遍设置中表现良好，并对损失函数提出了一个小的改变，使 GEM 在 训练时间，同时保持相似的表现； </p><h2 id="Joint-embedding-model-using-compositional-task-descriptors"><a href="#Joint-embedding-model-using-compositional-task-descriptors" class="headerlink" title="Joint embedding model using compositional task descriptors"></a>Joint embedding model using compositional task descriptors</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Efficient-lifelong-learning-with-A-GEM&quot;&gt;&lt;a href=&quot;#Efficient-lifelong-learning-with-A-GEM&quot; class=&quot;headerlink&quot; title=&quot;Efficient lifelo</summary>
      
    
    
    
    
    <category term="context detection" scheme="http://example.com/tags/context-detection/"/>
    
  </entry>
  
  <entry>
    <title>14-最长公共前缀(二分、分治)</title>
    <link href="http://example.com/2021/09/25/14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80-%E4%BA%8C%E5%88%86%E3%80%81%E5%88%86%E6%B2%BB/"/>
    <id>http://example.com/2021/09/25/14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80-%E4%BA%8C%E5%88%86%E3%80%81%E5%88%86%E6%B2%BB/</id>
    <published>2021-09-25T01:05:01.000Z</published>
    <updated>2021-09-28T00:53:33.960Z</updated>
    
    <content type="html"><![CDATA[<h1 id="14-最长公共前缀-二分、分治"><a href="#14-最长公共前缀-二分、分治" class="headerlink" title="14-最长公共前缀(二分、分治)"></a>14-最长公共前缀(二分、分治)</h1><h4 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a><a href="https://leetcode-cn.com/problems/longest-common-prefix/">14. 最长公共前缀</a></h4><h2 id="法一：横向扫描"><a href="#法一：横向扫描" class="headerlink" title="法一：横向扫描"></a>法一：横向扫描</h2><p>用 $LCP(S_1,…,S_n)$ 表示字符串 $S_1,…,S_n$的最长公共前缀，可得</p><script type="math/tex; mode=display">LCP(S_1,...,S_n) = LCP(LCP (LCP(S_1,S_2), S_3),...,S_n)</script><p>基于该结论可得到一种查找字符串数组中的最长前缀的简单方法。依次遍历字符串中的每个字符串。对于每个遍历到的字符串，更新最长公共前缀，当遍历完所有的字符串以后，即可得到字符串数组中的最长公共前缀。</p><p><img src="https://i.loli.net/2021/09/25/nxdtFq4bUIczGSC.png" alt=""></p><p>如果在尚未遍历完所有的字符串时，最长公共前缀已经是空串，则最长公共前缀一定是空串，因此不需要继续遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs == <span class="keyword">null</span> || strs.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String prefix = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> count = strs.length;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; count;i++)&#123;</span><br><span class="line">            prefix = longestCommonPrefix(prefix, strs[i]); </span><br><span class="line">            <span class="keyword">if</span>(prefix.length() == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String str1, String str2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = Math.min(str1.length(), str2.length());</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(index&lt;length &amp;&amp; str1.charAt(index) == str2.charAt(index))&#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str1.substring(<span class="number">0</span>,index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span>(<span class="params">self, strs: List[<span class="built_in">str</span>]</span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> strs:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        prifix , count = strs[<span class="number">0</span>], <span class="built_in">len</span>(strs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,count):</span><br><span class="line">            prifix = self.lcp(prifix, strs[i]);</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> prifix:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> prifix</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lcp</span>(<span class="params">self, str1,str2</span>):</span></span><br><span class="line">        length, index = <span class="built_in">min</span>(<span class="built_in">len</span>(str1), <span class="built_in">len</span>(str2)), <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> index &lt; length <span class="keyword">and</span> str1[index] == str2[index]:</span><br><span class="line">            index+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> str1[:index]</span><br></pre></td></tr></table></figure><p>复杂度：</p><ul><li>时间$O(mn)$ m是字符串数组中的字符串的平均长度，n是字符串的数量。最坏情况下，字符串数组中的每个字符串的每个字符都会被比较一次。</li><li>空间 $O(1)$</li></ul><h2 id="法二：纵向扫描"><a href="#法二：纵向扫描" class="headerlink" title="法二：纵向扫描"></a>法二：纵向扫描</h2><p>方法一是横向扫描，依次遍历每个字符串，更新最长公共前缀。另一种方法是纵向扫描。</p><p>纵向扫描时，从前往后遍历所有字符串的每一列，比较相同列上的字符是否相同。</p><p>如果相同则继续对下一列进行比较，如不相同则当前列不再属于公共前缀，当前列之前的部分为最长。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs==<span class="keyword">null</span> || strs.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = strs[<span class="number">0</span>].length();</span><br><span class="line">        <span class="keyword">int</span> count = strs.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = strs[<span class="number">0</span>].charAt(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;count;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==strs[j].length() || strs[j].charAt(i)!=c)&#123;</span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>,i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析</p><ul><li>时间复杂度 $O(mn)$ 其中 m 是字符串数组中的字符串的平均长度，n是字符串的数量</li><li>空间 $O(1)$</li></ul><h2 id="方法三：分治"><a href="#方法三：分治" class="headerlink" title="方法三：分治"></a>方法三：分治</h2><p>注意到 LCP 的计算满足结合律，有以下结论：</p><script type="math/tex; mode=display">LCP(S_1, ..., S_n) = LCP(LCP(S_1,...,S_k), LCP(S_{k+1},...,S_n))</script><p>其中$LCP(S_1,…,S_n)$ 是字符串 $S_1,…,S_n$ 的最长公共前缀，$1&lt;k&lt;n$</p><p>基于上述结论，可以使用分治法得到字符串数组中的最长公共前缀。对于问题 $LCP(S<em>i,…,S_j)$，可以分解成两个子问题 $LCP(S_i,…,S</em>{mid})$ 与$LCP(S_{mid+1},…,S_j)$</p><p>其中 $mid = \frac{i+j}{2}$ 对两个子问题分别求解，然后对两个子问题的解计算最长公共前缀，即原问题的解。</p><p><img src="https://i.loli.net/2021/09/26/QpVbrwdZINPjcty.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs==<span class="keyword">null</span> || strs.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longestCommonPrefix(strs, <span class="number">0</span>, strs.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == end)&#123;</span><br><span class="line">            <span class="keyword">return</span> strs[start];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (end - start) / <span class="number">2</span> + start;</span><br><span class="line">        String lcpLeft = longestCommonPrefix(strs, start, mid);</span><br><span class="line">        String lcpRight = longestCommonPrefix(strs, mid+<span class="number">1</span>, end);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> minLength = Math.min(lcpLeft.length(), lcpRight.length());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;minLength;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(lcpLeft.charAt(i) != lcpRight.charAt(i))&#123;</span><br><span class="line">                <span class="keyword">return</span> lcpLeft.substring(<span class="number">0</span>,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lcpLeft.substring(<span class="number">0</span>,minLength);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：</p><ul><li><p>时间复杂度：$O(mn)$ 其中m 是字符串数组中的字符串的平均长度，n是字符串的数量。</p><p>时间复杂度的递推式是 $T(n) = 2\cdot T(n/2) + O(m)$， 通过计算可得 $T(n) = O(mn)$</p></li><li><p>空间复杂度 $O(mlogn)$ ，n为字符串数量。空间复杂度取决于递归调用的层数，层数最大为 logn，每层需要 m 的空间存储返回结果。</p></li></ul><h2 id="方法四：二分查找"><a href="#方法四：二分查找" class="headerlink" title="方法四：二分查找"></a>方法四：二分查找</h2><p>虽然，最长公共前缀的长度不会超过字符串数组中的最短字符串的长度。</p><p>用 minLength 表示字符串数组中的最短字符串长度，则可以再 $[0,minLength]$ 的范围内通过二分查找找到最长公共前缀的长度。每次取查找范围的中间值mid， 判断每个字符串的长度为mid 的前缀是否相同，如果相同则最长公共前缀的长度一定大于或等于 mid， 如果不相同则最长公共前缀的长度一定小于mid， 通过上述方式将查找范围缩小一半，直到得到最长公共前缀的长度。</p><p><img src="https://i.loli.net/2021/09/26/32HvnS78gisxEcI.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs==<span class="keyword">null</span> || strs.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> minLength = Integer.MAX_VALUE</span><br><span class="line">        <span class="keyword">for</span>(String str:strs)&#123;</span><br><span class="line">            minLength = Math.min(minLength, str.length());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high=minLength;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (high - low + <span class="number">1</span>) /<span class="number">2</span> + low;</span><br><span class="line">            <span class="keyword">if</span>(isCommonPrefix(strs, mid))&#123;</span><br><span class="line">                low = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>,low);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCommonPrefix</span><span class="params">(String[] strs, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        String str0 = strs[<span class="number">0</span>].substring(<span class="number">0</span>, length);</span><br><span class="line">        <span class="keyword">int</span> count = strs.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;count;i++)&#123;</span><br><span class="line">            String str = strs[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(str0.charAt(j) != str.charAt(j))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;14-最长公共前缀-二分、分治&quot;&gt;&lt;a href=&quot;#14-最长公共前缀-二分、分治&quot; class=&quot;headerlink&quot; title=&quot;14-最长公共前缀(二分、分治)&quot;&gt;&lt;/a&gt;14-最长公共前缀(二分、分治)&lt;/h1&gt;&lt;h4 id=&quot;14-最长公共前缀&quot;&gt;</summary>
      
    
    
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>凸优化一</title>
    <link href="http://example.com/2021/09/24/%E5%87%B8%E4%BC%98%E5%8C%96%E4%B8%80/"/>
    <id>http://example.com/2021/09/24/%E5%87%B8%E4%BC%98%E5%8C%96%E4%B8%80/</id>
    <published>2021-09-24T11:32:10.000Z</published>
    <updated>2021-09-24T11:37:24.763Z</updated>
    
    <content type="html"><![CDATA[<h1 id="凸优化一"><a href="#凸优化一" class="headerlink" title="凸优化一"></a>凸优化一</h1><p>从一个可行解的集合中，寻找出最优的元素</p><p>任何一个优化问题都可以写成这个形式：</p><script type="math/tex; mode=display">minimize</script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;凸优化一&quot;&gt;&lt;a href=&quot;#凸优化一&quot; class=&quot;headerlink&quot; title=&quot;凸优化一&quot;&gt;&lt;/a&gt;凸优化一&lt;/h1&gt;&lt;p&gt;从一个可行解的集合中，寻找出最优的元素&lt;/p&gt;
&lt;p&gt;任何一个优化问题都可以写成这个形式：&lt;/p&gt;
&lt;script type</summary>
      
    
    
    
    
    <category term="Convex optimization" scheme="http://example.com/tags/Convex-optimization/"/>
    
  </entry>
  
  <entry>
    <title>Gradient Episodic Memory for Continual Learning</title>
    <link href="http://example.com/2021/09/24/Gradient-Episodic-Memory-for-Continual-Learning/"/>
    <id>http://example.com/2021/09/24/Gradient-Episodic-Memory-for-Continual-Learning/</id>
    <published>2021-09-24T06:59:03.000Z</published>
    <updated>2021-09-24T13:09:46.644Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Gradient-Episodic-Memory-for-Continual-Learning"><a href="#Gradient-Episodic-Memory-for-Continual-Learning" class="headerlink" title="Gradient Episodic Memory for Continual Learning"></a>Gradient Episodic Memory for Continual Learning</h1><p>人工智能的一个主要障碍是模型在不忘记先前获得的知识的情况下，更快地解决新问题的能力很差。</p><p>首先，提出了一套度量标准来评估在数据连续体上学习的模型。这些度量不仅通过它们的测试准确性来表征模型，而且还根据它们在任务之间传输知识的能力来表征模型。</p><p>其次，提出了一个持续学习的模型，称为梯度情节记忆(GEM)，它可以减轻遗忘，同时允许知识有益地转移到以前的任务中。</p><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>有监督学习的设置 $D<em>{tr} = {(x_i,y_i)}</em>{i=1}^n$ , 其中每个示例 $(x_i，y_i)$ 由特征向量 $x_i\in X$ 和目标向量 $y_i\in Y$组成。</p><p>大多数监督学习方法假设每个示例 $(x_i，y_i)$ 是来自描述单个学习任务的固定概率分布 $P$ 的独立同分布(IID)样本。目标是构造一个模型 $f:X \rightarrow Y$ ，用于预测目标向量 $y$ 与未见的特征向量 $x$ ,其中$(x,y) \sim P$</p><p>为了实现这一点，监督学习方法通常采用 经验风险最小化 (ERM) 原则 [Vapnik, 1998]，其中 f 是通过最小化这个式子：</p><script type="math/tex; mode=display">\frac{1}{|D_u|} \sum_{x_i,y_i \in D_u} l(f(x_i), y_i)</script><p>在实践中，ERM通常需要多次遍历训练集。<a href="https://zhuanlan.zhihu.com/p/103786559">经验风险最小化(Empirical Risk Minimization)</a></p><p>将逐个样本地观察数据的连续体：</p><script type="math/tex; mode=display">(x_1,t_1,y_1), ...,(x_i,t_i,y_i),...,(x_n,t_n,y_n)</script><p>$t<em>i \in T$ 该任务描述符标识与 $(x_i，y_i)\sim P</em>{t_i}$ 相关联的任务。</p><p>重要的是，样本不是从三元组 $(x，t，y)$上的固定概率分布中提取的，因为在切换到下一任务之前可以观察到来自当前任务的整个示例序列。</p><p>连续学习的目标是构造一个能够预测与测试对 $(x，t)$ 相关的目标 $y$ 的模型 $f: X\times T$，其中 $(x,y)\sim P_t$。</p><p>在这种情况下，ERM面临着未知的挑战：</p><ul><li>Non-iid input data : 数据连续体相对于任何固定概率分布 $P(X,T,Y)$ 不是独立同分布的，因为一旦任务切换，就可以观察到来自新任务的整个样本序列。</li><li>Catastrophic forgetting : 学习新任务可能会损害学习者在以前解决的任务中的表现。 </li><li>Transfer learning :  当连续体中的任务相关时，就存在迁移学习的机会。这将转化为更快地学习新任务，以及提高旧任务的性能。</li></ul><h2 id="A-Framework-for-Continual-Learning"><a href="#A-Framework-for-Continual-Learning" class="headerlink" title="A Framework for Continual Learning"></a>A Framework for Continual Learning</h2><p>连续体的数据三元组 $(x<em>i,t_i,y_i)$ 由特征向量 $x_i\in X</em>{t<em>i}$ , 任务描述符 $t_i\in T$ , 目标向量 $y_i\in Y</em>{t_i}$</p><p>为简单起见，我们假设连续体是局部 iid，即每个三元组 $(x<em>i，t_i，y_i)$ 都满足 $(x_i,y_i) \sim^{iid} P</em>{t_i}(X,Y)$</p><p>目标是学习一个预测器 $f:X\times T \to Y$，它可以在任何时候被查询以预测与测试对 $(x，t)$ 相关联的目标向量 $y$，其中$(x,y)\sim P_t$。这样的测试对可以属于我们在过去观察到的任务，可以属于当前的任务，也可以属于我们将在未来体验的任务。</p><h3 id="Task-descriptors"><a href="#Task-descriptors" class="headerlink" title="Task descriptors"></a>Task descriptors</h3><p>框架中的一个重要组成部分是任务描述符  $t_1, . . . , t_n \in T$ 。在最简单的情况下，任务描述符是整数 $t_i = i \in Z$，枚举出现在数据连续集中的不同任务。更一般地说，任务描述符 $t_i$ 可以是结构化对象，例如一段自然语言，解释如何解决第 $i$ 个任务。丰富的任务描述符为  zero-shot learning 提供了机会，因为可以单独使用新的任务描述符来推断任务之间的关系。此外，任务描述符消除了类似学习任务的歧义。特别是，相同的输入 $x_i$ 可能出现在两个不同的任务中，但需要不同的目标。任务描述符可以引用多个学习环境的存在，或提供有关每个示例的附加（可能是分层的）上下文信息。然而，在本文中，作者专注于减轻从连续数据中学习时的灾难性遗忘，并将 zero-shot learning  留给未来的研究。</p><h3 id="Training-Protocol-and-Evaluation-Metrics"><a href="#Training-Protocol-and-Evaluation-Metrics" class="headerlink" title="Training Protocol and Evaluation Metrics"></a>Training Protocol and Evaluation Metrics</h3><p>大多数关于学习一系列任务的文献描述了一种设置</p><ul><li>i) 任务数量 很小</li><li>ii) 每个任务的示例数量很大</li><li>iii) 学习者对每个任务的样本执行多次传递</li><li>iv) 报告的唯一指标是所有任务的平均性能。 </li></ul><p>相比之下，本文:</p><ul><li>i) 任务数量很大，</li><li>ii) 每个任务的训练样本数量很少</li><li>iii) 学习者只观察与每个任务相关的样本一次</li><li>iv) 报告了衡量转移和遗忘的指标。</li></ul><p>除了监控其跨任务的表现外，评估模型传递知识的能力也很重要。更具体地说：</p><ul><li>Backward transfer (BWT) ：学习任务 t 对前一任务 k ≺ t 的性能的影响。当学习任务 t 时，提高了先前任务 k 的性能(存在正面的反向迁移)。当学习任务 t 会降低先前任务 k 的性能时(存在负面的反向迁移)。 越大意味着灾难性遗忘越严重。<script type="math/tex; mode=display">\frac{1}{T} \sum_{i=1}^T R_{T,i}\frac{1}{T-1} \sum_{i=1}^{T-1} R_{T,i} - R_{i,i}</script></li></ul><ul><li>Forwardtransfer(FWT) ：学习任务t 对未来任务 k&gt;t 的性能的影响。 $\hat b$是每个任务在随机初始化时的测试精度向量。<script type="math/tex; mode=display">\frac{1}{T-1} \sum_{i=2}^{T-1} R_{i-1,i} - \hat b_i</script></li></ul><ul><li>Retained Accuracy(RA) 是模型在训练结束时跨任务的平均准确率。<script type="math/tex; mode=display"> \frac{1}{T} \sum_{i=1}^T R_{T,i}</script></li></ul><p>讨论第一个任务的向后转移或最后一个任务的正向转移是没有意义的。</p><p>考虑为每一个 $T$ 任务访问测试集。在模型学习完任务 $t<em>i$之后，我们评估了它在所有 $T$ 个任务上的测试性能。通过这样做，我们构造了矩阵 $R \in R^{T\times T}$，其中 $R</em>{i,j}$ 是在观察到来自任务 $t_i$ 的最后一个样本之后，模型对任务 $t_j$ 的测试分类精度。</p><h3 id="Gradient-of-Episodic-Memory-GEM"><a href="#Gradient-of-Episodic-Memory-GEM" class="headerlink" title="Gradient of Episodic Memory (GEM)"></a>Gradient of Episodic Memory (GEM)</h3><p>梯度情景记忆（GEM），一种持续学习的模型。 GEM 的主要特征是情景记忆 $M_t$，它存储来自任务 t 的观察示例的子集。 为简单起见，我们假设整数任务描述符，并使用它们来索引情节记忆。 当使用整数任务描述符时，不能期望显着的正向转移（zero-shot learning）。 相反，我们专注于通过有效使用情景记忆来最小化负向后迁移（灾难性遗忘）。</p><p>实际上，学习者总共有 $M$ 个存储单元的预算。如果总任务数 $T$ 已知，我们可以为每个任务分配 $m=M/T$个存储器。如果总任务数 $T$ 未知，我们可以在观察新任务时逐渐减小 $m$ 值</p><p>为简单起见，假设内存中填充了来自每个任务的最后 $m$ 个示例，尽管可以采用更好的内存更新策略(例如为每个任务构建核心重置)。在下文中，我们考虑由 $\theta \in R^P$参数化的预测因子 $f_\theta$，并将第k个任务的记忆损失定义为:</p><script type="math/tex; mode=display">l(f_{\theta} ,M_k) = \frac{1}{|M_k|} \sum_{(x_i,k,y_i)\in M_k} l(f_{\theta}(x_i,k),y_i)</script><p>显然，将当前示例中的损失与上式一起最小化会导致过度拟合存储在 $M_k$中的示例。作为另一种选择，我们可以通过蒸馏的方法来保持过去任务的预测不变 —— iCaRL: Incremental classifier and representation</p><p>然而，这将认为正向后向转移是不可能的。 相反，我们将使用 上面的损失 作为不等式约束，避免它们的增加但允许它们的减少。 与最先进的 [Kirkpatrick et al., 2017, Rebuffi et al., 2017] 相比，我们的模型允许正向后向转移。</p><p>更具体地说，在观察三元组 $(x,t,y)$时，我们解决了以下问题：</p><script type="math/tex; mode=display">minimize_{\theta}  \ \ \ l(f_{\theta}(x,t) ,y)</script><script type="math/tex; mode=display">\text{subject to (受制于)}  \ \ \ l(f_{\theta}, M_k) \le l(f_{\theta}^{t-1},M_k) \ \  for \ all \ k\lt t</script><p>其中 $f_{\theta}^{t-1}$ 是任务 t−1学习结束时的预测器状态。</p><p>首先，在每次参数更新g之后，只要我们保证以前任务的损失不增加，就没有必要存储旧的预测值 $f_{\theta}^{t-1}$。</p><p>其次，假设函数是局部线性的（因为它发生在小优化步骤周围）并且memory代表过去任务的样本，我们可以通过计算它们的损失梯度向量之间的角度来 ，判断先前任务损失的增加 和建议的更新。在数学上，我们将上面式子的约束重新表述为：</p><script type="math/tex; mode=display"><g, g_k> := <\frac{\partial l(f_{\theta}(x,t),y)}{\partial \theta} , \frac{\partial l(f_{\theta},M_k)}{ \partial\theta}> \ge 0 , \ for \ all \ k <t</script><p>如果满足上面的不等式，则参数更新 $g$ 不太可能增加先前任务的损失。</p><p>另一方面，如果违反了一个或多个不等式约束，那么至少有一个先前的任务在参数更新后损失会增加。 如果违反不等式，我们建议将梯度 g 投影到满足所有上式约束 的最近梯度  $\hat g$（以平方 $l2$ 范数表示）。 因此：</p><script type="math/tex; mode=display">minimize_{\hat g}  \ \ \ \frac{1}{2} ||g-\hat g||^2_2</script><script type="math/tex; mode=display">\text{subject to (受制于)}  \ \ \ <\hat g,g_k> \ge 0 \ for \ all \ k <t</script><p>为了有效地解决上式，回想一下具有不等式约束的二次规划Quadratic Program （QP）的原始值：</p><p><a href="https://zhuanlan.zhihu.com/p/36081404">凸优化笔记(3)Quadratic Programming简介</a></p><script type="math/tex; mode=display">minimize_{z} \ \ \frac{1}{2} z^TCz + p^Tz</script><script type="math/tex; mode=display">\text{subject to (受制于)}  \ \ \ Az\ge b</script><p>其中$C\in R^{p\times p}, p\in R^p,A\in R^{(t-1)\times p} ,b\in R^{t-1}$ , 上式的对偶问题是：</p><script type="math/tex; mode=display">minimize_{u,v} \ \ \frac{1}{2} u^TCu -b^Tv</script><script type="math/tex; mode=display">\text{subject to (受制于)}  \ \ \ A^Tv -Cu=p \ ,\ v\ge 0</script><p> 如果 $(u^⋆,v^⋆)$是上个式子的解，则存在解 $z^⋆$ 满足 $Cz^⋆=Cu^⋆$</p><p>有了这些符号，我们将原始GEM QP 写成：</p><script type="math/tex; mode=display">minimize_{z} \ \ \frac{1}{2} z^Tz -g^Tz + \frac{1}{2}g^Tg</script><script type="math/tex; mode=display">\text{subject to (受制于)}  \ \ \ Gz \ge 0</script><p>其中 $G = -(g<em>1,…,g</em>{t-1})$ 并且去掉常数项 $g^Tg$ 。这是 p 个变量（神经网络的参数数量）上的 QP，可以以数百万计。 但是，我们可以将 GEM QP 的对偶假设为：</p><script type="math/tex; mode=display">minimize_{v} \ \ \frac{1}{2} v^TGG^Tv + g^TG^Tv</script><script type="math/tex; mode=display">\text{subject to (受制于)}  \ \ \ v \ge 0</script><p>由于 $u  = G^Tv + g$ 并且 $g^T g$ 是常数，这是在 $t − 1 ≪ p$ 个变量上的 QP，即目前观察到的任务数量。一旦我们解决了 $v^<em>$ 的对偶问题(上式) ，我们就可以将投影梯度更新恢复为 $\hat g = G^Tv^</em> + g$。 在实践中，我们发现添加一个小的常数 $\gamma \ge 0 $ 到 $v^⋆$ 会使梯度投影偏向于有利于有益向后转移的更新。</p><p><img src="https://i.loli.net/2021/09/24/bDAQzaEYd6gPOIy.png" alt=""></p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p><img src="https://i.loli.net/2021/09/24/gDpRaMANdbhT9kc.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Gradient-Episodic-Memory-for-Continual-Learning&quot;&gt;&lt;a href=&quot;#Gradient-Episodic-Memory-for-Continual-Learning&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    
    <category term="context detection" scheme="http://example.com/tags/context-detection/"/>
    
  </entry>
  
  <entry>
    <title>12,13-整数互换罗马数字</title>
    <link href="http://example.com/2021/09/24/12-13-%E6%95%B4%E6%95%B0%E4%BA%92%E6%8D%A2%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/"/>
    <id>http://example.com/2021/09/24/12-13-%E6%95%B4%E6%95%B0%E4%BA%92%E6%8D%A2%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</id>
    <published>2021-09-24T04:34:19.000Z</published>
    <updated>2021-09-24T05:13:58.677Z</updated>
    
    <content type="html"><![CDATA[<h1 id="12-13-整数互换罗马数字"><a href="#12-13-整数互换罗马数字" class="headerlink" title="12,13-整数互换罗马数字"></a>12,13-整数互换罗马数字</h1><h4 id="12-整数转罗马数字"><a href="#12-整数转罗马数字" class="headerlink" title="12. 整数转罗马数字"></a><a href="https://leetcode-cn.com/problems/integer-to-roman/">12. 整数转罗马数字</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] values=&#123;<span class="number">1000</span>,<span class="number">900</span>,<span class="number">500</span>,<span class="number">400</span>,<span class="number">100</span>,<span class="number">90</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        String[] rom=&#123;<span class="string">&quot;M&quot;</span>,<span class="string">&quot;CM&quot;</span>,<span class="string">&quot;D&quot;</span>,<span class="string">&quot;CD&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;XC&quot;</span>,<span class="string">&quot;L&quot;</span>,<span class="string">&quot;XL&quot;</span>,<span class="string">&quot;X&quot;</span>,<span class="string">&quot;IX&quot;</span>,<span class="string">&quot;V&quot;</span>,<span class="string">&quot;IV&quot;</span>,<span class="string">&quot;I&quot;</span>&#125;;</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;values.length;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(num&gt;=values[i])&#123;</span><br><span class="line">                sb.append(rom[i]);</span><br><span class="line">                num-=values[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13. 罗马数字转整数"></a><a href="https://leetcode-cn.com/problems/roman-to-integer/">13. 罗马数字转整数</a></h4><p>通常情况下，罗马数字中小的数字在大的数字的右边。若输入的字符串满足该情况，那么可以将每个字符视作一个单独的值，累加每个字符对应的数值即可。</p><p>例如 $\texttt{XXVII}$ 可视作 X+X+V+I+I=10+10+5+1+1=27。</p><p>若存在小的数字在大的数字的左边的情况，根据规则需要减去小的数字。对于这种情况，我们也可以将每个字符视作一个单独的值，若一个数字右侧的数字比它大，则将该数字的符号取反。</p><p>例如 XIV 可视作 X−I+V=10−1+5=14。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Character, Integer&gt; symbolValues = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;() &#123;&#123;</span><br><span class="line">        put(<span class="string">&#x27;I&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">        put(<span class="string">&#x27;V&#x27;</span>, <span class="number">5</span>);</span><br><span class="line">        put(<span class="string">&#x27;X&#x27;</span>, <span class="number">10</span>);</span><br><span class="line">        put(<span class="string">&#x27;L&#x27;</span>, <span class="number">50</span>);</span><br><span class="line">        put(<span class="string">&#x27;C&#x27;</span>, <span class="number">100</span>);</span><br><span class="line">        put(<span class="string">&#x27;D&#x27;</span>, <span class="number">500</span>);</span><br><span class="line">        put(<span class="string">&#x27;M&#x27;</span>, <span class="number">1000</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> value = symbolValues.get(s.charAt(i));</span><br><span class="line">            <span class="keyword">if</span> (i &lt; n - <span class="number">1</span> &amp;&amp; value &lt; symbolValues.get(s.charAt(i + <span class="number">1</span>))) &#123;</span><br><span class="line">                ans -= value;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;12-13-整数互换罗马数字&quot;&gt;&lt;a href=&quot;#12-13-整数互换罗马数字&quot; class=&quot;headerlink&quot; title=&quot;12,13-整数互换罗马数字&quot;&gt;&lt;/a&gt;12,13-整数互换罗马数字&lt;/h1&gt;&lt;h4 id=&quot;12-整数转罗马数字&quot;&gt;&lt;a hr</summary>
      
    
    
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>10-正则表达式</title>
    <link href="http://example.com/2021/09/23/10-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://example.com/2021/09/23/10-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2021-09-23T01:15:02.000Z</published>
    <updated>2021-09-23T03:12:03.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="10-正则表达式"><a href="#10-正则表达式" class="headerlink" title="10-正则表达式"></a>10-正则表达式</h1><h4 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10. 正则表达式匹配"></a><a href="https://leetcode-cn.com/problems/regular-expression-matching/">10. 正则表达式匹配</a></h4><h2 id="定义状态"><a href="#定义状态" class="headerlink" title="定义状态"></a>定义状态</h2><ul><li>定义动态数组$dp[m][n]$ （n为字符串p的长度+1，m为字符串s的长度+1）</li><li><ul><li>为什么要加1</li><li>因为我们还要处理空字符串的情况，比如p为空，s为空，或者p为空，s不为空</li></ul></li><li>$dp[m][n]$ 的含义：p的前$n-1$ 个字符能否匹配s的前$m-1$个字符</li><li><ul><li>为什么是n-1和m-1?</li><li>因为动态数组里面加了一列和一行空字符的匹配情况，故需要-1才能对应相应字符串</li></ul></li></ul><p>因此创建好的dp数组如下图：</p><p><img src="https://i.loli.net/2021/09/23/UDWLfZIH8nmwYCX.jpg" alt=""></p><h2 id="确定动态转移方程"><a href="#确定动态转移方程" class="headerlink" title="确定动态转移方程"></a>确定动态转移方程</h2><p>说明：为了区别dp数组与字符串索引的区别(因为相差1)，我们设 $i=r-1,j=c-1$ （r为dp里面的行索引，c为dp里面的列索引）</p><p>有以下几种情况是需要我们处理的：</p><ul><li>当 $s[i]=p[j] \ || \  p[j]==’.’$ （即正好能够匹配或者相对应的是一个 $.$）</li></ul><p>那么我们只需要看一下前面 $dp[r-1][c-1]$的状态，$dp[r][c]$继续延续即可</p><p>即状态转移方程为 $dp[r][c]=dp[r-1][c-1]$</p><p><img src="https://i.loli.net/2021/09/23/wzgDScn6VBvR93J.jpg" alt=""></p><ul><li><p>当 $p[j] ==’<em>‘$ （即匹配到了万能字符 $</em>$）</p><p>两种情况分别对应的处理方式为：</p><p>如果 $*$ 的前一个字符正好对应了$s$，状态转移过程为：$dp[r][c] = dp[r-1][c]$</p><p>如果是$*$的前一个字符为 $.$ 那么只需看$.$的前面字符匹配情况，状态转移过程为: $dp[r][c]=dp[r][c-2]$</p></li></ul><p>  边界：</p><ul><li><p>首先我们要确定 $dp[0][0]$，当p为空，s为空时，肯定匹配成功。那么$dp[0][0]=true$</p></li><li><p>当 p 为空字符串，而s不为空时，dp数组必定为False，正好初始化dp数组的时候设置的是False；即dp数组的第一列为False可以确定</p></li><li><p>当s为空字符串，而p不为空时，我们无需判断p里面的第一个值是否为””，如果为””,那肯定匹配不到为Fasle,原数组正好是Fasle，所以直接从2开始判断即可。如果遇到了*,只要判断其对应的前面两个元素的dp值</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> m = p.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp=<span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        s = <span class="string">&#x27; &#x27;</span>+s;</span><br><span class="line">        p = <span class="string">&#x27; &#x27;</span>+p;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span> &amp;&amp; j==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(p.charAt(j) != <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(p.charAt(j)==<span class="string">&#x27;.&#x27;</span> || s.charAt(i)==p.charAt(j))&#123;</span><br><span class="line">                        <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                            dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j&gt;=<span class="number">2</span>) dp[i][j] = dp[i][j-<span class="number">2</span>];</span><br><span class="line">                    <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>) == <span class="string">&#x27;.&#x27;</span> || s.charAt(i)==p.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                            <span class="keyword">if</span>(dp[i-<span class="number">1</span>][j]) dp[i][j]=<span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;10-正则表达式&quot;&gt;&lt;a href=&quot;#10-正则表达式&quot; class=&quot;headerlink&quot; title=&quot;10-正则表达式&quot;&gt;&lt;/a&gt;10-正则表达式&lt;/h1&gt;&lt;h4 id=&quot;10-正则表达式匹配&quot;&gt;&lt;a href=&quot;#10-正则表达式匹配&quot; class=&quot;</summary>
      
    
    
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Learning to learn without forgetting by maximizing transfer and minimizing interference</title>
    <link href="http://example.com/2021/09/22/LEARNING-TO-LEARN-WITHOUT-FORGETTING-BY-MAXIMIZING-TRANSFER-AND-MINIMIZING-INTERFERENCE/"/>
    <id>http://example.com/2021/09/22/LEARNING-TO-LEARN-WITHOUT-FORGETTING-BY-MAXIMIZING-TRANSFER-AND-MINIMIZING-INTERFERENCE/</id>
    <published>2021-09-22T10:58:55.394Z</published>
    <updated>2021-09-28T06:42:55.377Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Learning-to-learn-without-forgetting-by-maximizing-transfer-and-minimizing-interference"><a href="#Learning-to-learn-without-forgetting-by-maximizing-transfer-and-minimizing-interference" class="headerlink" title="Learning to learn without forgetting by maximizing transfer and minimizing interference"></a>Learning to learn without forgetting by maximizing transfer and minimizing interference</h1><p>在对非平稳数据分布进行持续学习方面，仍然是将神经网络扩展到人类现实环境的主要挑战。</p><p>在这项工作中，我们提出了一种关于连续学习的新概念，即迁移和干扰之间的对称权衡，可以通过实施跨样本的梯度对齐来优化该权重。</p><p>Meta-Experience Replay (MER) 通过将经验回放与基于优化的元学习相结合。</p><p>该方法学习使基于未来梯度的干扰可能性较小，而基于未来梯度的迁移可能性更大的参数。</p><p>作者在连续终身监督学习基准和非静态强化学习环境中进行了实验，实验表明，MER算法和基线算法之间的性能差距随着环境变得更加不平稳和存储的经验在总经验中所占的比例变小而增大。</p><h2 id="Continual-learning-problem"><a href="#Continual-learning-problem" class="headerlink" title="Continual learning problem"></a>Continual learning problem</h2><p>人工智能的一个长期目标是建立能够长期自主操作的代理。这样的代理必须渐进地学习并适应不断变化的环境，同时保持对以前所学知识的记忆，这种设置称为终身学习。本文是持续学习的一个变体。</p><p>在持续学习中，假设学习者接触到一系列任务，其中每个任务都是来自相同分布的一系列经验。</p><p>作者希望在这种情况下开发一种解决方案，在无监督的情况下发现任务的概念，同时在每次体验后逐步学习。</p><p>这很有挑战性，因为在标准的离线单任务和多任务学习中，隐含地假设数据是独立同分布的平稳分布。不幸的是，每当情况不是这样的时候，神经网络往往都会举步维艰。</p><p>持续学习面临的最大问题是灾难性的遗忘(干扰)，其中最主要的担忧是神经网络缺乏稳定性，而主要的解决方案是通过专注于保留过去的知识来限制经验之间的权重共享程度。</p><p>另一个问题是稳定性-可塑性两难问题，在这种观点下，首要关注的是：网络稳定性(保存过去的知识)和可塑性(快速学习当前经验)之间的平衡。</p><p>以前的持续学习技术侧重于平衡有限的权重共享和某种机制以确保快速学。在本文中，作者扩展了这一观点，指出——对于在无限数量的分布上的连续学习，需要及时考虑前向和后向的权重共享和稳定性-塑性权衡，如下图：</p><p><img src="https://i.loli.net/2021/09/22/iCN3JmMckXxLfHy.png" alt=""></p><p>稳定性-可塑性困境考虑了当前学习的可塑性以及它如何降低旧学习。 迁移-干扰权衡考虑了稳定性-可塑性困境及其对前向和后向权重共享的依赖。这种对称的观点是至关重要的，因为单纯专注于降低权重共享程度的解决方案不太可能在未来产生迁移。</p><p>本文提出的迁移-干扰权衡为持续学习问题的梯度对齐目标提供了一个新的视角。这是问题的核心，因为这些梯度是学习期间基于 SGD 的优化器的更新步骤，并且梯度的角度和管理权重共享的程度之间存在明显的联系。</p><p>与过去对持续学习的概念观点的关键区别在于，我们不仅关注相对于过去例子的当前迁移和干扰，而且还关注随着我们学习而向前发展的迁移和干扰的动态。</p><p>然而，在过去的工作中，基于当前的学习和过去的学习，对权重共享的动态进行了临时更改，而没有制定关于最佳权重共享动态的一致理论。就我们对未来的元学习进行推广而言，这应该使模型更容易在非平稳环境中执行持续学习。</p><p>作者通过在过去关于经验回放的工作的基础上实现这一点，经验重播一直是用神经网络解决非平稳问题的中流砥柱。</p><p>作者提出了一种新的meta-experience replay(MER)算法，它结合了经验回放和基于优化的元学习。MER在各种有监督的持续学习和持续强化学习环境中显示出巨大的潜力。</p><h2 id="The-transfer-interference-trade-off-for-continual-learning"><a href="#The-transfer-interference-trade-off-for-continual-learning" class="headerlink" title="The transfer-interference trade-off for continual learning"></a>The transfer-interference trade-off for continual learning</h2><p>在参数 $\theta$ 和损失 $L$ 的瞬间，我们可以在使用 SGD 训练时定义两个任意不同样本 $(x_i,y_i)$ 和 $(x_j,y_j)$ 之间的迁移和干扰的操作度量。 迁移发生在：</p><script type="math/tex; mode=display">\frac{\partial L(x_i,y_i)}{\partial \theta} \cdot \frac{\partial(x_j,y_j)}{\partial\theta} \gt 0</script><p>这意味着学习样本 $ i$ 将在不重复的情况下提高示例 $j$ 的表现，反之亦然。干扰发生在：</p><script type="math/tex; mode=display">\frac{\partial L(x_i,y_i)}{\partial \theta} \cdot \frac{\partial(x_j,y_j)}{\partial\theta} \lt 0</script><p>当 $i$ 和 $j$ 使用一组重叠参数进行学习时，它们之间存在权重共享。因此，当权重共享最大化时，迁移潜力最大化，而当权重共享最小化时，干扰潜力最小化。</p><p>持续学习中稳定性-可塑性困境的过去解决方案在简化的时间环境中运行，其中学习分为两个阶段：</p><ul><li>所有过去的经历都被归结为<strong>旧记忆</strong></li><li>而目前正在学习的数据则是<strong>新学习</strong></li></ul><p>在此设置中，目标是简单地最小化时间上向后投影的干扰，这通常是通过显式或隐式地降低权重共享的程度来实现的。</p><p>然而，这种观点的重要问题是，这个系统仍然需要学习，未来会带来什么在很大程度上是未知的。这使得我们有责任不采取任何措施来潜在地破坏网络在不确定的未来有效学习的能力。这种考虑使我们将稳定性-可塑性问题的时间范围向前扩展，更一般地说，将其转变为一个持续学习问题，我们将其标记为解决迁移-干扰权衡问题。如上图A。</p><p>具体来说，重要的是不仅要减少来自我们当前时间点的反向干扰，而且我们必须以不限制我们未来学习能力的方式这样做。这种更普遍的观点承认问题中的一个微妙之处：梯度对齐的问题以及因此跨样本的权重共享在时间上向后和向前出现。</p><p>在这里，作者提出了一个潜在的解决方案，我们学习以一种在每个时间点促进梯度对齐的方式进行学习。 跨样本的权重共享可以通过迁移来提高对未来的性能，但不破坏之前的性能。 因此，我们的工作对持续学习问题采用了元学习的观点。 希望学习以一种从整体分布中推广到其他样本的方式来学习每个样本。</p><h2 id="A-system-for-learning-to-learn-without-forgetting"><a href="#A-system-for-learning-to-learn-without-forgetting" class="headerlink" title="A system for learning to learn without forgetting"></a>A system for learning to learn without forgetting</h2><p>在典型的离线监督学习中，我们可以在数据集 $D$ 内$x, y$ 的平稳分布上表达我们的优化目标：</p><script type="math/tex; mode=display">\theta = \text{argmin}_{\theta} E_{(x,y)\sim D}[L(x,y)]</script><p>如果我们想要最大限度地迁移和最小化干扰，我们可以想象在目标上增加辅助损失以使学习过程偏向那个方向是有用的。</p><p>考虑公式1和2，一个明显有益的选择将是还直接考虑相对于在随机选择的数据点评估的损失函数的梯度。</p><p>如果我们可以最大化这些不同点的梯度之间的点积，它将直接鼓励网络在梯度方向对齐的地方共享参数，并在相反方向的梯度引起干扰的地方保持参数分开。</p><p>因此，理想情况下，针对以下目标进行优化:</p><script type="math/tex; mode=display">\theta  = argmin_{\theta} E_{[(x_i,y_i),(x_j,y_j)] \sim D} [L(x_i,y_i)+L(x_j,y_j)] - \alpha\frac{\partial L(x_i,y_i)}{\partial \theta}\cdot \frac{\partial L(x_j,y_j)}{\partial \theta}</script><p>其中 $(x_i，y_i)$和 $(x_j，y_j)$是随机抽样的唯一数据点。我们将尝试设计一个针对这一目标进行优化的持续学习系统。然而，要在实践中实施这种学习过程，还必须解决多方面的问题。</p><p>第一个问题是，持续学习处理的是对非平稳数据流的学习。我们通过实现一个经验回放模块来解决这个问题，该模块增强了在线学习，这样我们就可以对到目前为止看到的所有样本的固定分布进行近似优化。</p><p>另一个实际问题是，这种损失的梯度取决于损失函数的二阶导数，这一点计算效率不高。通过使用具有最小计算开销的元学习算法间接地将目标近似为一阶Tayor展开来解决这一问题。</p><h3 id="Experience-replay"><a href="#Experience-replay" class="headerlink" title="Experience replay"></a>Experience replay</h3><p><strong>Learning objective:</strong> 持续的终身学习环境对神经网络的优化提出了挑战，非平稳流中的样本层出不穷。反而，我们希望我们的网络在目前为止看到的所有样本平稳分布上进行优化。经验回放 (1992) 是一种古老的技术，它仍然是尝试在非平稳环境中学习的深度学习系统的核心组成部分，我们将在这里采用最近工作中的约定 (A deeper look at experience replay2017) ; Scalable recollections for continual lifelong learning2017) 利用这种方法。</p><p>经验回放的中心特征是保持对所见样本的记忆 $M$，该记忆与当前样本的训练交织在一起，目的是使训练更稳定。因此，经验回放在 $M$ 逼近 $D$ 的程度上逼近等式 3 中的目标：</p><script type="math/tex; mode=display">\theta = argmin_{\theta} E_{(x,y)\sim M} [L(x,y)]</script><p>$M$ 具有当前大小 $M<em>{size}$和最大大小$M</em>{max}$。 使用reservoir sampling来更新缓冲区。这确保在每个时间步，看到的 N 个示例中的任何一个在缓冲区中的概率都等于 $M_{size}/N$。</p><p>缓冲区的内容类似于所有样本的平稳分布，以至于存储的项目捕获了过去样本的变化。 遵循离线学习的标准做法，我们通过从 M 捕获的分布中随机抽样一批 B 来进行训练。</p><p><strong>Prioritizing the current example:</strong> 我们探索的经验回放变体与离线学习的不同之处在于，当前样本具有特殊作用，可确保它始终与从回放缓冲区采样的样本交错。这是因为在我们继续下一个样本之前，我们希望确保我们的算法能够针对当前样本进行优化(特别是如果它没有添加到记忆中)。在看到的N个样本上，这仍然意味着我们已经将每个样本作为当前样本进行了训练，每步的概率为1/N。我们提供了进一步详细说明在这项工作中如何使用经验回放的算法在附录G中。</p><p><img src="https://i.loli.net/2021/09/23/d5yaHjVocX6Qki1.png" alt=""></p><p><img src="https://i.loli.net/2021/09/23/RnH3td1zVFSY4yW.png" alt=""></p><p><img src="https://i.loli.net/2021/09/23/8UvcJVqlsBICPD3.png" alt=""></p><p><strong>Concerns about storing examples: </strong>显然，将所有经验都存储在内存中是不可行的。因此，在这项工作中，我们重点展示当每种方法只提供很小的内存缓冲区时，我们可以获得比基线技术更高的性能。</p><h3 id="Combining-experience-replay-with-optimization-based-meta-learning"><a href="#Combining-experience-replay-with-optimization-based-meta-learning" class="headerlink" title="Combining experience replay with optimization based meta-learning"></a>Combining experience replay with optimization based meta-learning</h3><p><strong>First order meta-learning:</strong> </p><p>FOMAML  和 Reptile</p><p>Reptile通过泰勒展开指出，这两个算法对于相同的损失函数是近似优化的。Reptile可以有效地针对大致相同的目标进行优化，同时不需要像 MAML 那样针对每个学习的任务将数据拆分为训练和测试拆分。Reptile 是通过使用基于 SGD 的优化器和学习率 $\alpha$ 顺序优化 s batch数据来实现的。在对这些批进行训练之后，我们在训练 $\theta_0$ 之前获取初始参数，并将它们更新为 $\theta_0 \leftarrow \theta_0 + \beta *(\theta_k-\theta_0)$，其中 $\beta$ 是元学习更新的学习率。</p><p>该过程对每个系列的s批进行重复（算法2）。Reptile在一组s批次中大致优化了以下目标：</p><script type="math/tex; mode=display">\theta = argmin_{\theta} E_{B_1,...,B_s \sim  D} [2\sum_{i=1}^s [L(B_i) - \sum_{j-1}^{i-1}\alpha\frac{\partial L(B_i)}{\partial\theta} \cdot \frac{\partial L(B_j)}{\partial\theta}]]</script><p><img src="https://i.loli.net/2021/09/23/EOur37U1qD8GiWw.png" alt=""></p><p><strong>The MER learning objective:</strong> 在这项工作中，我们修改了Reptile算法，将其与经验回放模块适当地集成在一起，在最大化迁移和最小化干扰的同时，促进了持续学习。</p><p>正如我们在附录I中的推导过程中更详细地描述的那样，在按顺序提供样本的在线设置中实现 Reptile 目标并非易事，并且只能部分实现，因为我们对缓冲区和批次的采样策略。根据上一节关于体验回放的评论，这允许我们使用MER算法在持续学习环境中针对以下目标进行优化：</p><script type="math/tex; mode=display">\theta = argmin_{\theta} E_{[(x_{11},y_{11}),..., (x_{sk},y_{sk})] \sim M}[2\sum_{i=1}^s\sum_{j-1}^k[L(x_{ij},y_{ij}) - \sum_{q=1}^{i-1} \sum_{r=1}^{j-1} \alpha\frac{\partial L(x_{ij},y_{ij})}{\partial \theta} \cdot \frac{\partial  L(x_{qr},y_{qr})}{\partial\theta}] ]</script><p><strong>The MER algorithm:</strong> MER 使用储层采样维护经验回放式记忆 M，并在每个时间步从缓冲区中抽取 s 个批次，包括 k-1 个随机样本，以与当前示例一起训练。每个批次内的k个样本中的每一个都被视为其自己的大小为1的Reptile批次，在该批次被处理之后具有内循环爬行动物元更新。然后，我们在外部循环中跨s个批次再次应用Reptile元更新。我们在算法1中提供了关于MER的更多细节。当β=1时，该过程近似于上面的目标。采样函数生成 s 个更新批次。 通过首先添加当前示例然后从 M 中交错 k - 1 个随机样本来创建每个批次。</p><p><img src="https://i.loli.net/2021/09/23/v6gkTQhElaUqI91.png" alt=""></p><p><strong>Prioritizing current learning:</strong> 为了确保强正则化，我们希望在 Reptile 更新中处理的批次数量足够大 - 足以让经验重播开始过拟合 M。因此，我们还需要确保我们提供足够的优先级来学习当前样本，特别是因为我们可能不会将其存储在 M 中。为了在算法 1 中实现这一点，我们从 M 中采样 s 个单独的批次，这些批次按顺序处理并且每个批次都与当样本交错。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>How does MER perform on supervised continual learning benchmarks?</p><p><img src="https://i.loli.net/2021/09/23/y5uKOL7wV9R6JFT.png" alt=""></p><p>How do the performance gains from MER vary as a function of the buffer size?</p><p><img src="https://i.loli.net/2021/09/23/oGej8vdghWEXN3i.png" alt=""></p><p>How effective is MER at dealing with increasingly non-stationary settings?</p><p><img src="https://i.loli.net/2021/09/23/XGjxz7R5edQa3vL.png" alt=""></p><p>Does MER lead to a shift in the distribution of gradient dot products?</p><p><img src="https://i.loli.net/2021/09/23/EuLksbjeQTSCYRh.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Learning-to-learn-without-forgetting-by-maximizing-transfer-and-minimizing-interference&quot;&gt;&lt;a href=&quot;#Learning-to-learn-without-forgett</summary>
      
    
    
    
    
    <category term="context detection" scheme="http://example.com/tags/context-detection/"/>
    
  </entry>
  
  <entry>
    <title>5-最长回文子串</title>
    <link href="http://example.com/2021/09/19/5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>http://example.com/2021/09/19/5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</id>
    <published>2021-09-19T01:29:13.000Z</published>
    <updated>2021-09-20T01:21:35.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5-最长回文子串"></a>5-最长回文子串</h1><h4 id="5-最长回文子串-1"><a href="#5-最长回文子串-1" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串</a></h4><h2 id="动态规划DP"><a href="#动态规划DP" class="headerlink" title="动态规划DP"></a>动态规划DP</h2><ul><li>思想：对于一个子串而言，如果它是回文串，并且长度大于2，那么它首尾的两个字母去掉之后，它仍然是个回文串</li><li>状态转移方程： $(s[i]==s[j])\ \&amp;\&amp; \ dp[i+1][j-1]$ ，$dp[i][j]$ 表示子串$s[i..j]$是否是回文</li><li>边界条件,即子串的长度为 1 或 2。： $dp(i,i)=true$ 单个字符串， $dp(i,i+1) = (Si==Si+1)$两个字符</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">        String ans=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+k&lt;n;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> j = i+k;</span><br><span class="line">                <span class="comment">// 先处理两种临界情况</span></span><br><span class="line">                <span class="keyword">if</span>(k==<span class="number">0</span>) &#123; <span class="comment">//k=0时，j=i, dp[i][j]相当于一个字符串，一定是回文串</span></span><br><span class="line">                    dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(k==<span class="number">1</span>)&#123; <span class="comment">// k=1时，j=i+1 dp[i][j]相当于连续两个字符，相同时，一定是回文串</span></span><br><span class="line">                    dp[i][j] = (s.charAt(i)==s.charAt(j));</span><br><span class="line">                &#125; <span class="keyword">else</span>&#123; <span class="comment">// k&gt;1 时，需满足状态转移方程，dp[i,j] = dp[i+1][j-1] &amp;&amp; (si==sj)</span></span><br><span class="line">                    dp[i][j] = (s.charAt(i)==s.charAt(j) &amp;&amp; dp[i+<span class="number">1</span>][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &amp;&amp; k+<span class="number">1</span>&gt;ans.length())&#123; <span class="comment">//更新回文串长度</span></span><br><span class="line">                    ans = s.substring(i, i+k+<span class="number">1</span>); <span class="comment">// 注意子串方法的具体用法</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(n^2)$ 其中n是字符串长度，动态规划的状态总数为$O(n^2)$，对于每个状态，我们需要转移的实际为$O(1)$</p><p>空间复杂度: $O(n^2)$ 即存储动态规划需要的空间</p><h2 id="中心扩展"><a href="#中心扩展" class="headerlink" title="中心扩展"></a>中心扩展</h2><p>思想</p><ul><li>前提条件:</li><li><ul><li>根据状态转移方程，可以发现所有的状态，在转移的时候可能性都是唯一的。也就是说，我们可以从每一种边界情况开始扩展，也可以得出所有状态对应的答案。</li><li>边界情况，对应的子串实际上就是我们扩展出的回文串的回文中心</li></ul></li><li>本质：</li><li><ul><li>枚举所有的回文中心，并尝试扩展，直到无法扩展为止，此时的回文串长度即为回文中心下的最长回文串长度。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中心扩展</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span> || s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end=<span class="number">0</span>; <span class="comment">// 初始化最大回文串的起点和终点</span></span><br><span class="line">        <span class="comment">// 遍历每个位置，当做中心</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="comment">// 分别拿到奇数偶数的回文串长度</span></span><br><span class="line">            <span class="keyword">int</span> len_odd = expandCenter(s,i,i);</span><br><span class="line">            <span class="keyword">int</span> len_even = expandCenter(s,i,i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> len = Math.max(len_odd,len_even);</span><br><span class="line">            <span class="comment">// 计算对应最大回文子串的起点和终点</span></span><br><span class="line">            <span class="keyword">if</span>(len &gt; end-start)&#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                    这里为什么要len-1？ ，因为for循环是从0开始的，</span></span><br><span class="line"><span class="comment">                    如果是奇数回文，假设有个回文是3个，那么len=3，此时中心i是下标1（从0开始），那么(len-1)/2和len/2的结果都是1，因为整数会向下取整</span></span><br><span class="line"><span class="comment">                    但是如果是偶数回文，假设和有个回文是4个，那么len=4，此时的中心是一条虚线，但是i的位置在1，因为s是从左向右遍历的，</span></span><br><span class="line"><span class="comment">                    如果从左向右i的位置就会在2，这个时候 (len-1)/2 =1 ,len/2=2 ,很明显为了保证下标正确，我们需要的是(len-1)/2，原因是i在中心线的左边一位。</span></span><br><span class="line"><span class="comment">                    所以要少减一个1</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                start = i-(len-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">                end = i+len/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start, end+<span class="number">1</span>);<span class="comment">//注意这里end+1是因为java自带左闭右开的原因</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expandCenter</span><span class="params">(String s,<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;<span class="comment">//起始的左右边界</span></span><br><span class="line">        <span class="comment">// left = right的时候，此时回文中心是一个字符，回文串的长度是奇数</span></span><br><span class="line">        <span class="comment">// right = left+1的时候，此时回文中心是一个空隙，回文串的长度是偶数</span></span><br><span class="line">        <span class="comment">// 跳出循环的时候恰好满足 s.charAt(left)!=s.charAt(right)</span></span><br><span class="line">        <span class="keyword">while</span>(left &gt;=<span class="number">0</span> &amp;&amp; right&lt;s.length() &amp;&amp; s.charAt(left)==s.charAt(right))&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right-left-<span class="number">1</span>; <span class="comment">//回文串的长度是right-left+1-2 = right -left -1</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(n^2)$ 其中n是字符串长度，长度为1和2的回文中心分别有n和n-1个，每个回文中心最多会向外扩展$O(n)$次</p><p>空间复杂度：$O(1)$</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;5-最长回文子串&quot;&gt;&lt;a href=&quot;#5-最长回文子串&quot; class=&quot;headerlink&quot; title=&quot;5-最长回文子串&quot;&gt;&lt;/a&gt;5-最长回文子串&lt;/h1&gt;&lt;h4 id=&quot;5-最长回文子串-1&quot;&gt;&lt;a href=&quot;#5-最长回文子串-1&quot; class=&quot;</summary>
      
    
    
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>7,8-整数反转,字符串转换整数(atoi)</title>
    <link href="http://example.com/2021/09/18/7,8-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC,%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0(atoi)/"/>
    <id>http://example.com/2021/09/18/7,8-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC,%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0(atoi)/</id>
    <published>2021-09-18T12:24:07.000Z</published>
    <updated>2021-09-20T16:09:43.005Z</updated>
    
    <content type="html"><![CDATA[<h1 id="7-8-整数反转-字符串转换整数-atoi"><a href="#7-8-整数反转-字符串转换整数-atoi" class="headerlink" title="7,8-整数反转,字符串转换整数(atoi)"></a>7,8-整数反转,字符串转换整数(atoi)</h1><h4 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7. 整数反转"></a><a href="https://leetcode-cn.com/problems/reverse-integer/">7. 整数反转</a></h4><h2 id="法一：按位转换"><a href="#法一：按位转换" class="headerlink" title="法一：按位转换"></a>法一：按位转换</h2><ul><li>弹出 和 推入数字</li><li><ul><li>弹出：num = x%10;   x/=10</li><li>推入：result = result x 10 + num  (这里有可能溢出)</li></ul></li><li>模式识别：整数运算注意溢出</li><li><ul><li>转换为 INT_MAX / INT_MIN的逆运算</li></ul></li></ul><p>判断某数乘十是否会溢出，就把该数 和  INT_MAX 除10 进行比较</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(rev &lt; Integer.MIN_VALUE /<span class="number">10</span> || rev &gt; Integer.MAX_VALUE/<span class="number">10</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">int</span> digit = x % <span class="number">10</span>;</span><br><span class="line">          x /= <span class="number">10</span>;</span><br><span class="line">          rev = rev * <span class="number">10</span> + digit;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">return</span> rev;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">self, x</span>):</span></span><br><span class="line">      INT_MIN, INT_MAX = -<span class="number">2</span>**<span class="number">31</span> , <span class="number">2</span>**<span class="number">31</span>-<span class="number">1</span></span><br><span class="line">        rev = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> x!=<span class="number">0</span>:</span><br><span class="line">          <span class="comment"># INT_MIN也是一个负数，不能写成 rev &lt; INT_MIN //10</span></span><br><span class="line">            <span class="keyword">if</span> rev &lt; INT_MIN//<span class="number">10</span> +<span class="number">1</span> <span class="keyword">or</span> rev &gt; INT_MAX//<span class="number">10</span>:</span><br><span class="line">              <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            digit =x %<span class="number">10</span></span><br><span class="line">            <span class="comment"># python3 的 取模运算在x为负时也会返回[0,9) 以内的数，因此需要进行特殊判断</span></span><br><span class="line">            <span class="keyword">if</span> x&lt;<span class="number">0</span> <span class="keyword">and</span> digit &gt;<span class="number">0</span>:</span><br><span class="line">              digit -= <span class="number">10</span></span><br><span class="line">            <span class="comment"># 同理python3的整数除法在x为负数时会向下(更小的负数)取整，因此不能写成 x//=10</span></span><br><span class="line">            x = (x - digit) // <span class="number">10</span></span><br><span class="line">            rev = rev * <span class="number">10</span> + digit</span><br><span class="line">     <span class="keyword">return</span> rev</span><br><span class="line">       </span><br></pre></td></tr></table></figure><h4 id="8-字符串转换整数-atoi"><a href="#8-字符串转换整数-atoi" class="headerlink" title="8. 字符串转换整数 (atoi)"></a><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/">8. 字符串转换整数 (atoi)</a></h4><p>这道题的难点在于要考虑到各种边界问题，一不留神少了一步判断可能执行就报错了。<br>根据题目描述，可能会出现各种输入条件，比如：</p><p>“ 123”<br>“ -345 “<br>“ -+7890”<br>“11223344556677889900”<br>“ -112233.44.55aabb”<br>等等…<br>我们总结一下，字符串可能包含下面三种类型:</p><p><img src="https://i.loli.net/2021/09/20/ScF8Ka7fytjEh9g.jpg" alt=""></p><p>紫色的第一部分是空格，在转换的时候需要过滤掉<br>黄色的部分是正负号，如果是正号则忽略，是负号则需要记录这个正负号状态<br>蓝色是第三部分，这部分字符串中会包含任意字符，但我们只需要”0”到”9”这几个字符</p><p>此外，对于11223344556677889900这样的字符串，明显是超长了，所以当字符串大于最大的32位整数，或者小于最小的32位整数，后面就不用判断了。<br>题目要求是只能存储32位大小的有符号整数，所以不能用long做存储，而且需要提前判断整数的大小。</p><p><img src="https://i.loli.net/2021/09/20/Na5lE2B9p8mO3DG.jpg" alt=""></p><p>上图绿色的是最大的32位整数，三个蓝色的数组代表三种不同的输入。<br>如果是第一种2147483650，这个值本身就比最大32位整数要大了，存到int里面就溢出了，所以提前一位判断，也就是到黄色格子那一位的时候就要判断了。<br>第一种情况当前的值大于214748364直接返回最大值即可。<br>对于第二种、第三种情况，如果当的值等于214748364，即前面若干位都一样，再单端判断最后一位，也就是橙色格子那一位。如果最后一位大于等于7，同样也是直接返回最大值。</p><p>对于负数也是类似的判断方式:</p><p><img src="https://i.loli.net/2021/09/20/aT2Ueq6OHWIJX43.jpg" alt=""></p><p>如果当前值小于-214748364，直接返回最小值即可。<br>如果当前值等于-214748364，再判断最后一位，如果大于等于8，返回最小值。</p><p>总结一下整个执行流程:</p><p>过滤掉前面若干个空格(如果有的话)<br>判断正号、负号位，如果是负号则记录下状态，表示输入的是负数。<br>循环判断后面的字符串是否是0到9，如果是则累加这个值<br>当前的值跟最大、最小32位整数比较看是否溢出<br>如果是正数，且大于214748364，直接返回最大值<br>如果是正数，且等于214748364，再判断最后一位是否大于7<br>如果是负数，且小于-214748364，直接返回最小值<br>如果是负数，且等于-214748364，再判断最后一位是否大于8<br>循环结束后，根据负号的标志位返回对应的正数或负数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(str==<span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n = str.length();</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">boolean</span> is_negative = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//第一步，跳过前面若干个空格</span></span><br><span class="line"><span class="keyword">while</span>(i&lt;n &amp;&amp; str.charAt(i)==<span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">++i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果字符串全是空格直接返回</span></span><br><span class="line"><span class="keyword">if</span>(i==n) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二步，判断正负号</span></span><br><span class="line"><span class="keyword">if</span>(str.charAt(i)==<span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">is_negative = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果是正负号，还需要将指针i，跳过一位</span></span><br><span class="line"><span class="keyword">if</span>(str.charAt(i)==<span class="string">&#x27;-&#x27;</span> || str.charAt(i)==<span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">++i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第三步，循环判断字符是否在 0~9之间</span></span><br><span class="line"><span class="keyword">while</span>(i&lt;n &amp;&amp; str.charAt(i)&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; str.charAt(i)&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line"><span class="comment">//&#x27;0&#x27;的ASCII码是48，&#x27;1&#x27;的是49，这么一减就从就可以得到真正的整数值</span></span><br><span class="line"><span class="keyword">int</span> tmp = str.charAt(i)-<span class="number">48</span>;</span><br><span class="line"><span class="comment">//判断是否大于 最大32位整数</span></span><br><span class="line"><span class="keyword">if</span>(!is_negative &amp;&amp;(res&gt;<span class="number">214748364</span> ||(res==<span class="number">214748364</span> &amp;&amp; tmp&gt;=<span class="number">7</span>))) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2147483647</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否小于 最小32位整数</span></span><br><span class="line"><span class="keyword">if</span>(is_negative &amp;&amp;(-res&lt;-<span class="number">214748364</span> || (-res==-<span class="number">214748364</span> &amp;&amp; tmp&gt;=<span class="number">8</span>))) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">2147483648</span>;</span><br><span class="line">&#125;</span><br><span class="line">res = res*<span class="number">10</span> + tmp;</span><br><span class="line">++i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果有负号标记则返回负数</span></span><br><span class="line"><span class="keyword">if</span>(is_negative) &#123;</span><br><span class="line"><span class="keyword">return</span> -res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;7-8-整数反转-字符串转换整数-atoi&quot;&gt;&lt;a href=&quot;#7-8-整数反转-字符串转换整数-atoi&quot; class=&quot;headerlink&quot; title=&quot;7,8-整数反转,字符串转换整数(atoi)&quot;&gt;&lt;/a&gt;7,8-整数反转,字符串转换整数(atoi)</summary>
      
    
    
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>La-MAML: Look-ahead Meta Learning for Continual Learning</title>
    <link href="http://example.com/2021/09/17/La-MAML-Look-ahead-Meta-Learning-for-Continual-Learning/"/>
    <id>http://example.com/2021/09/17/La-MAML-Look-ahead-Meta-Learning-for-Continual-Learning/</id>
    <published>2021-09-17T06:37:09.000Z</published>
    <updated>2021-09-23T08:26:31.898Z</updated>
    
    <content type="html"><![CDATA[<h1 id="La-MAML-Look-ahead-Meta-Learning-for-Continual-Learning"><a href="#La-MAML-Look-ahead-Meta-Learning-for-Continual-Learning" class="headerlink" title="La-MAML: Look-ahead Meta Learning for Continual Learning"></a>La-MAML: Look-ahead Meta Learning for Continual Learning</h1><p>持续学习问题涉及能力有限的训练模型，这些模型在一组未知数量的顺序到达的任务上表现良好。</p><p>虽然元学习在减少新旧任务之间的干扰方面显展示出潜力，但目前的训练过程往往要么很慢，要么离线，而且对许多超参数很敏感。</p><p>作者提出<em>Look-ahead MAML (La-MAML)</em> 一种optimisation-based的快速元学习算法，用于在线持续学习，并辅之以小情节记忆。</p><p>作者在元学习更新中提出的对每个参数学习率的调制，并将其与先前关于超梯度 <em>hypergradients</em> 和元下降 <em>meta-descent</em> 的工作联系起来。</p><p>与传统的基于先验的方法相比，这提供了一种更灵活和更有效的方式来减轻灾难性遗忘。</p><p>作者开发了一种基于梯度的元学习算法，以实现高效的在线持续学习。先提出了一种连续元学习的基本算法，称为连续MAML(C-MAML)，它利用replay-buffer并优化了一个减轻遗忘的元目标。随后提出了一种对C-MAML的改进，称为La-MAML，它包括对每参数学习率(LRs)的调制，以跨任务和时间调整模型的学习速度。</p><h2 id="连续学习与元学习"><a href="#连续学习与元学习" class="headerlink" title="连续学习与元学习"></a>连续学习与元学习</h2><h3 id="涉及论文"><a href="#涉及论文" class="headerlink" title="涉及论文"></a>涉及论文</h3><ul><li>GEM：Gradient episodic memory for continual learning.</li><li>MER：Learning to learn without forgetting by maximizing transfer and minimizing interference (2019)</li><li>Reptile：On first-order meta-learning algorithms  (2017)</li><li>12：Meta-learning representations for continual learning.  (2019)</li><li>Generative-replay：Continual learning with deep generative replay. (2019)</li><li>A-GEM：Efficient lifelong learning with a-GEM  (2019)</li><li>Online-aware Meta Learning (OML) : Meta-learning representations for continual learning (2019)</li><li>2 : Continuous adaptation via meta-learning in nonstationary and competitive environments (2018)</li><li>10 : Online meta-learning (2019)</li><li>19:Continual adaptation for model-based RL (2019)</li><li>BGD：Task Agnostic Continual Learning Using Online Variational Bayes</li><li>UCB：Uncertainty-guided continual learning with bayesian neural networks</li><li>AlphaMAML : Adaptive Model-Agnostic Meta-Learning.</li></ul><p>灾难性的遗忘是Continual Learning的最大的挑战之一，当随机梯度下降（SGD）所需的i.i.d.采样条件被违反时，可能会发生这种情况，因为属于要学习的不同任务的数据按顺序到达。</p><p>连续学习(CL)算法还必须有效地利用其有限的模型容量，因为未来任务的数量是未知的。因此，确保各任务之间的梯度对齐至关重要，以便在实现其目标方面取得共同进展。</p><p>梯度情节记忆(GEM)研究了CL中权重分担和遗忘之间的关系，并开发了一种显式尝试最小化梯度干扰的算法。</p><p>Meta Experience Replay(MER)形式化了迁移-干扰权衡，并表明GEM的梯度排列目标与一阶元学习算法Reptile优化的目标一致。</p><p>除了对齐梯度外，元学习算法对 CL 也很有前景，因为它们可以直接使用元目标来影响模型优化并改进泛化或迁移等辅助目标。这避免了为了更好的CL而定义诸如稀疏性这样的启发式激励。缺点是它们通常很慢，很难调整，使它们更适合离线继续学习[12]。</p><h3 id="持续学习"><a href="#持续学习" class="headerlink" title="持续学习"></a>持续学习</h3><p>方法大致三种类型 replay-based, regularisation (or prior-based) 和  meta-learning-based .</p><ul><li>replay-based：为了避免灾难性遗忘的问题，replay-based的方法在内存中维护以前任务的样本集合。利用情节缓冲器（<em>episodic-buffer</em>）统一采样旧数据以模拟独立同分布的方法。<em>Generative-replay</em>训练生成模型能够重放过去的样本，但由于复杂的非平稳分布建模的困难而引起的可扩展性问题。GEM和A-GEM将存储器样本考虑在内，来确定改变的低干扰梯度以更新参数。</li><li>Regularisation-based：是一种启发式的方法，确保保留先前任务的性能的来约束网络权重，从而完全避免使用重放。这包括惩罚被认为对旧任务很重要的权重的改变，或者强制实施权重或表征稀疏性，以确保在任何时间点只有一部分神经元保持活跃。</li><li>Meta-Learning-based：这些方法是最近才出现的。MER 受 GEM 的启发，利用重放来激励新旧任务之间的梯度对齐。 OML引入了用于预训练算法的元目标，以离线学习最优表示，该最优表示随后被冻结并用于CL。[2，10，19]研究正交设置，其中学习代理使用所有先前看到的数据来快速适应传入的数据流，从而忽略灾难性遗忘的问题。</li></ul><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>首先通过顺序地观察 $T$ 个任务的训练数据$[D_1,D_2,…,D_T]$ 来学习 $T$ 个任务的序列 $[\tau_1,\tau_2 ,…,\tau_T]$  </p><p>定义$X^i,Y^i = {(x<em>n^i,y_n^i)}</em>{n=0}^{N_i}$ 为$N_i$个输入标签集合从数据 $D_i$ 中随机抽取。</p><p>在在线学习过程中的任意时间步长 $j$，我们的目标是最小化模型在迄今看到的所有 $t$ 个任务上的经验风险 $(τ_{1:t})$，给定对来自先前任务 $τ_i(i&lt;t)$ 的数据 $(X_i，Y_i)$ 限制访问。我们将这一目标称为累积风险，具体如下：</p><script type="math/tex; mode=display">\sum_{i=1}^t \mathbf{E}_{(X^i,Y^i)}[l_i(f_i(X^i;\theta) ,Y^i)] = \mathbf{E}_{(X^{1:t},Y^{1:t})}[L_t(f(X^{1:t};\theta), Y^{1:t})]</script><p>其中 $l_i$ 是在任务$\tau_i$上的loss， $f_i$ 是学习器，参数 $θ_0^j$ 是从输入到输出的特定任务映射参数。</p><p>$L<em>t = \sum</em>{i=1}^t l<em>i$  是任务 $τ</em>{1:t}$ 的所有任务损失之和，其中 $t$ 从 1到 $T$ 。设 $l$ 表示要最小化的某些损失目标。</p><p>作用于参数$θ_0^j$ (由 $U(θ_0^j)$ ) 表示的SGD运算定义为：</p><script type="math/tex; mode=display">U(\theta^j_0)=\theta_1^j = \theta_0^j-\alpha \nabla_{\theta_0^j} l(\theta_0^j) = \theta_0^j - \alpha g_0^j</script><p>$U$ 可以为 $U_k(\theta_0^j) = U…\circ U\circ U(\theta_0^j) =\theta_k^j$</p><h3 id="Model-Agnostic-Meta-Learning-MAML"><a href="#Model-Agnostic-Meta-Learning-MAML" class="headerlink" title="Model-Agnostic Meta-Learning (MAML):"></a>Model-Agnostic Meta-Learning (MAML):</h3><p>meta learning 成为一种流行的训练模型的方法，能够在有限的数据上进行快速调整。MAML建议优化模型参数，以学习一组任务，同时改进辅助目标，如任务分布中的few-shot 少样本泛化。</p><p>基于梯度的元学习中使用的一些常用术语：</p><ul><li><p>初始化：在训练期间的给定时间步长 $j$ 处，模型参数 $θ_0^j$ (或为简单起见，$θ_0$)通常被称为初始化，因为其目的是找到对不可见数据进行 few-shot 基于梯度的适配的理想起点。</p></li><li><p>inner-updates快速或内部更新：是对 $θ_0$ 的副本进行基于梯度的更新，以优化某些内部目标(在本例中，对于某些$τ_i$，为$l_i$)。</p></li><li><p>meta-update：元更新涉及从 $θ<em>0$ 到 $θ_k$ 的快速更新的轨迹，然后进行到 $θ_0$的永久梯度更新(或缓慢更新)。该缓慢更新是通过评估 $θ_k$ 上的辅助目标(或元损失meta loss $L</em>{meta}$)并通过轨迹微分以获得$\nabla<em>{\theta_k}L</em>{meta}(\theta<em>k)$来计算的。因此，MAML在时间步 $j$ 优化 $θ_0^j$，以便在对它们的样本进行几次梯度更新之后，对 ${\tau</em>{1:t}}$中的任务执行最佳性能。它在每一次元更新中都进行了优化，目标是：</p><script type="math/tex; mode=display">min_{\theta_0^j}\mathbf{E}_{\tau_{1:t}}[L_{meta}(U_k(\theta_0^j))] = min_{\theta_0^j}\mathbf{E}_{\tau_{1:t}}[L_{meta}(\theta_k^j)]</script></li></ul><h3 id="元学习与持续学习目标的等价性"><a href="#元学习与持续学习目标的等价性" class="headerlink" title="元学习与持续学习目标的等价性:"></a>元学习与持续学习目标的等价性:</h3><p>Reptile证明了Reptile算法和MAML算法等一阶和二阶元学习算法的近似等价性</p><p>MER随后表明，他们的CL目标是在一组任务$\tau_{1:t}$之间最小化损失并调整梯度，直到任何时间 $j$（在左边），可以通过Reptile目标（在右边）进行优化，即：</p><script type="math/tex; mode=display">min_{\theta_0^j} (\sum_{i=1}^t(l_i(\theta_0^j)) - \alpha\sum_{p,q\le t}(\frac{\partial l_p(\theta_0^j)} {\partial\theta_0^j} \cdot \frac{\partial l_q(\theta_0^j)}{\partial\theta_0^j})) =min_{\theta_{0}^j }\mathbf{E_{\tau_{1:t}}}[L_t(U_k(\theta_0^j))]</script><p>其中 meta-loss $L<em>t = \sum</em>{i=1}^t l<em>i$  根据Tasks $\tau</em>{1:t}$中的样本进行评估。这意味着元学习初始化的过程与学习CL的最优参数一致。</p><h3 id="在线感知元学习-OML-："><a href="#在线感知元学习-OML-：" class="headerlink" title="在线感知元学习(OML)："></a>在线感知元学习(OML)：</h3><p>[12]提出了元学习 <em>Representation-Learning Network</em>  网络(RLN)的概念，为<em>Task-Learning Network</em> (TLN)提供适合协作学习的表示。</p><p>RLN的表示是在离线阶段学习的，在该阶段使用灾难性遗忘作为学习信号进行训练。当TLN经历时间相关更新时，来自固定任务集（$\tau_{val}$）的数据被反复用于评估RLN和TLN。</p><p>在每个元更新的内循环中，TLN使用冻结的RLN对流式任务数据进行快速更新。然后，通过根据来自$\tau_{val}$的数据以及当前任务计算的 meta loss来评估RLN和更新的TLN。</p><p>这将测试在尝试学习流任务的过程中，模型在 $\tau_{val}$ 上的性能发生了怎样的变化。然后对meta loss进行微分，以获得针对TLN和RLN的缓慢更新的梯度。</p><p>这两个loss的组合被称为OML目标，以模拟内环中的CL和测试外环中的遗忘。RLN学习最终为CL的TLN提供更好的表示，该表示被证明具有紧急稀疏性。</p><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><p>在上一节中，我们看到OML目标可以直接规范CL行为，并且MER利用了元学习和CL目标的近似等价性。我们注意到，OML离线训练静态表示和MER算法慢得令人望而却步。</p><p>作者表明，通过多步MAML过程在线优化OML目标等同于更有效的样本效率CL目标。</p><h3 id="Continual-MAML-C-MAML"><a href="#Continual-MAML-C-MAML" class="headerlink" title="Continual-MAML (C-MAML)"></a>Continual-MAML (C-MAML)</h3><p>C-MAML旨在在线优化OML目标，这样学习当前任务就不会导致忘记以前见过的任务。我们定义了这个目标，适用于优化模型的参数 θ 而不是时间步 j 的表示，如下所示：</p><script type="math/tex; mode=display">min_{\theta_0^j} OML(\theta_0^j,t) = min_{\theta_0^j} \sum_{S_k^j\sim D_t}[L_t(U_k(\theta_0^j,S_k^j))]</script><p>其中 $S<em>k^j$ 是来自前任务$\tau</em>{t}$ 中的k个数据元组的流 $(X<em>{j+l}^t,Y</em>{j+l}^t)^k$ ，这是模型在时间 $j$ 处看到的。</p><p>Meta loss $L<em>t = \sum</em>{i=1}^l l<em>i$ 在 $\theta</em>{k}^j = U<em>k(\theta</em>{0}^j ,S_k^j)$ 上评估。它评估 $\theta_k^j$ 对于上面第一个公式中定义的持续学习预测任务的适合性，直到$\tau_t$.</p><p>省略了隐含的数据参数 $(x^i,y^i) \sim (X^i,Y^i)$ 这是任何任务$\tau_i$的 $L_t$ 中每个损失 $l_i$ 的输入。附录B</p><script type="math/tex; mode=display">min_{\theta_0^j}\mathbf{E}_{\tau_{1:t}} [L_t(U_k(\theta_0^j))] = min_{\theta_0^j} \sum_{i=1}^t(l_i(\theta_0^j) - \alpha \frac{\partial l_i(\theta_0^j)} {\partial\theta_0^j} \cdot \frac{\partial l_t(\theta_0^j)}{\partial\theta_0^j})</script><p>与上文元学习与合作学习目标的等价性那个公式不同它是不对称的，它集中于对其$\tau<em>t$的梯度和$\tau</em>{1:t}$的平均梯度，而不是在任务$\tau_{1:t}$之间对齐所有成对梯度。附录D</p><p>作者的经验表明，旧任务之间的梯度对齐不会退化，而学习了新任务，避免了重复优化它们之间的任务间对齐的需要。</p><p>这导致MER目标的显著加速，该目标试图将所有$\tau_{1:t}$ 上相乘均匀分布的批次。由于每个s 在梯度更新中有 $1/t-th$ 次贡献，因此MER有必要对包括s在内的许多此类均匀批次进行多次传递。</p><p>在训练期间，如MER中所示，通过对输入数据流的存储采样来填充重放缓冲器R。</p><p>在每次元更新开始时，从当前任务中采batch b。b还与从R采样的批次组合以形成元批次meta-batch $b<em>m$，其表示来自旧任务和新任务的样本。$\theta_0^j$通过k个基于sgd的内部更新进行更新，每次从b查看一个当前任务的样本。外部损失或元损失$L_t(\theta_k^j)$是在$b_m$上评估的。它指示参数 $\theta_k^j$ 在时间 $j$ 之前看到的所有任务 $\tau</em>{1:t}$上的性能。 附录C</p><h3 id="Lookahead-MAML-La-MAML"><a href="#Lookahead-MAML-La-MAML" class="headerlink" title="Lookahead-MAML (La-MAML)"></a>Lookahead-MAML (La-MAML)</h3><p>尽管元学习激励了任务内和任务间组的梯度对齐，但在新旧任务的梯度之间仍然可能有一些干扰，$\tau<em>{1:t−1}$和 $\tau</em>{t}$。</p><p>这将导致忘记 $\tau<em>{1:t−1}$，因为它的数据不再对我们完全可用。在训练新任务的开始阶段尤其如此，因为新任务的梯度不一定与旧任务一致。因此，需要一种机制来确保元更新相对于$\tau</em>{1:t-1}$是保守的、避免负迁移。元更新的幅度和方向需要根据更新对 $\tau_{1:t-1}$ 损失的影响程度进行调整。La-MAML包括一组可学习的pre-parameter学习率(LR)，用于内部更新，如图1所示。</p><p><img src="https://i.loli.net/2021/09/18/LhcnFOblKsCEPAZ.png" alt=""></p><p>对于每批数据，初始权重经历一系列 $k$ 次快速更新以获得 $\theta_k^j$ (这里 $j=0$)，其针对元损失进行评估以相对于权重 $\theta_0$ 和LRs $\alpha_0$ 反向传播梯度。首先，$\alpha^0$更新为$\alpha^1$，然后用于将 $\theta_0^0$更新为 $\theta_0^1$，蓝色框表示快速权重，绿色框表示慢速更新的梯度。LRs和权重以异步方式更新。</p><p>这是因为我们观察到上面OML的方程的梯度相对于内循环的 LR 的表达式直接反映了旧任务和新任务之间的对齐情况。扩充的学习目标被定义为:</p><script type="math/tex; mode=display">min_{\theta_0^j,\alpha^j} \sum_{S_k^j\sim D_t}[L_t(U_k(\alpha^j,\theta_0^j,S_k^j))]</script><p>以及该目标在时间 $j$ 的梯度，相对于 LR 向量 $\alpha^j$ （定义为$g_{MAML}(\alpha^j)$）:</p><script type="math/tex; mode=display">g_{MAML}(\alpha^j) = \frac{\partial}{\partial\alpha^j} L_t(\theta^j_k) = \frac{\partial}{\partial\theta^j_k}L_t(\theta^j_k) \cdot (-\sum_{k'=0}^{k-1}\frac{\partial}{\partial\theta_k^j} l_t(\theta_{k'}^j))</script><p>附录A推导</p><p>$g<em>{MAML}(\alpha)$ 中的第一项对应于元损失的梯度在batch上 $b_m:g</em>{meta}$。第二项表示来自内部更新的累积梯度：$g_{traj}$。</p><p>该表达式表明，当$g<em>{meta}$和 $g</em>{traj}$之间的内积较高时，LRs的梯度将为负，即两者对齐；当两者正交（不干扰）时为零，当两者之间存在干扰时为正。</p><p>负的(正的)LR梯度会拉高(降低)LR的大小。如下图：</p><p><img src="https://i.loli.net/2021/09/18/jQSTzt4dbLsVyqa.png" alt=""></p><p>$g<em>{traj}$ (蓝色虚线)和 $g</em>{meta}$对齐的不同场景，从扰动(左)到对齐(右)。黄色箭头表示内部更新。当梯度对齐(扰动)时，LR $\alpha$ </p><p>增加(减少)。</p><p>我们建议在元更新中异步更新网络权重和LRs。设$\alpha^{j+1}$ 为更新的LR 向量，该向量通过在时间 $j$ 处采用上一个等式中的LR梯度进行SGD而获得。然后，我们将权重更新为：</p><script type="math/tex; mode=display">\theta_0^{j+1} \leftarrow \theta_0^j - max(0,\alpha^{j+1}) \cdot \nabla_{\theta_0^j} L_t(\theta_k^j)</script><p>其中k是在内循环中采取的步数。 将 LRs $\alpha^{j+1}$ 修剪为正值，以避免上升梯度，并且也避免进行扰动的参数更新，从而减轻灾难性遗忘。因此，元目标保守地调节学习的速度和方向，以便在新任务上取得更快的学习进度，同时促进旧任务的迁移。</p><p><img src="https://i.loli.net/2021/09/18/oB2XVDnMRjteq3b.png" alt=""></p><p>Line(a)，(b)是C-MAML和La-MAML之间的唯一区别，C-MAML使用固定标量LR $\alpha$ 进行元更新到 $\theta_0^j$，而不是 $\alpha^{j+1}$。</p><p>作者的基于元学习的算法结合了基于先验和基于回放的方法的概念。LR在重放样本上的梯度和流任务之间的相互作用的指导下，以数据驱动的方式调制参数更新。然而，由于LR随着每次元更新而演变，它们的衰变是暂时的。这与许多基于先验的方法不同，在这些方法中，对参数更改的惩罚逐渐变得非常高，以至于网络容量饱和。</p><p>随着任务的到来，可学习的LR可以调整为高值和低值，因此是一种更简单、灵活和优雅的约束权重的方法。这种异步更新类似于信任区域优化或前瞻搜索，因为每个参数的步长是根据对它们应用假设更新后产生的损失进行调整的。</p><h3 id="与其他工作的联系"><a href="#与其他工作的联系" class="headerlink" title="与其他工作的联系"></a>与其他工作的联系</h3><h4 id="Stochastic-Meta-Descent-SMD"><a href="#Stochastic-Meta-Descent-SMD" class="headerlink" title="Stochastic Meta-Descent (SMD)"></a>Stochastic Meta-Descent (SMD)</h4><p>当学习非平稳数据分布时，使用衰减的LR策略并不常见。严格递减 LR 策略旨在更接近收敛于固定分布的固定 mimima，这与在线学习的目标不一致。由于数据分布的范围未知，因此也不可能手动调整这些计划。</p><p>然而，LRS的适应性仍然是非常需要的，以适应优化的场景，加速学习，调节适应的程度，以减少灾难性遗忘。我们的自适应LRS可以连接到离线监督学习(OSL)中的元下降。虽然存在几种不同的变种，但它们背后的核心思想和我们的方法是获得适应。当我们根据新旧任务梯度之间的相关性调整增益以在所有任务上共享进展时，[4，25]利用两个连续随机梯度之间的相关性来更快地收敛。我们利用元目标关于LRS的可微性，自动获得LR超梯度。</p><h4 id="Learning-LRs-in-meta-learning"><a href="#Learning-LRs-in-meta-learning" class="headerlink" title="Learning LRs in meta-learning"></a>Learning LRs in meta-learning</h4><p>Meta-SGD 建议学习MAML中的LRS以进行few-shot学习。他们的更新和我们的更新有一些显著的不同。它们同步更新权重和LR，而我们对LRS的异步更新用于执行更保守的权重更新。</p><p>我们更新的直觉来自于需要减轻梯度干扰及其与持续学习中普遍存在的转移-干扰权衡的联系。α-MAML解析地更新了MAML更新中的两个标量LR，以实现更自适应的few-shot学习。我们的每个参数的LR通过反向传播被隐式地调制，以基于它们在任务之间的排列来调节参数的变化，为我们的模型在CL领域提供了更强大的适应性。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>指标</p><p>使用保留精度retained accuracy（RA）度量来比较各种方法。RA 是模型在训练结束时跨任务的平均准确率。</p><p>反向迁移和干扰 <em>backward-transfer and interference</em>(BTI)值，它衡量每个任务从学习到最后一个任务结束的准确性的平均变化。 较小的 BTI 意味着训练期间遗忘较少。</p><p><em>Efficient Lifelong Learning (ELL)</em>:  高效终身学习 (LLL)：在A-GAM中形式化，高效终身学习的设置假设每个任务的传入数据必须仅通过一次处理：一旦处理，数据样本将不再可访问，除非它们被添加到 回放记忆。</p><p><img src="https://i.loli.net/2021/09/18/DrAbfMtzHEpoaBP.png" alt=""></p><p>随着训练的进行，模型会演变成对遗忘的抵抗力。这意味着超过一个点，它可以在传入样本的一个小窗口上持续进行梯度更新，而不需要进行元更新。</p><p><img src="https://i.loli.net/2021/09/18/mdJEbSojDI7aBvf.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;La-MAML-Look-ahead-Meta-Learning-for-Continual-Learning&quot;&gt;&lt;a href=&quot;#La-MAML-Look-ahead-Meta-Learning-for-Continual-Learning&quot; class=&quot;h</summary>
      
    
    
    
    
    <category term="context detection" scheme="http://example.com/tags/context-detection/"/>
    
  </entry>
  
  <entry>
    <title>4-三种方法彻底解决中位数问题</title>
    <link href="http://example.com/2021/09/15/4-%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%E5%BD%BB%E5%BA%95%E8%A7%A3%E5%86%B3%E4%B8%AD%E4%BD%8D%E6%95%B0%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2021/09/15/4-%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%E5%BD%BB%E5%BA%95%E8%A7%A3%E5%86%B3%E4%B8%AD%E4%BD%8D%E6%95%B0%E9%97%AE%E9%A2%98/</id>
    <published>2021-09-15T01:31:49.000Z</published>
    <updated>2021-09-16T03:23:36.548Z</updated>
    
    <content type="html"><![CDATA[<h1 id="4-三种方法彻底解决中位数问题"><a href="#4-三种方法彻底解决中位数问题" class="headerlink" title="4-三种方法彻底解决中位数问题"></a>4-三种方法彻底解决中位数问题</h1><h4 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a>4. 寻找两个正序数组的中位数</h4><h2 id="两种思想"><a href="#两种思想" class="headerlink" title="两种思想"></a>两种思想</h2><ul><li>真合并：使用归并的方式，合并两个有序数组，得到一个大的有序数组，大的有序数组中的中间位置的元素即为中位数。$O(n+m),O(n+m)$</li><li>假合并：不需要合并两个有序数组，只要找到中位数的位置即可。由于两个数组的长度已知，因此中位数对应的两个数组下标之和也是已知的。维护两个指针，初始时分别指向两个数组的下标为0的位置，每次将指向较小的指针后移一位（如果一个指针已经到达数组末尾，则只需要移动另一个数组的指针），直到达到中位数的位置。$O(n+m),O(1)$</li></ul><h2 id="常见的思想改进：假合并、奇偶合并"><a href="#常见的思想改进：假合并、奇偶合并" class="headerlink" title="常见的思想改进：假合并、奇偶合并"></a>常见的思想改进：假合并、奇偶合并</h2><p>通过假合并的思想可以将空间复杂度优化到$O(1)$但对于时间复杂度并没有什么优化，此方法代码复杂，不仅要考虑奇偶问题，更需要高了一个数组遍历后的各种边界问题。</p><p>假合并的一个优化点是 将奇偶两种情况合并到了一起：</p><ul><li>如果是奇数，我们需要知道第(len+1)/2 个数就可以了，如果遍历的话需要遍历int(len/2)+1次</li><li>如果是偶数，需要知道第(len/2) 和 len/2 + 1个数，也是需要遍历len/2 + 1次</li><li>返回中位数，奇数需要最后一次遍历结果就可以，偶数需要最后一次和上一次的结果。所以用两个变量left和right。right保存当前循环的结果，在每次循环前将right赋值给left。这样在最后一次循环的时候，left将得到right的值，也就是上一次的循环结果，加下来right更新为最后一次的结果len/2+1次</li></ul><p>另一种合并的思想是: 我们可以在奇数的时候, 在<strong>末尾等处添加一个占位符</strong>#等, 这样也是可以将奇数合并成偶数的情况的.此方法的另一个优化点就是 通过在if条件中<strong>加入大量的限制条件</strong>, 从而实现了对于各种边界问题的处理, 这也是一种很重要的思想.</p><p><img src="https://i.loli.net/2021/09/15/rwI2miAu4SPgOX7.jpg" alt=""></p><p><img src="https://i.loli.net/2021/09/15/G1OiltFhg24JmY8.jpg" alt=""></p><p>此方法的时间复杂度相对于下面两种思想还是太高了, 大家不用特意掌握此方法, 但是这两个优化的思想还是很重要的, 要好好的理解一下.</p><p>接下来我们就来详细讲解两个时间复杂度超低的算法代码思想.</p><h2 id="寻找第k小数-记住这个"><a href="#寻找第k小数-记住这个" class="headerlink" title="寻找第k小数(记住这个)"></a>寻找第k小数(记住这个)</h2><p> 主要就是根据两个数的三种比较结果, 不断地去除不满足的元素的过程.</p><p><img src="https://i.loli.net/2021/09/15/hKBdPugr5fRxXeC.jpg" alt=""></p><p>这个思想最难的点在于 <strong>三种特殊情况的处理</strong>, 我们能否想到这三种情况, 并将他们<strong>完美的融入到代码之中</strong>, 我感觉这才是真正的难点所在.</p><p><img src="https://i.loli.net/2021/09/15/AdgYMm3xTtQSup8.jpg" alt=""></p><p>最开始对于奇数和偶数的两种情况进行了判断, 其实是可以将两种情况合并的, 只需要在奇数时求两次同样的k就可以了.</p><p><img src="https://i.loli.net/2021/09/15/rmU7B5WJRGELvjd.jpg" alt=""></p><p>接下来处理了三种特殊情况中的两种特殊情况: 一个数组为空 和 k=1.</p><p><img src="https://i.loli.net/2021/09/15/XGbolki98Dv6BCK.jpg" alt=""></p><p>下面的<strong>几个定义</strong>就非常重要了, 一定要弄清这些定义的含义, 才能更轻松的理解代码.</p><p><img src="https://i.loli.net/2021/09/15/vkMmQjqNbPZGIwn.jpg" alt=""></p><p>index1, index2作为数组的起始点的下标, 初值都是0, 但是随着两个数组不断被删除元素, 这两个起始点也是在不断的进行变化, 具体变化方式就是 index1 = newIndex1 + 1, 因为在删除元素的时候 连同比较位置也一同删去了, 所以新的开始是 比较位置 的后一位.</p><p>newindex1, newindex2作为比较点就是图中被框中的两个数的下标, 它的赋值过程就涉及到了 最后一个边界情况. 因为当一个数组较短时, 其中一个比较点可能已经到达了数组的最后, 所以它的值是 两种情况下较小的那个数.</p><p><img src="https://i.loli.net/2021/09/15/mAW7YsNX5GBcKgH.jpg" alt=""></p><p>接下来就是根据两个比较点的大小来进行不同的操作过程了, 这里最难理解的点就是 k -= (newIndex1 - index1 + 1), 也就是减去元素的个数问题了. 我们根据上面的图来举例, 图中index1的值为0, newindex1的值经过计算为1, 通过比较后, 可以看到 红色的数 就是被删除的数, 也就是两个, 所以我们需要在最后+1才是真实被删去的个数. 对于此类问题在确定最终个数的时候, 我们都可以通过这样的特例来决定代码的书写, 至此代码就全部讲解完成了.</p><p><img src="https://i.loli.net/2021/09/15/1hmHAU4Ets7iFJ9.jpg" alt=""></p><h2 id="理解中位数作用进行划分数组"><a href="#理解中位数作用进行划分数组" class="headerlink" title="理解中位数作用进行划分数组"></a>理解中位数作用进行划分数组</h2><p>最后这种思想时间复杂度比上面的还低，上面的思想每一轮循环可以将查找范围减少一半，因此时间复杂度是$O(log(m+n))$ ，但这种思想可以对确定的较短的数组进行二分查找，所以它的时间复杂度是$O(logmin(m,n))$</p><p>划分数组正好和上面算法完全相反，它的思想特别复杂，但思想理解了，代码写起来倒是没太大难度。</p><p>首先要明白中位数的作用：将一个集合划分为两个长度相等的子集，其中一个子集中的元素总是大于另一个子集中的元素。这种思想无论是在机构数组中都是适用的，这就衍生出了下面的思想。</p><p>首先讨论奇偶两种不同情况的不同划分方式，</p><p><img src="https://i.loli.net/2021/09/16/8n9sSjVk7C3GKZM.jpg" alt=""></p><p>然后在写代码时，由于计算机的取整操作，我们是可以将这两种情况合并成一种代码书写方式，其中的$i$和$j$分别是两个数组的划分位置。</p><p><img src="https://i.loli.net/2021/09/16/LzOv1Zxn8pBUVQo.jpg" alt=""></p><p>同样我们也会遇到复杂的边界问题, 但下面这种处理方式是真的非常优秀.</p><p><img src="https://i.loli.net/2021/09/16/bBhSzkpAOunIXNj.jpg" alt=""></p><p>上面问题都考虑完了, 其实就可以写代码了, 但是我们需要进行两个条件的判断: B[j−1]≤A[i] 以及A[i−1]≤B[j], 为了优化代码, 经过分析后, 我们发现这两种情况是可以等价转换的. 也就是只需要进行一个条件的判断即可.</p><p><img src="https://i.loli.net/2021/09/16/YZ2lJiL9IomnaKH.jpg" alt=""></p><p>代码中有个注意点就是java中的<strong>三目运算符? :</strong> 在Python中是没有引入这个符号的, 但是Python利用了已有的关键字if…else实现了这个功能.</p><p><img src="https://i.loli.net/2021/09/16/gRSNcoWaidyOnhz.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//常规思想 假合并</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n = nums2.length;</span><br><span class="line">        <span class="keyword">int</span> len = m+n;</span><br><span class="line">        <span class="keyword">int</span> left = -<span class="number">1</span>, right= -<span class="number">1</span>; <span class="comment">// 记录前后两个数</span></span><br><span class="line">        <span class="keyword">int</span> aStart=<span class="number">0</span>, bStart=<span class="number">0</span>;  <span class="comment">// 记录两个数组的移动</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=len/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            left = right; <span class="comment">// 每次循环前将right的值赋给left</span></span><br><span class="line">            <span class="comment">// A移动的条件：B遍历到最后 或当前 A&lt;B 满足一个即可</span></span><br><span class="line">            <span class="keyword">if</span>(aStart &lt; m &amp;&amp; (bStart&gt;=n || nums1[aStart] &lt; nums2[bStart]))&#123;</span><br><span class="line">                right = nums1[aStart++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right= nums2[bStart++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((len &amp; <span class="number">1</span>) == <span class="number">0</span>) <span class="comment">// 与1交，判断奇偶数，更快速</span></span><br><span class="line">            <span class="keyword">return</span> (left+right)/<span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第k小数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length1 = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> length2 = nums2.length;</span><br><span class="line">        <span class="keyword">int</span> totallength = length1+ length2;</span><br><span class="line">        <span class="keyword">if</span>(totallength % <span class="number">2</span> == <span class="number">1</span>)&#123; <span class="comment">// 可以将两种情况合并，奇数会求两次同样的k</span></span><br><span class="line">            <span class="keyword">int</span> midIndex = totallength/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">double</span> median = getKthElement(nums1, nums2, midIndex+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> median;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> midIndex1 = totallength/<span class="number">2</span> -<span class="number">1</span> , midIndex2 = totallength/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">double</span> median = (getKthElement(nums1, nums2, midIndex1 + <span class="number">1</span>) + getKthElement(nums1, nums2, midIndex2 + <span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">            <span class="keyword">return</span> median;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getKthElement</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        主要思路：要找到第k(k&gt;1)小的元素，那么就取pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较</span></span><br><span class="line"><span class="comment">        这里的“/” 表示整除</span></span><br><span class="line"><span class="comment">        nums1 中小于等于pivot1的元素有 nums1[0..k/2-2] 共计k/2-1个</span></span><br><span class="line"><span class="comment">        nums2 中小于等于pivot2的元素有 nums2[0..k/2-2] 共计k/2-1个</span></span><br><span class="line"><span class="comment">        取 pivot = min(pivot1 , pivot2) 两个数组中小于等于 pivot的元素共计不会超过(k/2-1)+(k/2-1) &lt;=k-2个</span></span><br><span class="line"><span class="comment">        这样pivot本身最大也只能是第k-1小的元素</span></span><br><span class="line"><span class="comment">        * 如果 pivot = pivot1,那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;,剩下的作为新的 nums1 数组</span></span><br><span class="line"><span class="comment">         * 如果 pivot = pivot2,那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;,剩下的作为新的 nums2 数组</span></span><br><span class="line"><span class="comment">        由于我们 &quot;删除&quot; 了一些元素（这些元素都比第 k 小的元素要小）,因此需要修改 k 的值,减去删除的数的个数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> length1 = nums1.length, length2=nums2.length;</span><br><span class="line">        <span class="keyword">int</span> index1 = <span class="number">0</span>, index2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> kthElemnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//特殊情况</span></span><br><span class="line">            <span class="keyword">if</span>(index1==length1)&#123;<span class="comment">//第二种特殊情况，一个数组为空</span></span><br><span class="line">                <span class="keyword">return</span> nums2[index2+k-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(index2==length2)&#123;<span class="comment">//一个数组为空</span></span><br><span class="line">                <span class="keyword">return</span> nums1[index1+k-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">1</span>)&#123; <span class="comment">// 第三种情况，k=1</span></span><br><span class="line">                <span class="keyword">return</span> Math.min(nums1[index1], nums2[index2]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 正常情况， index1，index2作为起始点，newindex1,newindex2作为比较点 在不停的更新</span></span><br><span class="line">            <span class="keyword">int</span> half = k/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> newIndex1 = Math.min(index1 + half, length1) -<span class="number">1</span>;<span class="comment">// 第一种情况，发生越界，需要记录比较的位置</span></span><br><span class="line">            <span class="keyword">int</span> newIndex2 = Math.min(index2 + half, length2) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> pivot1 = nums1[newIndex1], pivot2=nums2[newIndex2]; <span class="comment">//获取两个需要比较的数</span></span><br><span class="line">            <span class="keyword">if</span>(pivot1&lt;=pivot2)&#123;</span><br><span class="line">                <span class="comment">// 将两种情况合并</span></span><br><span class="line">                k -= (newIndex1 -index1 +<span class="number">1</span>); <span class="comment">//两者相减后+1，这才是真正减去的长度</span></span><br><span class="line">                index1 = newIndex1+<span class="number">1</span>; <span class="comment">//连同比较位置也一同删去了，所以新的开始是 比较位置的后一位</span></span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                k -= (newIndex2-index2+<span class="number">1</span>);</span><br><span class="line">                index2 = newIndex2+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1.length &gt; nums2.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> findMedianSortedArrays(nums2, nums1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n = nums2.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = m;</span><br><span class="line">        <span class="comment">// median1：前一部分的最大值</span></span><br><span class="line">        <span class="comment">// median2：后一部分的最小值</span></span><br><span class="line">        <span class="keyword">int</span> median1 = <span class="number">0</span>, median2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123; <span class="comment">// 一直循环找到一个最大的i满足A[i-1]≤B[j]</span></span><br><span class="line">            <span class="comment">// 前一部分包含 nums1[0 .. i-1] 和 nums2[0 .. j-1]</span></span><br><span class="line">            <span class="comment">// 后一部分包含 nums1[i .. m-1] 和 nums2[j .. n-1]</span></span><br><span class="line">            <span class="keyword">int</span> i = (left + right) / <span class="number">2</span>; <span class="comment">//二分法,i从区间中间开始</span></span><br><span class="line">            <span class="keyword">int</span> j = (m + n + <span class="number">1</span>) / <span class="number">2</span> - i;<span class="comment">//+1的操作将总数为奇数和偶数合并为一种情况</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//nums_im1, nums_i, nums_jm1, nums_j 分别表示 nums1[i-1], nums1[i], nums2[j-1], nums2[j]</span></span><br><span class="line">            <span class="comment">//当一个数组不出现在前一部分时,对应的值为负无穷,就不会对前一部分的最大值产生影响</span></span><br><span class="line">            <span class="keyword">int</span> nums_im1 = (i == <span class="number">0</span> ? Integer.MIN_VALUE : nums1[i - <span class="number">1</span>]);</span><br><span class="line">            <span class="comment">//当一个数组不出现在后一部分时,对应的值为正无穷,就不会对后一部分的最小值产生影响</span></span><br><span class="line">            <span class="keyword">int</span> nums_i = (i == m ? Integer.MAX_VALUE : nums1[i]);</span><br><span class="line">            <span class="keyword">int</span> nums_jm1 = (j == <span class="number">0</span> ? Integer.MIN_VALUE : nums2[j - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">int</span> nums_j = (j == n ? Integer.MAX_VALUE : nums2[j]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums_im1 &lt;= nums_j) &#123;</span><br><span class="line">                median1 = Math.max(nums_im1, nums_jm1);</span><br><span class="line">                median2 = Math.min(nums_i, nums_j);</span><br><span class="line">                left = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = i - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (m + n) % <span class="number">2</span> == <span class="number">0</span> ? (median1 + median2) / <span class="number">2.0</span> : median1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="comment"># 常规思想</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays1</span>(<span class="params">self, nums1, nums2</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m = <span class="built_in">len</span>(nums1)</span><br><span class="line">        n = <span class="built_in">len</span>(nums2)</span><br><span class="line">        lens = m+n</span><br><span class="line">        left, right = -<span class="number">1</span>, -<span class="number">1</span></span><br><span class="line">        aStart,bStart = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(lens//<span class="number">2</span>+<span class="number">1</span>):</span><br><span class="line">            left = right  <span class="comment"># 每次循环将right的值赋值给left</span></span><br><span class="line">            <span class="comment"># A移动的条件，B遍历到最后 或A&lt;B满足一个</span></span><br><span class="line">            <span class="keyword">if</span> aStart&lt;m <span class="keyword">and</span> (bStart &gt;= n <span class="keyword">or</span> nums1[aStart] &lt; nums2[bStart]):</span><br><span class="line">                right = nums1[aStart]</span><br><span class="line">                aStart+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = nums2[bStart]</span><br><span class="line">                bStart+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (lens &amp; <span class="number">1</span>)  == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> (left+right)/<span class="number">2.0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> right</span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">    <span class="comment"># 第k小数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span>(<span class="params">self, nums1, nums2</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getKthElemnt</span>(<span class="params">k</span>):</span></span><br><span class="line">            index1, index2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="comment"># 特殊情况</span></span><br><span class="line">                <span class="keyword">if</span> index1 == m:</span><br><span class="line">                    <span class="keyword">return</span> nums2[index2+k-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> index2 == n:</span><br><span class="line">                    <span class="keyword">return</span> nums1[index1+k-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> k==<span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">min</span>(nums1[index1], nums2[index2])</span><br><span class="line"></span><br><span class="line">                newIndex1 = <span class="built_in">min</span>(index1 + k//<span class="number">2</span> -<span class="number">1</span>, m-<span class="number">1</span>)</span><br><span class="line">                newIndex2 = <span class="built_in">min</span>(index2 + k//<span class="number">2</span> -<span class="number">1</span>, n-<span class="number">1</span>)</span><br><span class="line">                privot1,privot2 =nums1[newIndex1], nums2[newIndex2]</span><br><span class="line">                <span class="keyword">if</span> privot1&lt;=privot2:</span><br><span class="line">                    k-=newIndex2-index1 +<span class="number">1</span></span><br><span class="line">                    index1 = newIndex2 + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    k -= newIndex2 - index2 +<span class="number">1</span></span><br><span class="line">                    index2 = newIndex2 +<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        m,n = <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">        totalLength = m+n</span><br><span class="line">        <span class="keyword">if</span> totalLength % <span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> getKthElemnt((totalLength+<span class="number">1</span>)//<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (getKthElemnt(totalLength//<span class="number">2</span>)+ getKthElemnt(totalLength//<span class="number">2</span>+<span class="number">1</span>)) /<span class="number">2</span> </span><br><span class="line">          </span><br><span class="line">    <span class="comment"># 划分数组</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span>(<span class="params">self, nums1: List[<span class="built_in">int</span>], nums2: List[<span class="built_in">int</span>]</span>) -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums1) &gt; <span class="built_in">len</span>(nums2):</span><br><span class="line">            <span class="keyword">return</span> self.findMedianSortedArrays(nums2, nums1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        infinty = <span class="number">2</span>**<span class="number">40</span>  <span class="comment"># 代表正无穷</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">        left, right = <span class="number">0</span>, m</span><br><span class="line">        <span class="comment"># median1：前一部分的最大值</span></span><br><span class="line">        <span class="comment"># median2：后一部分的最小值</span></span><br><span class="line">        median1, median2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right: <span class="comment"># 一直循环找到一个最大的i满足A[i−1]≤B[j]</span></span><br><span class="line">            <span class="comment"># 前一部分包含 nums1[0 .. i-1] 和 nums2[0 .. j-1]</span></span><br><span class="line">            <span class="comment"># // 后一部分包含 nums1[i .. m-1] 和 nums2[j .. n-1]</span></span><br><span class="line">            i = (left + right) // <span class="number">2</span></span><br><span class="line">            j = (m + n + <span class="number">1</span>) // <span class="number">2</span> - i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment"># nums_im1, nums_i, nums_jm1, nums_j 分别表示 nums1[i-1], nums1[i], nums2[j-1], nums2[j]</span></span><br><span class="line">            <span class="comment"># 当一个数组不出现在前一部分时,对应的值为负无穷,就不会对前一部分的最大值产生影响</span></span><br><span class="line">            nums_im1 = (-infinty <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">else</span> nums1[i - <span class="number">1</span>]) <span class="comment"># 注意写法与java不同</span></span><br><span class="line">            <span class="comment"># 当一个数组不出现在后一部分时,对应的值为正无穷,就不会对后一部分的最小值产生影响</span></span><br><span class="line">            nums_i = (infinty <span class="keyword">if</span> i == m <span class="keyword">else</span> nums1[i])</span><br><span class="line">            nums_jm1 = (-infinty <span class="keyword">if</span> j == <span class="number">0</span> <span class="keyword">else</span> nums2[j - <span class="number">1</span>])</span><br><span class="line">            nums_j = (infinty <span class="keyword">if</span> j == n <span class="keyword">else</span> nums2[j])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> nums_im1 &lt;= nums_j:</span><br><span class="line">                median1, median2 = <span class="built_in">max</span>(nums_im1, nums_jm1), <span class="built_in">min</span>(nums_i, nums_j)</span><br><span class="line">                left = i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = i - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (median1 + median2) / <span class="number">2</span> <span class="keyword">if</span> (m + n) % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> median1</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/"></a></h4><p><img src="https://i.loli.net/2021/09/15/roqxyuNvdGnAlX7.jpg" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;4-三种方法彻底解决中位数问题&quot;&gt;&lt;a href=&quot;#4-三种方法彻底解决中位数问题&quot; class=&quot;headerlink&quot; title=&quot;4-三种方法彻底解决中位数问题&quot;&gt;&lt;/a&gt;4-三种方法彻底解决中位数问题&lt;/h1&gt;&lt;h4 id=&quot;4-寻找两个正序数组的中位</summary>
      
    
    
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Multimodal Emergent Fake News Detection via Meta Neural Process Networks</title>
    <link href="http://example.com/2021/09/11/Multimodal-Emergent-Fake-News-Detection-via-Meta-Neural-Process-Networks/"/>
    <id>http://example.com/2021/09/11/Multimodal-Emergent-Fake-News-Detection-via-Meta-Neural-Process-Networks/</id>
    <published>2021-09-11T12:20:00.000Z</published>
    <updated>2021-09-20T15:00:07.742Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Multimodal-Emergent-Fake-News-Detection-via-Meta-Neural-Process-Networks"><a href="#Multimodal-Emergent-Fake-News-Detection-via-Meta-Neural-Process-Networks" class="headerlink" title="Multimodal Emergent Fake News Detection via Meta Neural Process Networks"></a>Multimodal Emergent Fake News Detection via Meta Neural Process Networks</h1><p>基于深度学习的模型在对感兴趣事件的大量标注数据进行训练时表现出较好的性能，而在其他事件上由于领域漂移的影响，模型的性能往往会下降。此外，添加来自新出现的事件的知识需要从头开始构建新的模型或继续微调模型，这对于现实世界的设置来说是不切实际的。（需新注入知识）</p><p>假新闻通常出现在新到的活动上，我们很难及时获得足够的帖子。在突发事件的早期阶段，我们通常只有少数相关的验证帖子。 如何利用一小部分经过验证的帖子来使模型快速学习。(few-shot挑战)</p><p>本文作者提出 MetaFEND 将元学习(meta learning)和神经过程(np)方法集成在一起解决此类问题。 还提出了标签嵌入模块和硬注意机制，通过处理分类信息和修剪无关帖子来提高效率。</p><p>MetaFEND的目标是：调整参数以更好地利用给定的支持数据点作为条件。</p><h2 id="Limitations-of-Current-Techniques"><a href="#Limitations-of-Current-Techniques" class="headerlink" title="Limitations of Current Techniques"></a>Limitations of Current Techniques</h2><p>few-shot learning 是一种为了克服利用一小部分数据实例进行快速学习。</p><p>元学习是一种促进few-shot learning的研究路线，其基本思想是利用以前任务中的全局知识来促进新任务的学习。然而，现有元学习方法的成功与一个重要的假设高度相关：任务来自相似的分布，共享的全局知识适用于不同的任务。这种假设在假新闻识别问题中通常不成立，因为不同事件新闻的写作风格、内容、词汇量甚至类别分布往往不尽相同。</p><p>如下图假新闻在事件中的比例明显不同。</p><p><img src="https://i.loli.net/2021/09/18/iFMmdJVBwKY8tNA.png" alt=""></p><p>不同事件之间的显著差异对事件异构性提出了严峻的挑战，这不能简单地通过全局共享知识来解决</p><p>另一个少机会学习的研究方向是 neural processes [Attentive neural processes]，它使用一小部分数据实例作为条件进行推理。尽管神经过程表现出更好的泛化能力，但它们基于一组固定的参数，并且通常受到欠拟合等限制，从而导致性能不令人满意。</p><p>这两种模型的研究思路是相辅相成的：</p><ul><li>元学习中的参数自适应机制可以提供更多的参数灵活性，以缓解神经过程的不匹配问题。</li><li>neural processes 可以使用一小部分数据实例作为条件，而不是将所有信息编码到参数集中，从而帮助应对MAML的异构性挑战。</li></ul><p>尽管将这两种流行的小范围方法集成在一起是有希望的，但在给定的小数据实例集上的不兼容操作是基于这两种方法开发模型的主要障碍。</p><h2 id="BACKGROUND"><a href="#BACKGROUND" class="headerlink" title="BACKGROUND"></a>BACKGROUND</h2><p>假新闻定义为故意编造的、可以查证为虚假的新闻。</p><p>作者的目标是利用从过去事件中学到的知识，通过几个例子对新发生的事件进行有效的假新闻检测。更正式地，我们将假新闻检测定义为紧随少镜头问题。</p><p>设 $E$ 表示一组新闻事件。在每个新闻事件$e∼E$中，有一些关于这事件$e$的带标签的贴子。</p><p>在培训阶段的每一集中，标记的帖子被划分为两个独立的集合：support set和query set 。 利用support set对模型进行训练，学习如何对query set 进行假新闻检测</p><p>supprt set : ${X<em>e^s, Y_e^s} = {x</em>{e,i}^s, y^s<em>{e,i}}</em>{i=1}^K$</p><p>query set  : ${X<em>e^q,Y_e^q} = {x</em>{e,i}^q, y<em>{e,i}^q}</em>{i=K+1}^N$ </p><p>在推理阶段，为每个事件提供带有 $K$ 个标签的帖子。该模型利用其对应的K个标签帖子作为支持集，对给定事件e进行假新闻检测。</p><h3 id="MAML"><a href="#MAML" class="headerlink" title="MAML"></a>MAML</h3><p>元学习过程分为两个阶段：元训练和元测试。</p><p>在元训练阶段，基线模型 $f<em>{\theta}$ 借助于支持集，根据具体事件 e 进行调整。例如一个事件的具体模型$f</em>{\theta<em>e}$ 在对应的query set上被评估，loss $L(f</em>{\theta<em>e}, {X_e^q,Y_e^q})$  在 ${X_e^q,Y_e^q}$ 被用于更新基线模型 $f</em>{\theta}$。 </p><p>在元测试阶段，基线模型 $f<em>\theta$ 根据事件$e’$进行调整，使用元训练阶段过程中获取的特定于事件的参数$\theta_e’$，用于对事件$e’$的查询集 ${X</em>{e’}^q,Y_{e’}^q}$ 进行预测。</p><p>MAML更新参数向量 $\theta$ 使用事件 $e$ 上的一个或多个梯度下降更新。例如，使用一个梯度更新时：</p><script type="math/tex; mode=display">\theta_e = M(f_{\theta}, \{X_e^s,Y_e^s\}) = \theta - \alpha \nabla_{\theta} L(f_{\theta}, \{X_e^s,Y_e^s\})</script><p>通过优化模型的性能来训练模型参数关于 $\theta$ 跨从中采样的事件$p(E)$。更具体地说，元目标如下：</p><script type="math/tex; mode=display">min_{\theta} \sum_{e \sim E} L(f_{\theta_i}) = \sum_{e \sim E} L(f_{\theta-\alpha L(f_{\theta,\{X_e^s,Y_e^s\}})}, {X_e^q,Y_e^q})</script><h3 id="Limitations-of-MAML"><a href="#Limitations-of-MAML" class="headerlink" title="Limitations of MAML"></a>Limitations of MAML</h3><p>MAML可以通过一个和几个梯度更新捕捉任务不确定性。然而，在虚假新闻检测中问题是，当事件是异构的时，事件不确定性很难通过一个或多个梯度步骤编码到参数中。</p><p>此外，即使给定的支持数据和感兴趣的查询数据来自同一事件，也不能保证它们都高度相关。在这种情况下，支持集上假新闻检测损失的参数自适应可能会对某些帖子产生误导。</p><h3 id="Conditional-Neural-Process-CNP"><a href="#Conditional-Neural-Process-CNP" class="headerlink" title="Conditional Neural Process (CNP)"></a>Conditional Neural Process (CNP)</h3><p>CNP包括四个主要部分：编码器、特征提取器、聚合器和解码器。这个条件神经过程的基本思想借助 ${X<em>e^s,Y_e^s} = {x</em>{e,i}^s,y<em>{e,i}^s}^K</em>{i=1}$ 作为上下文进行预测。</p><script type="math/tex; mode=display">p(y_{e,i}^q| \{X_e^s,Y_e^s\}, x_{e,i}^q) = f(agg(g(\{X_e^s,Y_e^s\}))  \oplus h(x_{e,i}^q))</script><h3 id="Limitations-of-CNP"><a href="#Limitations-of-CNP" class="headerlink" title="Limitations of CNP"></a>Limitations of CNP</h3><p>CNP的一个广泛认可的限制是欠拟合。对于不同的上下文数据点，它们在预测中的重要性通常是不同的。然而，CNP的聚合器对所有支持数据一视同仁，无法获得依赖于查询的上下文信息。此外，CNP只是将帖子的输入特征和数字标签值连接在一起作为输入，而忽略标签的分类特征。</p><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><p>提出了一种 meta neural process框架，它可以通过模拟任务将元学习方法和神经过程方法融合在一起。</p><p>为了应对异构新闻事件带来的挑战，我们进一步提出了一个标签嵌入组件来处理分类标签，以及一个hard attention件，该组件可以从具有不平衡类分布的支持集中选择信息量最大的信息。</p><p><img src="https://i.loli.net/2021/09/20/HOkN9KbidLxR37y.png" alt=""></p><h3 id="Meta-learning-Neural-Process-Design"><a href="#Meta-learning-Neural-Process-Design" class="headerlink" title="Meta-learning Neural Process Design"></a>Meta-learning Neural Process Design</h3><p>提出的框架包括两个阶段：</p><ul><li>事件适应：事件适应阶段是在支持集的帮助下，使模型参数适应特定事件。</li><li>事件监测：检测阶段是在支持度和自适应参数集的帮助下，检测给定事件的假新闻。</li></ul><h4 id="事件适应"><a href="#事件适应" class="headerlink" title="事件适应"></a>事件适应</h4><p>第i个support data ${x<em>{e,i}^s,y</em>{e,i}^s}$ 是一个例子，在事件适应阶段，${x<em>{e,i}^s,y</em>{e,i}^s}$ 被用作目标数据，剩余的support set ${X<em>e^s,Y_e^s} \setminus {x</em>{e,i}^s, y_{e,i}^s}$  ，被用于上下文集，$\setminus$是差集的意思。</p><p>在support set上事件适应目标函数：</p><script type="math/tex; mode=display">L_e^s = \sum_i log p_{\theta}(y_{e,i}^s| \{X_e^s,Y_e^s\} \setminus \{x_{e,i}^s,y_{e,i}^s\}, x_{e,i}^s)</script><p>然后，我们在 $L_e^s$ 上为事件 e 更新参数 $\theta$ 。一个或多个梯度下降更新。例如，使用一个梯度更新时：</p><script type="math/tex; mode=display">\theta_e = \theta - \alpha \nabla_{\theta} L_{e}^s</script><h4 id="识别阶段"><a href="#识别阶段" class="headerlink" title="识别阶段"></a>识别阶段</h4><p>提出的模型具有特定事件参数集 $\theta_e$ , 获取query set $X_e^q$ 和整个support set ${X_e^s,Y_e^s}$ 作为输入和输出预测 $\hat Y_e^q $对于 query set $X_e^q$ 。 对应识别阶段的loss：</p><script type="math/tex; mode=display">L_e^q = log p_{\theta_e} (Y_e^q | X_e^s,Y_e^s,X_e^q)</script><p>通过这个元神经过程，我们可以学习一个初始化参数集，该参数集可以快速地学习使用给定的上下文输入输出作为条件条件来检测关于新到达事件的假新闻。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Multimodal-Emergent-Fake-News-Detection-via-Meta-Neural-Process-Networks&quot;&gt;&lt;a href=&quot;#Multimodal-Emergent-Fake-News-Detection-via-Meta</summary>
      
    
    
    
    
    <category term="context detection" scheme="http://example.com/tags/context-detection/"/>
    
  </entry>
  
  <entry>
    <title>11-盛最多的水的容器</title>
    <link href="http://example.com/2021/09/11/11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E7%9A%84%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <id>http://example.com/2021/09/11/11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E7%9A%84%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</id>
    <published>2021-09-11T01:32:00.000Z</published>
    <updated>2021-09-22T01:47:30.447Z</updated>
    
    <content type="html"><![CDATA[<h1 id="11-盛最多的水的容器"><a href="#11-盛最多的水的容器" class="headerlink" title="11-盛最多的水的容器"></a>11-盛最多的水的容器</h1><h4 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/">11. 盛最多水的容器</a></h4><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h3 id="双指针的思想来源"><a href="#双指针的思想来源" class="headerlink" title="双指针的思想来源"></a>双指针的思想来源</h3><p>双指针大多都是对两层循环的优化，所以当暴力法设计到两层循环遍历的时候，我们就应该有这种思想：能不能用双指针。</p><p>其次，就是要有限制的满足条件，对于本题而言，限制的满足条件就是 每次移动数字较小的那个指针，我们必须根据题目找到某个条件，而这个条件就是双指针的移动条件，也就是双指针思想的基础。</p><h3 id="双指针移动的条件"><a href="#双指针移动的条件" class="headerlink" title="双指针移动的条件"></a>双指针移动的条件</h3><p>要找到这个条件，我们就需要从题目的定义出发，也就是容纳的水量的含义，当左右指针分别指向数组的左右两端，那么， 容纳的水量 = 两个指针指向的数字中较小的值 x 指针之间的距离。</p><p>接下来就只要考虑移动双指针后两者的变化情况即可。如果我们移动数字较大的那个指针，那么前者 【两个指针指向的数字中较小值】不会增加，后者 【指针之间的距离】会减小，那么这个成绩会减小。因此，我们移动数字较小的那个指针，这是从公式变化角度解释如何移动指针的</p><h3 id="双指针合理性的证明"><a href="#双指针合理性的证明" class="headerlink" title="双指针合理性的证明"></a>双指针合理性的证明</h3><p>双指针的含义：</p><ul><li>双指针代表的是，可以作为容器边界的所有位置的范围</li><li>在一开始，双指针指向数组的左右边界，表示数组中所有的位置都可以作为容器的边界。</li><li>在这之后，我们每次将，对应的数字较小的那个指针往另一个指针的方向移动一个位置，就表示我吗任务 这个指针不再能作为容器的边界了。</li></ul><h3 id="两个优化点"><a href="#两个优化点" class="headerlink" title="两个优化点"></a>两个优化点</h3><ul><li>当任意一边移动后，如果高度低于之前的高度，那么继续移动就行，不需要计算面积和比对两步多余操作。</li><li>两边相等时，可以同时移动左右边界，相等的时候，两边界都是瓶颈，就算只移动一侧，移动后得到的容器也受之前瓶颈的影响而只会减小，所以如果想得到更大的容积，同时移动两侧就可以了（同时跳过瓶颈）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span>(<span class="params">self, height: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(height) - <span class="number">1</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            area = <span class="built_in">min</span>(height[l], height[r]) * (r - l)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, area)</span><br><span class="line">            <span class="keyword">if</span> height[l] &lt;= height[r]:  <span class="comment"># 移动较小的那一端</span></span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> area = Math.min(height[l], height[r]) * (r - l);</span><br><span class="line">            ans = Math.max(ans, area);</span><br><span class="line">            <span class="keyword">if</span> (height[l] &lt;= height[r]) &#123;  <span class="comment">// 移动较小的那一端</span></span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                --r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/09/22/FvEY1UzIbAVuZan.jpg" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;11-盛最多的水的容器&quot;&gt;&lt;a href=&quot;#11-盛最多的水的容器&quot; class=&quot;headerlink&quot; title=&quot;11-盛最多的水的容器&quot;&gt;&lt;/a&gt;11-盛最多的水的容器&lt;/h1&gt;&lt;h4 id=&quot;11-盛最多水的容器&quot;&gt;&lt;a href=&quot;#11-盛最多水</summary>
      
    
    
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>1-两数之和到四数之和</title>
    <link href="http://example.com/2021/09/11/1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%E5%88%B0%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://example.com/2021/09/11/1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%E5%88%B0%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</id>
    <published>2021-09-11T01:32:00.000Z</published>
    <updated>2021-09-27T01:17:30.009Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-两数之和到四数之和"><a href="#1-两数之和到四数之和" class="headerlink" title="1-两数之和到四数之和"></a>1-两数之和到四数之和</h1><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p>示例 1：</p><p>输入：nums = [2,7,11,15], target = 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。<br>示例 2：</p><p>输入：nums = [3,2,4], target = 6<br>输出：[1,2]<br>示例 3：</p><p>输入：nums = [3,3], target = 6<br>输出：[0,1]</p><h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><h3 id="哈希表法"><a href="#哈希表法" class="headerlink" title="哈希表法"></a>哈希表法</h3><p>哈希表的方法首先用在了两数之和(无序数组)上, 哈希表的使用最主要的目的就是为了降低时间复杂度, 缩减寻找第二个元素使用的时间(将时间复杂度由O(n)降为O(1)), 其中无序数组是哈希表使用的重要条件, 因为当数组有序后, 我们完全可以直接使用 双指针 的方法来降低时间复杂度, 它的使用比 哈希表 更加方便快捷, 空间复杂度也更低, 所以数组有序之后, 我们应该首选 双指针 的方法.</p><p>在使用哈希表的时候, 也有一个很重要的优化点, 就是 遍历两遍哈希表 和 遍历一遍哈希表 的区别. 简单来说就是, 如果我们先将第一个元素放入哈希表中, 然后再寻找第二个元素, 那么我们就需要 遍历两遍哈希表, 如果我们先寻找第二个元素, 之后再将元素放入到哈希表中, 那么就只需要 遍历一遍哈希表.</p><p><img src="https://i.loli.net/2021/09/11/vUaHFiVBCbOrKlx.jpg" alt=""></p><p>上面是我们第一次使用哈希表的情况, 第二次使用哈希表就到了 《四数之和II四数组相加》, 首先由于它具有四个独立的数组, 相当于四维空间, 所以我们很难在这么高的空间维度上直接使用 双指针 的方法, 其次它并没有要求 不重复元组 的情况, 这就给了我们使用 哈希表 的可能性, 因为不用担心复杂的去重操作, 但是使用哈希表一般也是两维的空间, 所以我们必须先进行降维操作, 也就是将四个数组进行分组, 由三种结果的时间复杂度来判断, 我们很容易就选择了 两两分组 的情况.</p><p><img src="https://i.loli.net/2021/09/11/Gi9Cge7pl1Uuhm5.jpg" alt=""></p><p>之后对于哈希表的使用, 就是两种不同情况的使用了。如果需要直接返回相应数组的下标值, 那是很简单的, 我们只需要将 下标值 当做 哈希表的值 即可。(两数之和中的使用)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)&#123;</span><br><span class="line">  Map&lt;Integer,Integer&gt; map = HashMap&lt;Integer,Integer&gt;();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(map.containsKey(target - nums[i]))&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(target-nums[i]), i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        hashtable = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> i,num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">          <span class="keyword">if</span> target - num <span class="keyword">in</span> hashtable:</span><br><span class="line">              <span class="keyword">return</span> [hashtable[target-nums], i]</span><br><span class="line">            hashtable[num] = i</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>对于n数之和, 除了哈希表的方法, 最常用的就是 双指针 的方法了, 上文也提到了, 使用双指针最重要的条件就是数组是有序的, 当然这只是针对n数之和的题型, 对于其他题型, 并不需要要求数组是有序</p><p>在n数之和中使用双指针必要条件就是数组是有序的, 这就需要我们根据实际情况来判断 数组是否需要进行排序. 比如在 两数之和 中, 就算使用暴力法也才$O(n^2)$, 但进行排序最快也需要$O(nlogn)$的时间复杂度, 所以对于两数之和来说, 是真的没必要.</p><p>但是对于 三数之和 和 四数之和 就很有必要了, 因为它们时间复杂度实在太高了, 最关键的是它们元组的重复情况也比较多, 想利用哈希表进行去重是非常困难的, 最终只能选择将数组排序后使用 双指针 的方法.</p><h4 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a></h4><p><img src="https://z3.ax1x.com/2021/09/11/hxu1ER.png" alt=""></p><h4 id="两数之和中有序和无序的区别"><a href="#两数之和中有序和无序的区别" class="headerlink" title="两数之和中有序和无序的区别"></a>两数之和中有序和无序的区别</h4><p>在无序数组中寻找第二个数就没有多少捷径, 毕竟数组无序, 很多经典的方法都用不上, 最后只能牺牲空间来换取时间, 利用哈希表将空间复杂度增加到了$O(n)$, 从而降低了寻找第二个数的时间复杂度.</p><p>但是当数组有序之后, 就能使用一些经典的算法同时仍然保证空间复杂度为O(1), 不需要牺牲空间来换取时间, 比如下面马上介绍的 二分法 和 双指针 方法.</p><p>这里给我们提供了一种思维, 那我们是不是也可以将无序数组先进行排序后, 再使用这些经典算法呢? 当然可以这么做, 但对于两数之和来说, 必要性不是太大. 因为最快的排序算法也需要O(nlogn)的时间复杂度, 对于两数之和确实提升也不是太大, 但是对于 三数之和/四数之和 还是挺实用的, </p><h4 id="二分法和寻找插入位置的区别"><a href="#二分法和寻找插入位置的区别" class="headerlink" title="二分法和寻找插入位置的区别"></a>二分法和寻找插入位置的区别</h4><p>数组有序了，使用二分法寻找第二个数可以将时间复杂度降到$O(nlogn)$ 。</p><p>寻找插入位置无论，最终无论是否找到目标值，返回的位置结果都是相同的，而且题中说明数组中无重元素，保证了返回位置的唯一性，所以最终 left == right == mid，返回哪个都无所谓，也并不是需要特殊的将等于目标值这种情况单独写出来。所以代码只讨论了两种情况，最终返回一个值，非常简洁。</p><p>本题使用的二分法，首先并没有要求数组无重复元素，其次我们要的是具体的等于目标值的位置，并不是寻找插入位置，所以在找不到的情况下，只能返回[-1,-1]。首先的返回结果就有了两种情况.</p><p>其次由于有重复元素的存在, 若直接使用之前的只讨论两种情况的二分法是会出错的, 这里必须要讨论三种情况, 且在相等的情况下直接返回正确的结果, 在找不到的情况下返回 [-1, -1].</p><p>本题另外的一个小的注意点是: 返回的下标从1开始, 只要在原本的返回结果上+1就可以了.</p><p>还有一个注意点是, 为了避免重复寻找,在寻找第二个数时,只在第一个数的右侧寻找, 也就是left = i+1.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="comment"># 二分法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, numbers, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type numbers: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(numbers)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            left, right = i+<span class="number">1</span>, n  <span class="comment"># 采用左闭右开区间[left, right), left+1避免重复</span></span><br><span class="line">            <span class="keyword">while</span> left&lt;right:</span><br><span class="line">                mid = (right - left) //<span class="number">2</span> + left; <span class="comment"># 防止溢出</span></span><br><span class="line">                <span class="keyword">if</span> numbers[mid] == target - numbers[i]: <span class="comment"># 数组中存在重复元素，必须判断相等</span></span><br><span class="line">                    <span class="keyword">return</span> [i+<span class="number">1</span>, mid+<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">elif</span> numbers[mid] &gt; target - numbers[i]:</span><br><span class="line">                    right = mid <span class="comment"># 右开，真正右端点为mid-1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span> <span class="comment"># 左闭，所以小+1</span></span><br><span class="line">        <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 双指针</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum1</span>(<span class="params">self, numbers, target</span>):</span></span><br><span class="line">        low, high =<span class="number">0</span>, <span class="built_in">len</span>(numbers-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">while</span> low&lt;high:</span><br><span class="line">            total = numbers[low] + numbers[high]</span><br><span class="line">            <span class="keyword">if</span> total == target:</span><br><span class="line">                <span class="keyword">return</span> [low+<span class="number">1</span>, high+<span class="number">1</span>] <span class="comment"># 返回下标从1开始</span></span><br><span class="line">            <span class="keyword">elif</span> total&lt;target:</span><br><span class="line">                low+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high-=<span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 二分法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = i+<span class="number">1</span>, rigth = numbers.length;  <span class="comment">// 采用左闭右开区间[left,right),left+1避免重复</span></span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                mid = left + right /<span class="number">2</span> + left; <span class="comment">// 防止溢出</span></span><br><span class="line">                <span class="keyword">if</span>(numbers[mid] == target - numbers[i])&#123; <span class="comment">// 数组中存在重复元素,必须判断相等</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i+<span class="number">1</span>, mid+<span class="number">1</span>&#125; ; <span class="comment">// 返回的下标从1开始,都+1</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(numbers[mid] &gt; target-numbers[i])&#123; <span class="comment">//中点大于目标值,在左侧</span></span><br><span class="line">                    right = mid;<span class="comment">//右开，真正右端点为mid-1</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    left = mid+<span class="number">1</span>; <span class="comment">// 左闭 +1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 双指针法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum2(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target)&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = numbers.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123; <span class="comment">// 指针移动条件</span></span><br><span class="line">            <span class="keyword">int</span> sum = numbers[low] + numbers[high];</span><br><span class="line">            <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;low + <span class="number">1</span>, high + <span class="number">1</span>&#125;; <span class="comment">// 返回下标从1开始</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                ++low;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                --high;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><h4 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></h4><p><img src="https://i.loli.net/2021/09/12/6x3jq9QeCmGfa2B.jpg" alt=""></p><p>难点在于题目要求的不重复的三元组，它的可重复情况是非常多的，无法像两数之和那样，只要将第一个元素放入哈希表中，就可以轻松解决元素重复的问题了。</p><p>对于三数之和，即使使用哈希表去重，它的操作也是比较困难的，所以不能简单的使用三重循环枚举所有的三元组，然后用哈希表去重，这样工作量比较大。</p><p>因此必须换一种做法，从源头上解决元素重复问题，如果给定数组是有序的，那么其中可重复的情况就是可控的了，处理起来也简单，所以先把数组从小到大排序，随后用普通的三重循环就可。</p><p>然后就会发现，重复的元素都是相邻元素，只要保证每一重循环时，相邻两次枚举的元素不是相同的元素，这样就可以避免元组重复的情况了。</p><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>使用普通的三层循环确实也能解决问题, 但是 $O(n^3)$ 的时间复杂度也确实太高了, 这时我们想到了在 有序数组的两数之和 中使用的双指针的方式, 虽然现在是三数之和, 但当我们正常遍历了第一层循环之后, 剩下的两个数不就形成了 有序数组的两数之和 了吗? 所以我们只要 保持第二重循环不变, 而将第三重循环变成一个从数组最右端开始向左移动的指针, 同时加上上述讨论的避免重复的条件, 最终代码就完成了.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">0</span> ||  (nums[<span class="number">0</span>]==<span class="number">0</span> &amp;&amp; nums.length==<span class="number">1</span>))  <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 枚举a</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> first=<span class="number">0</span>;first&lt;nums.length;first++)&#123;</span><br><span class="line">            <span class="comment">//需要和上一次枚举的数不同</span></span><br><span class="line">            <span class="keyword">if</span>(first&gt;<span class="number">0</span> &amp;&amp; nums[first] == nums[first-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// c对应的指针初始指向数组的最右排</span></span><br><span class="line">            <span class="keyword">int</span> third = nums.length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> target = -nums[first];</span><br><span class="line">            <span class="comment">//枚举b</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> second= first+<span class="number">1</span> ;second&lt;nums.length;second++)&#123;</span><br><span class="line">                <span class="comment">// 需要和上一次枚举不同</span></span><br><span class="line">                <span class="keyword">if</span>(second &gt; first+<span class="number">1</span> &amp;&amp; nums[second] == nums[second-<span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 需要保证b指针在c指针的左侧</span></span><br><span class="line">                <span class="keyword">while</span>(second &lt; third &amp;&amp; nums[second]+nums[third] &gt; target)&#123;</span><br><span class="line">                    --third;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果指针重合，后续也不会满足条件，可以退出循环</span></span><br><span class="line">                <span class="keyword">if</span>(second==third) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (nums[second] + nums[third] == target)&#123;</span><br><span class="line">                    res.add(Arrays.asList(nums[first],nums[second],nums[third]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>: <span class="keyword">return</span> res</span><br><span class="line">        nums.sort()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 枚举a</span></span><br><span class="line">        <span class="keyword">for</span> first <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> first&gt;<span class="number">0</span> <span class="keyword">and</span> nums[first] == nums[first-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            thrid = <span class="built_in">len</span>(nums) -<span class="number">1</span></span><br><span class="line">            target = -nums[first]</span><br><span class="line">            <span class="keyword">for</span> second <span class="keyword">in</span> <span class="built_in">range</span>(first+<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> second&gt; first+<span class="number">1</span> <span class="keyword">and</span> nums[second] == nums[second-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">while</span> second&lt;thrid <span class="keyword">and</span> nums[second] + nums[thrid] &gt; target:</span><br><span class="line">                    thrid-=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> second==thrid:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> nums[second]+nums[thrid] == target:</span><br><span class="line">                    res.append([nums[first], nums[second], nums[thrid]])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br></pre></td></tr></table></figure><h2 id="三数之和变体"><a href="#三数之和变体" class="headerlink" title="三数之和变体"></a>三数之和变体</h2><h4 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a><a href="https://leetcode-cn.com/problems/3sum-closest/">16. 最接近的三数之和</a></h4><p>还是使用双指针解决</p><p>排序+双指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> best = <span class="number">10000000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举 a</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 保证和上一次枚举的元素不相等</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 使用双指针枚举 b 和 c</span></span><br><span class="line">            <span class="keyword">int</span> j = i + <span class="number">1</span>, k = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[j] + nums[k];</span><br><span class="line">                <span class="comment">// 如果和为 target 直接返回答案</span></span><br><span class="line">                <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> target;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 根据差值的绝对值来更新答案</span></span><br><span class="line">                <span class="keyword">if</span> (Math.abs(sum - target) &lt; Math.abs(best - target)) &#123;</span><br><span class="line">                    best = sum;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                    <span class="comment">// 如果和大于 target，移动 c 对应的指针</span></span><br><span class="line">                    <span class="keyword">int</span> k0 = k - <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 移动到下一个不相等的元素</span></span><br><span class="line">                    <span class="keyword">while</span> (j &lt; k0 &amp;&amp; nums[k0] == nums[k]) &#123;</span><br><span class="line">                        --k0;</span><br><span class="line">                    &#125;</span><br><span class="line">                    k = k0;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果和小于 target，移动 b 对应的指针</span></span><br><span class="line">                    <span class="keyword">int</span> j0 = j + <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 移动到下一个不相等的元素</span></span><br><span class="line">                    <span class="keyword">while</span> (j0 &lt; k &amp;&amp; nums[j0] == nums[j]) &#123;</span><br><span class="line">                        ++j0;</span><br><span class="line">                    &#125;</span><br><span class="line">                    j = j0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> best;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>时间复杂度：$O(N^2)$ 其中 N 是数组 $\textit{nums}$ 的长度。我们首先需要 $O(N \log N)$ 的时间对数组进行排序，随后在枚举的过程中，使用一重循环 O(N) 枚举 a，双指针 O(N) 枚举 b 和 c，故一共是 O(N^2)</p><p>空间复杂度：$O(\log N)$。排序需要使用 $O(\log N)$ 的空间。然而我们修改了输入的数组 $\textit{nums}$，在实际情况下不一定允许，因此也可以看成使用了一个额外的数组存储了 $\textit{nums}$ 的副本并进行排序，此时空间复杂度为 O(N)。</p><h2 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h2><h4 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a href="https://leetcode-cn.com/problems/4sum/">18. 四数之和</a></h4><p><img src="https://i.loli.net/2021/09/13/mxBF4fzwX9Crky5.jpg" alt=""></p><h3 id="思想同三数之和：排序-双指针"><a href="#思想同三数之和：排序-双指针" class="headerlink" title="思想同三数之和：排序+双指针"></a>思想同三数之和：排序+双指针</h3><p>四数之和 本质上 和三数之和一样的，由于都有大量的重复元素在，都不能使用哈希表进行简单的去重，都需要先进行排序后才方便遍历处理，同时为了优化时间复杂度，再加上双指针方法的使用，如果只是想简单实现的话，那么在三数之和上直接多加一重循环。但在代码上不同点在于：并非只是简单的家一重循环而已，而是进行了优化处理。</p><p>因为四数之和相比较于三数之和来说，情况更加复杂，时间复杂度也比较高，而且这个时间复杂度通过算法降下来很难。只能通过对代码的优化，直接减少大量不必要的遍历情况，从而来缩短代码的运行时间。</p><p>对于代码的优化主要分为两大块：一部分是为了避免出现重复的四元组，在遍历上的优化，这部分和三数之和相似，不过更复杂。</p><p>首先是对前两重循环进行的去重操作, 当 i 或者 j 的值与前面的值相等时忽略, 之后又对 双指针 进行了去重操作, 这里有个重要的注意点: 一定注意代码中是 先进行了指针的移动还是先进行了去重的比较, 对于不同的顺序, 比较的元素是完全不同的. 如果先进行了指针的移动, 对于左指针来说, 需要比较的元素就是 当前元素和前面的一个元素, 如果是先进行去重的比较, 那比较的元素就是 当前元素和后面的一个元素, 再进行指针的移动. 对于右指针的情况正好是完全相反的.</p><p>第二部分就是在循环遍历中先通过计算特定的四个数之和, 以此来判断接下来的循环操作情况.</p><p>比如 在确定第一个数 nums[i] 之后, 如果nums[i]+nums[i+1]+nums[i+2]+nums[i+3]&gt;target, 也就是此时的最小的4个数之和都大于target, 说明此时剩下的三个数无论取什么值, 四数之和一定大于 target, 因此直接退出第一重循环就可以了</p><p>在确定第一个数 nums[i] 之后,如果nums[i]+nums[n−3]+nums[n−2]+nums[n−1]&lt;target, 也就是此时的最大的4个数之和都小于target, 说明此时剩下的三个数无论取什么值, 四数之和一定小于 target,因此第一重循环直接进入下一轮, 枚举nums[i+1], 使用 continue 关键字.</p><p>对于第二层循环也是同样的判断方法, 通过这两层循环的判断优化, 能直接删去大量的不满足情况, 减少代码运行的时间. 这也能给我们带来启发, 在算法层面不能进行优化的时候, 可以选择对代码的细节进行优化, 同样可以起到节省时间的效果.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSum</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> length&lt;<span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="comment"># 定义4个指针i,j,left,right  i从0开始遍历,j从i+1开始遍历,留下left和right作为双指针</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length - <span class="number">3</span>):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]: <span class="comment"># 当i的值与前面的值相等时忽略</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 获取当前最小值,如果最小值比目标值大,说明后面越来越大的值根本没戏</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>] + nums[i + <span class="number">3</span>] &gt; target:</span><br><span class="line">                <span class="keyword">break</span> <span class="comment"># 这里使用的break,直接退出此次循环,因为后面的数只会更大</span></span><br><span class="line">            <span class="comment"># 获取当前最大值,如果最大值比目标值小,说明后面越来越小的值根本没戏,忽略</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] + nums[length - <span class="number">3</span>] + nums[length - <span class="number">2</span>] + nums[length - <span class="number">1</span>] &lt; target:</span><br><span class="line">                <span class="keyword">continue</span> <span class="comment"># 这里使用continue,继续下一次循环,因为下一次循环有更大的数</span></span><br><span class="line">            <span class="comment"># 第二层循环j,初始值指向i+1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, length - <span class="number">2</span>):</span><br><span class="line">                <span class="keyword">if</span> j &gt; i + <span class="number">1</span> <span class="keyword">and</span> nums[j] == nums[j - <span class="number">1</span>]: <span class="comment"># 当j的值与前面的值相等时忽略</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[j] + nums[j + <span class="number">1</span>] + nums[j + <span class="number">2</span>] &gt; target:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[j] + nums[length - <span class="number">2</span>] + nums[length - <span class="number">1</span>] &lt; target:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                left, right = j + <span class="number">1</span>, length - <span class="number">1</span></span><br><span class="line">                <span class="comment"># 双指针遍历,如果等于目标值,left++并去重,right--并去重,当当前和大于目标值时right--,当当前和小于目标值时left++</span></span><br><span class="line">                <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                    total = nums[i] + nums[j] + nums[left] + nums[right]</span><br><span class="line">                    <span class="keyword">if</span> total == target:</span><br><span class="line">                        res.append([nums[i], nums[j], nums[left], nums[right]])</span><br><span class="line">                        left += <span class="number">1</span> <span class="comment"># left先+1之后,和它前面的left-1进行比较,若后+1,则和它后面的left+1进行比较</span></span><br><span class="line">                        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] == nums[left - <span class="number">1</span>]:</span><br><span class="line">                            left += <span class="number">1</span></span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] == nums[right + <span class="number">1</span>]:</span><br><span class="line">                            right -= <span class="number">1</span>   </span><br><span class="line">                    <span class="keyword">elif</span> total &lt; target:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> length=nums.length;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义4个指针， i,j,left,right  i从0开始遍历，j从i+1开始遍历，留下left和right作为双指针</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length - <span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取当前最小值，如果最小值比目标值大，说明后面越来越大的值根本没戏</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] + nums[i+<span class="number">1</span>] + nums[i+<span class="number">2</span>] +nums[i+<span class="number">3</span>] &gt; target)&#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 这里使用的break，直接退出此次循环，因为后面的数只会更大</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取当前最大值，如果最大值比目标值小，说明后面的值越来越小</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] + nums[length-<span class="number">3</span>] + nums[length-<span class="number">2</span>] + nums[length-<span class="number">1</span>] &lt; target)&#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 继续下一次循环，因为下一次循环有更大的数</span></span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第二层循环j，初始值指向i+1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;length-<span class="number">2</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;i+<span class="number">1</span> &amp;&amp; nums[j] == nums[j-<span class="number">1</span>])&#123;  <span class="comment">// 当j的值与前面的值相等时忽略</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[j] + nums[j+<span class="number">1</span>] + nums[j+<span class="number">1</span>] &gt; target) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[j] + nums[length-<span class="number">2</span>] + nums[length-<span class="number">1</span>] &lt; target)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> left = j+<span class="number">1</span>, right=length-<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//双指针遍历，如果等于目标值，left++并去重，right--并去重，当当前和大于目标值时right-- 否则left++</span></span><br><span class="line">                <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                    <span class="keyword">if</span>(sum==target)&#123;</span><br><span class="line">                        res.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));</span><br><span class="line">                        left++; <span class="comment">// left先+1之后，和它前面的left-1进行比较，若后+1，则和它后面的left+1进行比较</span></span><br><span class="line">                        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left]==nums[left-<span class="number">1</span>])&#123;</span><br><span class="line">                            left++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        right--;</span><br><span class="line">                        <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[right]== nums[right+<span class="number">1</span>])&#123;</span><br><span class="line">                            right--;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;target)&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四数之和二"><a href="#四数之和二" class="headerlink" title="四数之和二"></a>四数之和二</h2><h4 id="454-四数相加-II"><a href="#454-四数相加-II" class="headerlink" title="454. 四数相加 II"></a><a href="https://leetcode-cn.com/problems/4sum-ii/">454. 四数相加 II</a></h4><p><img src="https://i.loli.net/2021/09/14/met83ga7UN9wGL2.jpg" alt=""></p><h3 id="维数太高，分治处理"><a href="#维数太高，分治处理" class="headerlink" title="维数太高，分治处理"></a>维数太高，分治处理</h3><p>此题一看似乎和四数之和差不多，但本质上却有很大的区别，首先无论是三数之和还是四数之和，它们都是在一个数组上的操作，本质上都是一维的，同时它们都要求找到不重复的元组，这就限制了我们不能简单的使用哈希表进行去重操作。最终只能将数组排序后使用双指针。</p><p>但本题是四个独立的数组，相当于是四个维度，想在四个维度上使用双指针的方法显然不现实。同时此题只要求我们找到所有4个元素的和为0的元组个数即可，并没有要求是不重复的元组，这样就简单了很多，也是可以使用哈希表法。</p><p>此题是在使用哈希表的时候，会遇到如下三种情况：</p><ul><li>hashmap存一个数组，如A。然后计算三个数组之和，如BCD。时间复杂度为：$O(n)+O(n^3)=O(n^3)$</li><li>hashmap存三个数组之和，如ABC。然后计算一个数组，如D。时间复杂度为：$O(n^3)+O(n) = O(n^3)$</li><li>hashmap存两个数组之和，如AB，然后计算两个数组之和，如CD，时间复杂度为：$O(n^2)+O(n^2) = O(n^2)$</li></ul><p>根据事件复杂度来看，选第三种情况</p><p>确定了使用的方法(哈希表)以及分类方法(两两分组)。此题和两数之和中使用的哈希表有很大的区别，在两数之和中，我们需要的是满足条件的下标值，所以在哈希表中存的是元组的下标值。</p><p>但在本题中，我们需要的是元组个数，所以哈希表中的值应存取出现的次数，这就有点难度。使用java map中的merge或getOrDefault</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span>[] C, <span class="keyword">int</span>[] D)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(A.length==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer,Integer&gt; countAB = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u: A)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> v:B)&#123;</span><br><span class="line">                <span class="comment">// 存储u+v的结果，不存在赋值为1，存在在原来基础上+1</span></span><br><span class="line">                <span class="comment">// 另一种表达countAB.merge(u+v, 1, (old,new_)-&gt; old+1);</span></span><br><span class="line">                countAB.put(u+v, countAB.getOrDefault(u+v, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u: C)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> v:D)&#123;</span><br><span class="line">                <span class="keyword">if</span>(countAB.containsKey(-u-v))&#123;</span><br><span class="line">                    res+=countAB.get(-u-v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSumCount</span>(<span class="params">self, A, B, C, D</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :type nums3: List[int]</span></span><br><span class="line"><span class="string">        :type nums4: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># Counter类是dict()子类，用于计数可哈希对象</span></span><br><span class="line">        <span class="comment"># 它是一个集合，元素字段键(key) 一样存储，他们的技术存储为值</span></span><br><span class="line">        countAB = collections.Counter(u+v <span class="keyword">for</span> u <span class="keyword">in</span> A <span class="keyword">for</span> v <span class="keyword">in</span> B)</span><br><span class="line">        ans = <span class="number">0</span> </span><br><span class="line">        <span class="keyword">for</span> u <span class="keyword">in</span> C:</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> D:</span><br><span class="line">                <span class="keyword">if</span> -u-v <span class="keyword">in</span> countAB:</span><br><span class="line">                    ans+=countAB[-u-v]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="n数之和方法总结"><a href="#n数之和方法总结" class="headerlink" title="n数之和方法总结"></a>n数之和方法总结</h2><p>对于两数之和，看它是否有序的，如果是无序的就用哈希表法，如果是有序的可以使用双指针。</p><p>对于一个数组上的三数之和、四数之和等，无论数组是否有序，都排序后使用双指针法</p><p>对于多个数组之和的情况，首先对它们进行分组来实现降维操作，一般来说分为两个相等的小组，之后再使用哈希表法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-两数之和到四数之和&quot;&gt;&lt;a href=&quot;#1-两数之和到四数之和&quot; class=&quot;headerlink&quot; title=&quot;1-两数之和到四数之和&quot;&gt;&lt;/a&gt;1-两数之和到四数之和&lt;/h1&gt;&lt;p&gt;给定一个整数数组 nums 和一个整数目标值 target，请你在该</summary>
      
    
    
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Model-Agnostic Meta-Learning for Fast Adaptation of Deep Networks</title>
    <link href="http://example.com/2021/09/10/Model-Agnostic-Meta-Learning-for-Fast-Adaptation-of-Deep-Networks/"/>
    <id>http://example.com/2021/09/10/Model-Agnostic-Meta-Learning-for-Fast-Adaptation-of-Deep-Networks/</id>
    <published>2021-09-10T11:15:31.000Z</published>
    <updated>2021-09-22T11:56:55.214Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Model-Agnostic-Meta-Learning-for-Fast-Adaptation-of-Deep-Networks"><a href="#Model-Agnostic-Meta-Learning-for-Fast-Adaptation-of-Deep-Networks" class="headerlink" title="Model-Agnostic Meta-Learning for Fast Adaptation of Deep Networks"></a>Model-Agnostic Meta-Learning for Fast Adaptation of Deep Networks</h1><p>MAML一种模型无关的元学习算法，即它可以与任何经过梯度下降训练的模型兼容，并适用于各种不同的学习问题，包括分类、回归和强化学习。</p><p>元学习的目标是在各种学习任务上训练一个模型，它只需要少量的训练样本就可以解决新的学习任务。</p><p>MAML模型的参数被显式地训练，使得少量的梯度步骤和来自新任务的少量训练数据将在该任务上产生良好的泛化性能，易于微调。</p><p>核心思想是训练模型的初始参数，以便在参数通过一个或多个梯度步骤更新后，模型在新任务上具有最大性能，该梯度步骤使用来自该新任务的少量数据计算。</p><p>这种快速灵活的学习是一种挑战，因为模型必须将其先前的经验与少量新信息相结合，同时避免过拟合新数据。此外，先验经验和新数据的形式将取决于任务。因此，为了获得最大的适用性，learn to learn (或元学习)的机制应该适用于任务和完成任务所需的计算形式。</p><h2 id="Model-Agnostic-Meta-Learning"><a href="#Model-Agnostic-Meta-Learning" class="headerlink" title="Model-Agnostic Meta-Learning"></a>Model-Agnostic Meta-Learning</h2><p>目标是训练能够实现快速适应的模型，这是一种通常被形式化为few-shot learning的问题设置。</p><h3 id="Meta-Learning-Problem-Set-Up"><a href="#Meta-Learning-Problem-Set-Up" class="headerlink" title="Meta-Learning Problem Set-Up"></a>Meta-Learning Problem Set-Up</h3><p>few-shot learning元学习的目标是训练一个只使用几个数据点和训练迭代就能快速适应新任务的模型。</p><p>实际上，元学习问题将整个任务视为训练示例。</p><p>定义一个模型为f，它将观测值 $x$ 映射到输出 $a$ 。在元学习期间，模型被训练成能够适应大量或无限数量的任务。</p><p>定义每个任务 $T =  {L(x<em>1,a_1,…,x_H,a_H) , q(x_1), q(x</em>{t+1}|x_t,a_t ), H}$</p><p>$L$ 是loss function，初始观测 $q(x<em>1)$ 的分布，通过$q(x</em>{t+1}|x_t,a_t)$ 转换分布，事件长度$H$</p><p>在独立同分布的有监督学习问题中，长度H=1。该模型可以通过在每个时间步 $t$ 选择一个输出来产生长度为 $H$ 的样本。Loss函数提供任务特殊的反馈。</p><p>在元学习场景中，我们考虑希望模型能够适应的任务$p(T)$上的分布。在 K-shot 学习设置中，该模型被训练成仅从$q<em>i$ 中提取的K个样本和由任务 $T_i$ 生成的反馈 $L</em>{T_i}$ 中学习 从$p(T)$中提取的新任务$T_i$。</p><p>在元训练过程中，从 $p(T)$ 中抽取一个任务 $T<em>i$，用K个样本训练模型，并从$T_i$中相应的$L</em>{T_i}$ 损失反馈，然后在$T_i$的新样品上进行测试。然后，通过考虑来自 $q_i$ 的新数据上的测试误差如何相对于参数变化来改进模型 $f$。</p><p>实际上，采样任务 $T_i$ 上的测试误差充当元学习过程的训练误差。在元训练 (meta-training)结束时，从$p(T)$采样新任务，从K个样本中学习后，通过模型的性能来衡量元性能(meta-performance)。一般来说，元测试 (meta-testing) 任务是在元训练 (meta-training) 期间执行的。</p><h3 id="A-Model-Agnostic-Meta-Learning-Algorithm"><a href="#A-Model-Agnostic-Meta-Learning-Algorithm" class="headerlink" title="A Model-Agnostic Meta-Learning Algorithm"></a>A Model-Agnostic Meta-Learning Algorithm</h3><p>我们怎样才能鼓励这种通用型代表的出现呢？例如，神经网络可能学习广泛适用于 $p(T)$ 中所有任务的内部特征，而不是单个任务。</p><p>MAML对这个问题采取了明确的方法：由于模型将在新任务上使用基于梯度的学习规则进行微调，因此我们的目标是学习一个模型，使此基于梯度的学习规则能够在从$p(T)$提取的新任务上取得快速进展，而不会过拟合。</p><p>实际上，我们的目标是找到对任务变化敏感的模型参数，以便参数的微小变化将在沿损失梯度方向改变时，对从 $p(T)$ 得出的任何任务的损失函数产生较大的改进。如下图：</p><p><img src="https://i.loli.net/2021/09/11/UE2pXjfwd81z4hb.png" alt=""></p><p>我们对模型的形式不做任何假设，只是假设它由一些参数向量 $θ$ 参数化，并且损失函数在 $θ$ 中足够平滑，因此我们可以使用基于梯度的学习技术。</p><p>定义这个参数化的模型为$f_{\theta}$ , 参数为$\theta$。 当适应一个新的任务$T_i$时，模型的参数 $θ$ 变为 $θ_i’$。</p><p>使用任务 $T_i$ 上的一个或多个梯度下降更新来计算更新后的参数向量 $θ_i’$。例如，当使用一个梯度更新时:</p><script type="math/tex; mode=display">\theta_i' = \theta - \alpha \nabla_{\theta}L_{T_i}(f_{\theta})</script><p>步长 $α$ 可以固定为超参数。</p><p>通过优化 $f_{θ_i’}$相对于从 $p(T)$ 采样的任务的 $θ$ 的性能，来训练模型参数。更具体地说，元目标如下：</p><script type="math/tex; mode=display">min_{\theta} \sum_{T_i\sim p(T)} L_{T_i}(f_{\theta_i'}) = \sum_{T_i\sim p(T)} L_{T_i}(f_{\theta - \alpha \nabla_{\theta}L_{T_i}(f_{\theta})})</script><p>注意，元优化 （meta-optimization）是在模型参数θ上执行的，而目标是使用更新后的模型参数 $θ’$来计算的。实际上，MAML提出的方法旨在优化模型参数，使得新任务上的一个或少量梯度步骤将在该任务上产生最有效的行为。</p><p>跨任务的元优化通过随机梯度下降（SGD），模型参数θ更新如下：</p><script type="math/tex; mode=display">\theta \leftarrow \theta - \beta \nabla_{\theta} \sum_{T_i \sim p(T)} L_{T_i}(f_{\theta_i’})</script><p>$β$ 是元步长。下图概述了一般情况下完整的算法：</p><p><img src="https://i.loli.net/2021/09/11/WxXC1fqEFamYi6n.png" alt=""></p><p>输入任务不同分布的任务$p(T)$ 和两个学习步长超参数 $\alpha, \beta$ ,并且随机初始化模型参数。</p><p>第一层循环，遍历每个任务 $T_i \sim p(T)$ 中采样的batch</p><p>第二层循环，在每个任务 $T<em>i$  中 评估关于 K 个样本的 $∇</em>θ L<em>{T_i}(f</em>θ)$  使用梯度下降计算自适应参数：$θ<em>i’ = θ − α\nabla</em>θL<em>{T_i}(f</em>θ)$</p><p>然后根据所有任务上的损失梯度更新模型的参数  $\theta \leftarrow \theta - \beta \nabla<em>{\theta} \sum</em>{T<em>i \sim p(T)} L</em>{T<em>i}(f</em>{\theta_i’})$</p><p>MAML元梯度更新涉及通过梯度的梯度, 在计算上，这需要额外的反向传播 $f$ 来计算Hessian-vector乘积。</p><h3 id="Species-of-MAML"><a href="#Species-of-MAML" class="headerlink" title="Species of MAML"></a>Species of MAML</h3><p>监督学习和强化学习的元学习算法的具体实例。他们在损失函数的形式以及数据由任务生成并呈现给模型的方式上不同。</p><h4 id="Supervised-Regression-and-Classification"><a href="#Supervised-Regression-and-Classification" class="headerlink" title="Supervised Regression and Classification"></a>Supervised Regression and Classification</h4><p><img src="https://i.loli.net/2021/09/11/w39XVGQOYhamNUk.png" alt=""></p><p>Few-shot 学习在监督任务领域得到了很好的研究，其目标是仅从该任务的几个输入/输出对中学习新函数，使用类似任务的先前数据进行元学习。</p><p>我们可以定义horizon H=1并将timestep下标放到 $x_t$上，因为模型接受单个输入并生成单个输出，而不是一系列输入和输出。</p><p>任务 $T_i$ 从 $q_i$生成K个观测值 $x$ ，并且任务损失由模型的输出 $x$ 与该观测值和任务对应的目标值 $y$ 之间的误差表示。</p><p>用于监督分类和回归的两种常见损失函数是交叉熵和均方误差(MSE)，对于使用均方误差的回归任务，损失形式为：</p><script type="math/tex; mode=display">L_{T_i}f(\phi) = \sum_{x^{(j)},y^{(y)} \sim T_i} ||f_{\phi}(x^{(j)}) - y^{(j)}||_2^2</script><p>其中 $x^{(j)}, y^{(j)}$ 是任务$T_i$的一对输入输出，类似地，对于具有交叉熵损失的离散分类任务，损失采取以下形式：</p><script type="math/tex; mode=display">L_{T_i}f(\phi)= \sum_{x^{(j)},y^{(y)} \sim T_i} y^{(j)} log f_{\phi}(x^{(j)}) + (1-y^{(j)})log(1-f_{\phi}(x^{(j)}))</script><h4 id="Reinforcement-Learning"><a href="#Reinforcement-Learning" class="headerlink" title="Reinforcement Learning"></a>Reinforcement Learning</h4><p><img src="https://i.loli.net/2021/09/11/Jx6hAWtNTHg9B2O.png" alt=""></p><p>在强化学习（RL）中，Few-shot 元学习的目标是使模型能够仅使用测试设置中的少量经验快速获取新测试任务的策略。</p><p>例如，一个模型可能会学习如何快速找到如何导航迷宫，以便在面对新的迷宫时，只需几个样本就可以确定如何可靠地到达出口。</p><p>每个RL 任务$T<em>i$ 包含一个初始化状态分布$q_i(x_1)$ 和一个转换分布 $q_i(x</em>{t+1}| x<em>i,a_t)$ , 损失函数为 $L</em>{T_i}$</p><p>因此，整个任务是一个具有horizon H的马尔可夫决策过程（MDP），在该过程中，学习者可以查询有限数量的样本轨迹以进行少量镜头学习。</p><p>MDP的任何方面都可以在 $p(T)$ 中的任务之间改变。正在学习的模型 $f_θ$ 是一个策略，它从状态 $x_t$映射到每个操作上的分布时间步长 $t∈{1，.，H}$。任务$T_i$ 的模型的损失:</p><script type="math/tex; mode=display">L_{T_i}(f_\phi) = -\mathbf{E} _{x_t,a_t\sim f_{\phi},q_{T_i}} [\sum_{t=1}^H R_i(x_t, a_t)]</script><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>MAML能实现新任务的快速学习吗？</p><p>MAML是否可以用于多个不同领域的元学习，包括有监督的回归、分类和强化学习？</p><p>用MAML学习的模型可以通过额外的渐变更新和/或示例继续改进吗？</p><p><img src="https://i.loli.net/2021/09/11/NRBL1JGZyIUeY9C.png" alt=""></p><p><img src="https://i.loli.net/2021/09/11/myPCEawdMIN1Yt2.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Model-Agnostic-Meta-Learning-for-Fast-Adaptation-of-Deep-Networks&quot;&gt;&lt;a href=&quot;#Model-Agnostic-Meta-Learning-for-Fast-Adaptation-of-Dee</summary>
      
    
    
    
    
    <category term="context detection" scheme="http://example.com/tags/context-detection/"/>
    
  </entry>
  
  <entry>
    <title>Dynamically Addressing Unseen Rumor via Continual Learning</title>
    <link href="http://example.com/2021/09/07/Dynamically-Addressing-Unseen-Rumor-via-Continual-Learning/"/>
    <id>http://example.com/2021/09/07/Dynamically-Addressing-Unseen-Rumor-via-Continual-Learning/</id>
    <published>2021-09-07T11:06:19.000Z</published>
    <updated>2021-09-07T13:28:32.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dynamically-Addressing-Unseen-Rumor-via-Continual-Learning"><a href="#Dynamically-Addressing-Unseen-Rumor-via-Continual-Learning" class="headerlink" title="Dynamically Addressing Unseen Rumor via Continual Learning"></a>Dynamically Addressing Unseen Rumor via Continual Learning</h1><p>谣言往往与新出现的事件联系在一起，因此，处理没见过的谣言的能力对于谣言真实性分类模型至关重要。</p><p>以前的工作通过改进模型的泛化能力来解决这个问题，假设即使在新的事件爆发之后，模型也会保持不变。</p><p>在这项工作中，提出了一种解决方案，以根据谣言域创建的动态不断更新模型。</p><p>与这种新方法相关的最大技术挑战是由于新的学习而灾难性地忘记了以前的学习。</p><p>作者采用持续学习策略来控制新的学习，以避免灾难性的遗忘，并提出了一种可以联合使用的额外策略来加强遗忘的缓解。</p><p>谣言检测任务两个重要难点：</p><ul><li><p>处理没见过的谣言的能力 (处理训练阶段未见的新谣言)</p></li><li><p>谣言早发现</p></li></ul><p>此前的方法试图通过关注静态设置中的模型泛化通用性来解决这一挑战，如下图a。目标是提高模型$M<em>{\theta</em>{t=1}}$ 在不更新模型的情况下，在看不见的话题领域(“古尔利特”和“普京失踪”)上表现好。然而，增强模型的泛化能力是一个困难的问题，特别是对于总是引入新主题和词汇的任务。</p><p><img src="https://i.loli.net/2021/09/07/yUqli7RJVG489HX.png" alt=""></p><p>因此，作为另一种解决方案，通过训练一个能够不断适应新出现的谣言的分类器，在动态设置中对未见过谣言进行分类。如上图b。</p><p>通过这种方式，可以及时发现虚假谣言，而不必考虑可见谣言和不可见谣言之间的巨大分布差距。</p><p>持续学习想解决的主要挑战是在学习新的Domain时灾难性地忘记以前学习的Domain。</p><p>这篇文章作者采用了基于排练的(rehearsal- based)持续学习(CL)策略，利用以前遇到的领域的情景记忆来约束未来的学习，并提出了一种简单的技术TTOKENS，可以联合使用来进一步减少灾难性遗忘。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="Task-Definition"><a href="#Task-Definition" class="headerlink" title="Task Definition"></a>Task Definition</h3><p>谣言真实性分类是识别给定谣言文本 $X$ 是真、假还是无法核实的任务。</p><p>谣言数据集及其对应的标签为集合 $D = {(X_i,y_i,Rm)}_i^N$ 其中 $y\in{True, False,Unverifiabel}$</p><p>RM是谣言域标签，N是数据集的大小。</p><p>主要目标是训练一个谣言真实性分类模型M，该模型可以从传言领域流中学习，通过时间t而不会发生灾难性的遗忘。 </p><p>将谣言域流定义为 $S={D_1,···,D_T}$，其中 $D_t$ 表示流中第 $t$ 个谣言域的数据集，$T$ 是流的长度。</p><p>T也等于时间戳的长度和谣言域的数量。</p><p>在每个时间戳，使用一个新的谣言域数据集 $D<em>t$ 来顺序训练模型 $M$，并用时间 $k$ 处的谣言域表示训练后的模型参数，$θ</em>{t=k}$。</p><h3 id="Base-Model"><a href="#Base-Model" class="headerlink" title="Base Model"></a>Base Model</h3><p>BERT-BASE 编码器和一个分类层。给定输入谣言 $X=x_1,···,x_m$，该模型计算：</p><script type="math/tex; mode=display">H= BERT([CLS] +X)</script><script type="math/tex; mode=display">P(y|X) = Softmax(WH_{[CLS]}+b)</script><p>$H_{[cls]}$是 $[cls]$ 标记的嵌入,可训练参数为 $θ=[W，b]$ </p><p>在训练期间，冻结编码层，并且仅使用交叉熵损失来训练分类器参数θ：</p><script type="math/tex; mode=display">L_{\theta_t}(D_t) = -\sum_j^{D_t}log P(y|X)</script><h3 id="Rehearsal-based-CL-Strategies"><a href="#Rehearsal-based-CL-Strategies" class="headerlink" title="Rehearsal-based CL Strategies"></a>Rehearsal-based CL Strategies</h3><p>基于排练的CL策略依赖于“episodic memory” $M$ 来存储先前遇到的样本。$M$ 被定期重播，以避免灾难性遗忘，并加强过去知识和新知识之间的联系。</p><h4 id="REPLAY-Robins-1995"><a href="#REPLAY-Robins-1995" class="headerlink" title="REPLAY (Robins, 1995)"></a>REPLAY (Robins, 1995)</h4><p>CL的Memory M的一个简单利用是扩展当前任务数据 $D<em>t$，并使用 $L</em>{θ_t}(D_t+M)$来优化模型的参数。基本上，它可以被视为一个数据效率高的多任务框架，它只利用受Memory M大小限制的数据集的一小部分。</p><h4 id="Gradient-Episodic-Memory-GEM-Lopez-Paz-and-Ranzato-2017"><a href="#Gradient-Episodic-Memory-GEM-Lopez-Paz-and-Ranzato-2017" class="headerlink" title="Gradient Episodic Memory (GEM) (Lopez- Paz and Ranzato, 2017)"></a>Gradient Episodic Memory (GEM) (Lopez- Paz and Ranzato, 2017)</h4><p>另一种利用方法是使用当前域样本来约束梯度更新，使得Memory M中的样本的损失永远不会增加：</p><script type="math/tex; mode=display">L_{\theta_t} s.t. L_{\theta_t}(M) \le L_{\theta_{t-1}} (M)</script><p>GEM通过随模型参数数量变化的二次规划求解器计算梯度约束。</p><h3 id="Task-Specific-Tokens-TTOKENS"><a href="#Task-Specific-Tokens-TTOKENS" class="headerlink" title="Task-Specific Tokens (TTOKENS)"></a>Task-Specific Tokens (TTOKENS)</h3><p>各种工作表明，对大型预训练语言模型的输入上下文对模型的结果有巨大影响。换句话说，可以利用LM/MLM的这种上下文相关特性来有意地控制/区分不同域的表示。为了应用该策略，对输入文本 $X$ 进行预处理以从其对应的谣言域标签 Rm开始。形式上，给定第 $t$ 传言域Rm：</p><script type="math/tex; mode=display">H = BERT([CLS] + Rm + X)</script><p>该策略可以很容易地与其他CL策略一起使用，因为它是在数据处理步骤中完成的。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>数据集PHEME的一个显著特点是根据谣言事件进行分类。总共有9个不同的事件/域，更多详细信息如表1所示。</p><p><img src="https://i.loli.net/2021/09/07/eyQsigEztvZm8Bf.png" alt=""></p><p>以前的工作在静态设置中利用了这个数据集，其中8个域被组合成一个训练集，剩下的1个域用作单个不可见的测试域。在这项工作中，本文的任务是在动态设置中进行的。为了与动态设置结合，将PHEME的每个域视为单独的特定于域的数据集$D_T$，并以0.4/0.1/0.5的比率将它们拆分为Train/dev/test。</p><h3 id="Evaluation-Method"><a href="#Evaluation-Method" class="headerlink" title="Evaluation Method"></a>Evaluation Method</h3><p>在完成对第k个领域的学习后，对其在所有T领域测试集上的测试性能进行了评估。</p><p>这一步的结果是矩阵 $R \in \mathbf{R}^{T×T}$，其中 $R_{i,j}$ 是在观察到来自第 $i$ 域的最后一个样本之后，模型在第 $j$ 域上的测试分类精度。</p><p>基于此矩阵，计算了两个特定于CL的度量：</p><ul><li>Avg. Accuracy (ACC) 对于了解模型在学习新领域时性能如何变化很有用。此指标的计算方法如下：</li></ul><script type="math/tex; mode=display">ACC = \frac {1}{T}\sum_{i=1}^T R_{T,i}</script><p>请注意，在流的末尾，t=9，即Avg. Accuracy (ACC) 正好是所有任务的平均精确度。</p><ul><li>Backward Transfer (BWT) 是一种用于测量新学习任务对先前学习任务影响的CL方法。此指标的计算公式为：</li></ul><script type="math/tex; mode=display">BWT = \frac{1}{T-1} \sum_{i=1}^{T-1} R_{T,i} - R_{i,i}</script><p>负的BWT表明模型灾难性地忘记了以前的任务。</p><h3 id="model"><a href="#model" class="headerlink" title="model"></a>model</h3><p>两个没有CL策略的基线模型，并在我们的动态设置中进行了评估。BERT-BL是指在PHEME数据集上微调的BERT基础模型。M2-BL是指对统一错误信息表示进行微调的另一个基线，该基线被证明能有效提高未发现领域的泛化性。</p><p><img src="https://i.loli.net/2021/09/07/Xcvu63ni5SpVJoQ.png" alt=""></p><p>对于作者提出的模型，作者用上文提到的CL策略的各种组合来训练基于BERT的分类器，以评估所采用的策略在对不可见领域的鲁棒性方面的有效性。</p><p><img src="https://i.loli.net/2021/09/07/PUig5Oe9qcIFbjR.png" alt=""></p><p>模型性能随时间变化的可视化分析。用于Replay的ACC热力图(A)没有TTOKENS和(B)有TTOKENS。比较(A)和(B)之间的每一列，使用TTO-KENS的(B)列通常显示较深的阴影，这代表更好的性能。</p><p>对于TTOKENS成功背后的推理，作者有两个假设：1）TTOKENS隐含地充当了领域差异的信号，并鼓励模型为每个领域学习单独的知识。或者，2）TTOKENS作为一个良好的开端“上下文”，帮助基于LM的编码器在必要时将输入编码为更可分离的——这意味着，来自相同域的输入在向量空间中比来自不同域的输入更接近。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Dynamically-Addressing-Unseen-Rumor-via-Continual-Learning&quot;&gt;&lt;a href=&quot;#Dynamically-Addressing-Unseen-Rumor-via-Continual-Learning&quot; cl</summary>
      
    
    
    
    
    <category term="context detection" scheme="http://example.com/tags/context-detection/"/>
    
  </entry>
  
  <entry>
    <title>Rumor Detection on Social Media with Bi-Directional Graph Convolutional Networks</title>
    <link href="http://example.com/2021/09/04/Rumor-Detection-on-Social-Media-with-Bi-Directional-Graph-Convolutional-Networks/"/>
    <id>http://example.com/2021/09/04/Rumor-Detection-on-Social-Media-with-Bi-Directional-Graph-Convolutional-Networks/</id>
    <published>2021-09-04T10:54:37.000Z</published>
    <updated>2021-09-06T07:12:00.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rumor-Detection-on-Social-Media-with-Bi-Directional-Graph-Convolutional-Networks"><a href="#Rumor-Detection-on-Social-Media-with-Bi-Directional-Graph-Convolutional-Networks" class="headerlink" title="Rumor Detection on Social Media with Bi-Directional Graph Convolutional Networks"></a>Rumor Detection on Social Media with Bi-Directional Graph Convolutional Networks</h1><p><a href="https://github.com/TianBian95/BiGCN">https://github.com/TianBian95/BiGCN</a></p><p>从社交媒体上如此海量的信息中识别谣言正成为一项艰巨的挑战。</p><p>一些深度学习方法被应用于通过谣言传播的方式来发现谣言，如递归神经网络(RvNN)等。然而，这些深度学习方法只考虑了深度传播的特点，而忽略了谣言检测中广泛分散的结构。</p><p>实际上，propagation(传播)和dispersion(扩散)是谣言的两个关键特征。</p><p>作者提出一种新的双向图模型，称为双向图卷积网络(Bi-GCN)，通过对谣言的自上而下和自下而上的传播进行操作，来探索这两个特性。</p><ul><li>利用具有自上而下谣言传播有向图的GCN来学习谣言传播模式</li><li>具有相反方向的谣言扩散图，以捕获谣言扩散的结构</li></ul><p>此外，来自消息来源的信息涉及到GCN的每一层，以增强谣言根源的影响力。</p><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><h3 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h3><p>传统的检测方法主要采用用户特征、文本内容和传播模式等手工制作的特征来训练监督分类器，例如：Decision Tree、 Random Forest、Support Vector Machine (SVM)。</p><p>一些研究应用了有效的特征，如用户评论、时间结构特征，以及帖子的情感态度。</p><p>然而，这些方法主要依赖于特征工程，非常耗时费力。此外，这些手工制作的特征通常缺乏从谣言的传播和扩散中提取的高层次表示。</p><h3 id="深度学习方法"><a href="#深度学习方法" class="headerlink" title="深度学习方法"></a>深度学习方法</h3><p>最近的研究已经利用从传播路径/树或网络中挖掘高层表示的深度学习方法来识别谣言。也就是深度学习方法：</p><h4 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h4><p>长短期记忆(LSTM)、门控递归单元(GRU)和递归神经网络(RvNN)，因为他们能够从随着时间的谣言传播中学习序列特征。</p><p>然而，这些方法在效率上有很大的局限性，因为时间结构特征只关注谣言的顺序传播，而忽略了谣言散布的影响。</p><h4 id="CNN"><a href="#CNN" class="headerlink" title="CNN"></a>CNN</h4><p>谣言传播的结构也表明了谣言的某些传播行为。因此，一些研究试图通过引用基于卷积神经网络(CNN)的方法来涉及谣言传播结构中的信息。基于CNN的方法可以获得局部邻域内的相关特征，但不能处理图或树中全局结构关系。因此，这些方法忽略了谣言传播的全局结构特征。实际上，CNN不是为从结构化数据中学习高级表示而设计的，但图形卷积网络(GCN)是。</p><h3 id="GNN"><a href="#GNN" class="headerlink" title="GNN"></a>GNN</h3><p>GCN，或称为无向GCN(UD-GCN)，只聚合依赖于相关帖子之间的关系的信息，而丢失了以下内容的顺序。</p><p>虽然UD-GCN具有处理谣言传播的全局性结构特征的能力(其实传统基于消息传递的GNN只是局部特征)，但它没有考虑谣言传播的方向，但这已被证明是谣言检测的重要线索。</p><p>具体而言，沿着关系链的深度传播和在社区的广泛扩散是谣言的两个主要特征。</p><p>为了同时处理谣言的传播和扩散，本文提出了一种新的双向GCN(Bi-GCN)，它同时适用于谣言的自上而下和自下而上的传播。</p><p><img src="https://i.loli.net/2021/09/05/cs9LYDfpmCzixIV.png" alt=""></p><p>Top-Down graph convolutional Networks (TD-GCN)         /     Bottom-Up graph convolutional Networks (BU-GCN)</p><p>TD-GCN从谣言树中节点的父节点获取信息来制定谣言传播，而BU-GCN从树中节点的子节点收集信息来表示谣言的散布。</p><p>Detect rumors on twitter by promoting information campaigns with generative adversarial learning.采用对抗性学习方法来提高谣言分类器的性能，其中鉴别器用作分类器，相应的生成器通过产生冲突噪声来改进鉴别器。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h3><p>$C = {c_1,c_2,…,c_m}$ 为数据集，$c_i$ 是第 $i$ 个事件，$m$是事件的数量。</p><p>$c<em>i = {r_i,w_1^i,…,w</em>{n_i-1}^i,G_i}$ , $n_i$ 是事件$c_i$中帖子的数量，$r_i$是源帖子，每个$w_j^i$代表第$j$个相关回应帖子, $G_i$ 指的是传播结构。$ G_i$定义为 $⟨V_i，E_i⟩$其中 $r_i$是根节点</p><p>类别标签${N,F,T,U}$ (Non-rumor, False Rumor, True Rumor, and Unverified Rumor)</p><h3 id="DropEdge"><a href="#DropEdge" class="headerlink" title="DropEdge"></a>DropEdge</h3><p>DropEdge是一种减少基于GCN模型的过拟合的新方法。在每个训练周期内，随机地从输入图中剔除边，以一定的速率生成不同的变形副本。</p><p>因此，这种方法增加了输入数据的随机性和多样性，就像随机旋转或摆动图像一样。形式上，假设图 $A$ 中的边总数为$N_e$，dropping率为$p$，则DropEdge之后的邻接矩阵$A‘$计算如下：</p><script type="math/tex; mode=display">A' = A - A_{drop}</script><p>其中$A_{drop}$ 是$N_e\times p$ 随机采样原始边集合得到</p><h3 id="Bi-GCN-Rumor-Detection-Model"><a href="#Bi-GCN-Rumor-Detection-Model" class="headerlink" title="Bi-GCN Rumor Detection Model"></a>Bi-GCN Rumor Detection Model</h3><p><img src="https://i.loli.net/2021/09/06/YR7cEdVmlXPBwtb.png" alt=""></p><p>Bi-GCN的核心思想是从谣言传播和谣言扩散两个方面学习合适的高层表示。</p><p>在Bi-GCN模型中，采用两层1stChebNet作为基本的GCN组件。如图2所示，分4个步骤详细阐述了使用Bi-GCN进行谣言检测的过程。</p><p>首先讨论如何将Bi-GCN模型应用于一个事件，即第i个事件的$c_i→y_i$。其他事件的计算方式相同。为了更好地展示我们的方法，我们在下面的内容中省略了下标i。</p><h4 id="1-Construct-Propagation-and-Dispersion-Graphs"><a href="#1-Construct-Propagation-and-Dispersion-Graphs" class="headerlink" title="1 Construct Propagation and Dispersion Graphs"></a>1 Construct Propagation and Dispersion Graphs</h4><p>基于转发和回复关系，我们构造了传播结构 $⟨V, E⟩$ 对于谣言事件。</p><p>然后，设 $A\in R^{n_i×n_i}$和 $X$ 分别为其对应的基于谣言传播树$c_i$的邻接矩阵和特征矩阵。</p><p>$A$ 经过drop变成$A’$ ,基于$A’$ 和 $X$ ，我们可以建立我们的Bi-GCN模型。我们的Bi-GCN由两个组件组成：</p><p> Top-Down Graph Convolutional Network (TD- GCN)</p><p>Bottom-Up Graph Convolutional Network (BU- GCN)</p><p>两个分量的邻接矩阵是不同的</p><p>TD-GCN中，$A^{TD}=A’$  , 对于BU-GCN，邻接矩阵为 $A^{BU}=A’^⊤$。TD-GCN和BU-GCN采用相同的特征矩阵X。</p><h4 id="2-Calculate-the-High-level-Node-Representations"><a href="#2-Calculate-the-High-level-Node-Representations" class="headerlink" title="2 Calculate the High-level Node Representations"></a>2 Calculate the High-level Node Representations</h4><p>TD-GCN经过两层图卷积:</p><script type="math/tex; mode=display">H_1^{TD} = \sigma(\hat A^{TD}XW_0^{TD})</script><script type="math/tex; mode=display">H_2^{TD} = \sigma(\hat A^{TD}H_1^{TD}W_1^{TD})</script><p>BU-GCN相同</p><h4 id="3-Root-Feature-Enhancement"><a href="#3-Root-Feature-Enhancement" class="headerlink" title="3 Root Feature Enhancement"></a>3 Root Feature Enhancement</h4><p>众所周知，谣言事件的来源帖子总是信息丰富，影响广泛。要更好地利用源帖信息，从节点与源帖的关系中学习更准确的节点表示。</p><p>对于第k个GCL处的TD-GCN，我们将每个节点的隐藏特征向量与来自第(k−1)个GCL的根节点的隐藏特征向量连接起来，以构造新的特征矩阵</p><script type="math/tex; mode=display">\hat H_k^{TD} = concat(H_k^{TD},(H_{k-1}^{TD})^{root})</script><p>其中$H_0^{TD}=X$</p><h4 id="4-Representations-of-Propagation-and-Dispersion-for-Rumor-Classification"><a href="#4-Representations-of-Propagation-and-Dispersion-for-Rumor-Classification" class="headerlink" title="4 Representations of Propagation and Dispersion for Rumor Classification"></a>4 Representations of Propagation and Dispersion for Rumor Classification</h4><p>传播表示和扩散表示分别由TD-GCN和BU-GCN的节点表示聚合而成。</p><p>在这里，我们使用均值合并算子来聚集来自这两组节点表示的信息。它的公式是</p><script type="math/tex; mode=display">S^{TD} = MEAN(\hat H_2^{TD})</script><script type="math/tex; mode=display">S^{BU} = MEAN(\hat H_2^{BU})</script><p>然后，我们将传播的表示和扩散的表示连接起来，将信息合并为</p><script type="math/tex; mode=display">S=concat(S^{TD},S^{BU})</script><p>最后，事件ˆy的标签通过几个全连接层和SoftMax层：</p><script type="math/tex; mode=display">\hat y = Softmax(FC(S))</script><p>$\hat y \in R^{1\times C}$</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p><img src="https://z3.ax1x.com/2021/09/06/hhosuq.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/09/06/hhTFIS.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/09/06/hhTQaT.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Rumor-Detection-on-Social-Media-with-Bi-Directional-Graph-Convolutional-Networks&quot;&gt;&lt;a href=&quot;#Rumor-Detection-on-Social-Media-with-Bi-</summary>
      
    
    
    
    
    <category term="context detection" scheme="http://example.com/tags/context-detection/"/>
    
  </entry>
  
  <entry>
    <title>Interpretable Rumor Detection in Microblogs by Attending to User Interactions</title>
    <link href="http://example.com/2021/09/04/Interpretable-Rumor-Detection-in-Microblogs-by-Attending-to-User-Interactions/"/>
    <id>http://example.com/2021/09/04/Interpretable-Rumor-Detection-in-Microblogs-by-Attending-to-User-Interactions/</id>
    <published>2021-09-04T10:52:02.000Z</published>
    <updated>2021-09-05T03:10:18.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Interpretable-Rumor-Detection-in-Microblogs-by-Attending-to-User-Interactions"><a href="#Interpretable-Rumor-Detection-in-Microblogs-by-Attending-to-User-Interactions" class="headerlink" title="Interpretable Rumor Detection in Microblogs by Attending to User Interactions"></a>Interpretable Rumor Detection in Microblogs by Attending to User Interactions</h1><p><a href="https://github.com/serenaklm/rumor_detection">https://github.com/serenaklm/rumor_detection</a></p><p>通过学习区分社区对微博中真假claim的响应来解决谣言检测问题。</p><p>现有最先进的模型是基于对会话树建模的树模型。然而，在社交媒体中，发布回复的用户可能是对整个thread的回复，而不是对特定用户的回复。</p><p>提出Multi-head post-level attention模型(PLAN)来构建推文之间的远距离交互。并提出几个变体：</p><ul><li>结构感知自注意模型(StA-PLAN)，将树形结构信息合并到Transformer中</li><li>分层token和post-leve attention(StA-HiTPLAN), 通过token-level 自注意力学习句子表征</li></ul><p>这篇工作重点是利用社区对虚假claim的响应来检测虚假索赔。这一研究领域通过将自然语言处理应用于针对claim的评论来利用社区的集体智慧。这些工作背后的关键原则是，社交媒体上的用户会分享对不准确信息的看法、猜测和证据。</p><h2 id="样本"><a href="#样本" class="headerlink" title="样本"></a>样本</h2><p><img src="https://i.loli.net/2021/09/04/FwWU2TKkf1Ji5B3.png" alt=""></p><p>源贴：“沃尔玛捐赠1万美元支持达伦·威尔逊和正在进行的种族主义警察谋杀案#弗格森#抵制沃尔玛URL”。</p><p>推特R_1及其回复推文R_1_1对消息来源的真实性表示怀疑。</p><p>推特R_2_1和R_3_1提供了确凿的证据，揭穿了消息来源的说法是假的。</p><p>虽然R_2_1和R_3_1分别是R_2和R_3的子节点，但它们可以为树上的所有其他节点(如R_1_1和R_1)提供重要信息。</p><p>因此，应该考虑所有tweet之间的互动，而不仅仅是父节点和他们的孩子节点之间的互动。</p><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>两篇使用树形结构进行建模的sota对社交媒体中谣言检测有限制。</p><p>Rumor detection on twitter with tree-structured recursive neural networks(2018) ，将来源claim及其回复推文组织成树形结构，使用递归神经网络对传播树中的信息传播进行建模。来自不同节点的信号以自下而上或自上而下的方式进行粗略地重新聚合。在自下而上的模型中，信息从子节点传播到父节点，在自上而下的模型中，信息从父节点传播到子节点，反之亦然。</p><p>Tree lstms with convolution units to predict stance and rumor veracity in social media conver- sations.(2019) ，组织了树状结构的对话线程，并探索了用于谣言检测的branch和tree LSTM的几种变体。</p><p>这两篇论文都使用了树模型，目的是对会话线索中存在的结构信息进行建模。在树模型中，信息从父级传播到子级，反之亦然。然而，社交媒体对话中的线索结构有所不同，每个用户通常能够观察到对话的不同分支中的所有回复。揭穿假新闻的用户不能只针对他回复的人创建的内容也可能适用于该帖子中的其他推文。树模型不会对来自其他分支的节点之间的交互进行显式建模，这是对社交媒体会话建模时的一个关键限制。</p><p>自动区分真假Claims的现有方法利用了各种特征：</p><ul><li>Claims的内容</li><li>Claims来源的重点考虑和社交网络</li><li>使用可信来源(例如，维基百科)进行事实核查</li><li>社区对Claims的反应。</li></ul><p>这篇重点在社区响应，接下来展开介绍介绍。</p><h3 id="Content-Information"><a href="#Content-Information" class="headerlink" title="Content Information"></a>Content Information</h3><p>早期关于欺骗性内容检测的工作研究了语言线索的使用，例如代词的百分比、词长、动词数量和词类。也有工作对关于虚假的评论，目击者的陈述，和讽刺。利用语言特征对假新闻的检测也进行了研究。这种对概念内容的分析依赖于可能是领域或主题所独有的语言特征。</p><h3 id="Source-and-Social-Network"><a href="#Source-and-Social-Network" class="headerlink" title="Source and Social Network"></a>Source and Social Network</h3><p>研究假新闻的来源及其社交网络，在内容中加入来源信息提高了假新闻分类准确率。为传播假新闻而创建的账户往往具有不同的社交网络特征。</p><h3 id="Fact-Checking"><a href="#Fact-Checking" class="headerlink" title="Fact Checking"></a>Fact Checking</h3><p>事实核查网站，如PolitiFact。com和snopes.com依靠人工验证来揭穿假新闻，但无法匹配假新闻的生成速度(Funke 2019)。自动事实核查旨在对照诸如维基百科(Ciampaglia et al.2015年)。</p><p>最近，索恩等人(2018)提出了FEVER共享任务，针对包含500万维基百科文档的数据库验证输入Claim，并将每个Claim分为三类：支持、驳斥或信息不足。</p><p>事实核查是一种更有原则的假新闻检测方法。然而，它也需要建立一个经过核实的事实语料库，而且可能不适用于证据很少的新Claim。</p><h3 id="Community-Response"><a href="#Community-Response" class="headerlink" title="Community Response"></a>Community Response</h3><p>研究人员致力于通过构建分类器来自动预测claim的有效性，分类器利用对社交媒体帖子的评论和回复，以及传播模式。</p><p>Ma(2018a)采用多任务学习方法构建了一个学习立场感知特征的分类器用于谣言检测。</p><p>Li (2019)对他的模型采用了多任务学习方法，并在他的模型中包括了用户信息。</p><p>Chen(2017)提出汇集截然不同的特征，以捕捉帖子随时间的上下文变化。</p><p>除了语言特征，其他研究人员也关注了用户的人口统计或交互预测来确定用户的可信度。</p><p>Yang(2012)收集了从事传播假新闻的用户特征，通过对传播路径进行分类，仅利用用户特征构建了假新闻检测器</p><p>Li(2019)使用用户信息和内容特征相结合的方式训练具有多任务学习目标的LSTM。</p><p>在本文中，仅从帖子和评论两个方面来检测谣言和假新闻。提出了一种用于谣言检测的Transformer，而不是递归树模型。</p><h2 id="任务定义"><a href="#任务定义" class="headerlink" title="任务定义"></a>任务定义</h2><p>问题陈述，将每个线程thread定义为：</p><script type="math/tex; mode=display">X = \{x_1,x_2,...,x_n\}</script><p>其中$x_1$是源tweet，$x_i$是按时间顺序排列的第 $i$ 条tweet，$n$是线程中的tweet数量。</p><p>会话树中除了文本信息外，还有可以利用的结构信息。在树形结构模型中，如果$x_i$对$x_j$进行应答，反之亦然，则只对Twitter $x_i$和$x_j$进行关联。</p><p>本文模型允许任何帖子关注同一主题中的任何其他帖子。</p><p>在提出的结构感知模型中，用关系标签来标记任何一对推文 $x_i$ 和 $x_j$之间的关系 $R(i,j)\in {\text{parent, child, before, after, self}}$ 。$R(i，j)$ 的值是通过依次应用以下规则集来获得的：</p><ul><li>parent：如果 $x_i$ 直接回复 $x_j$</li><li>child：如果 $x_j$ 直接回复 $x_i$</li><li>before：如果 $x_i$ 在 $x_j$之前到来</li><li>after：如果 $x_i$ 在 $x_j$之后</li><li>self：如果i=j</li></ul><p>谣言检测任务简化为学习预测每个$(X，R)$到其谣言类别 $y$。</p><p>在两个谣言检测数据集上进行了实验，即Twitter15和Twitter16数据，以及PHEME 5数据。</p><p>对于我们正在处理的数据集，分类标签是不同的：</p><ul><li>Twitter15 and Twitter16：$y\in {\text{non-rumor, false-rumor, true-rumor, unverified}}$</li><li>PHEME: $y\in {\text{false-rumor, true-rumor, unverified}}$</li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>然而，正如我们将在下表中的数据统计中看到的那样，数据集中的树非常浅，大部分评论直接回复源tweet，而不是回复其他tweet。</p><p><img src="https://i.loli.net/2021/09/05/2RAGI9fpbJ5D387.png" alt=""></p><p>我们发现，在社交媒体中，由于整个帖子通常都是可见的，回复根帖子的用户可能会继续与更活跃的用户进行对话，而不是专门为根帖子撰写回复。因此，在对社交媒体对话进行建模时，没有对推文之间的每一种可能的成对交互进行显式建模的树模型是次优的，所以用Transformer-based模型。</p><h3 id="Post-Level-Attention-Network-PLAN"><a href="#Post-Level-Attention-Network-PLAN" class="headerlink" title="Post-Level Attention Network (PLAN)"></a>Post-Level Attention Network (PLAN)</h3><p><img src="https://i.loli.net/2021/09/05/aq5MoQL1iACXujd.png" alt=""></p><p>首先将对话树的结构展平，并将推文按时间顺序排列成直线结构，源推文作为第一条推文。对于我们的计划模型，我们在线性结构中对每个推文 $x_i$ 应用最大池化来获得它的句子表示 $x_i$。</p><p>然后传递一个句子嵌入序列 $X’ = (x_1’,x_2’,…,x_n’)$  通过s个数的多头注意力(MHA)层来模拟推文之间的交互。</p><p>我们将这些MHA层称为post-level attention层。因此，这将改变 $X’ =(x_1’,x_2’,…,x_n’)$ 为 $U=(u_1,u_2,…,u_n)$</p><p>最后，使用注意力机制对推文进行插值，然后通过一个全连接层进行预测。</p><h3 id="Structure-Aware-Post-Level-Attention-Network-StA-PLAN"><a href="#Structure-Aware-Post-Level-Attention-Network-StA-PLAN" class="headerlink" title="Structure Aware Post-Level Attention Network (StA-PLAN)"></a>Structure Aware Post-Level Attention Network (StA-PLAN)</h3><p>模型的一个可能的局限性是，我们通过以线性结构组织推文来丢失结构信息。转换树中固有存在的结构化信息对于假新闻检测可能仍然有用。</p><p>树模型在这方面更优越，因为结构信息是显式建模的。为了将树模型的优点和自我注意机制结合起来，对计划模型进行了扩展，使其显式地包含了结构信息。</p><script type="math/tex; mode=display">\alpha_{ij} = softmax(\frac{q_ik_j^T+a_{ij}^K}{\sqrt{d_k}})</script><script type="math/tex; mode=display">z_i = \sum_{j=1}^n\alpha_{ij}(v_j+a_{ij}^V)</script><p>$a^V<em>{ij}$ 和 $a^K</em>{ij}$ 都是代表tweet对之间五种可能的结构关系(即parent, child, before, after, self)之一的向量</p><h3 id="Structure-Aware-Hierarchical-Token-and-Post-Level-Attention-Network-StA-HiTPLAN"><a href="#Structure-Aware-Hierarchical-Token-and-Post-Level-Attention-Network-StA-HiTPLAN" class="headerlink" title="Structure Aware Hierarchical Token and Post-Level Attention Network (StA-HiTPLAN)"></a>Structure Aware Hierarchical Token and Post-Level Attention Network (StA-HiTPLAN)</h3><p><img src="https://i.loli.net/2021/09/05/Cx2RNBdOwAUcMI1.png" alt=""></p><p>PLAN模型执行最大池化，以获得每条推文的句子表示。</p><p>然而，让模型学习单词向量的重要性可能会更理想。因此，提出了一种分层的注意模型—token-level的注意和post-level的注意力。分层模型的概述如图所示。</p><p>在使用注意机制插入输出之前，我们执行token-level自注意力，而不是使用最大池化来获得句子表示。</p><p>每条推文可以表示为一系列单词记号$x<em>i=(x</em>{i,1}，x<em>{i,2}，…，x</em>{i,|xi|})$。我们在一条推文中通过MHA层传递了单词token的序列。这允许tweet中的token之间进行交互，将这些层称为token-level关注层。</p><h3 id="Time-Delay-Embedding"><a href="#Time-Delay-Embedding" class="headerlink" title="Time Delay Embedding"></a>Time Delay Embedding</h3><p>在不同的时间间隔创建的推文可以有不同的解释。首次创建源claim时表示不相信的推文可能很常见，因为claim可能尚未经过验证。然而，在传播的后期阶段，可疑的推文可能表明消息来源的说法是假的倾向很高。</p><p>因此，提出的三个模型PLAN、STA-PLAN和STA-HiTPLAN研究了带有时延信息的Tweet编码的实用性。</p><p>为了包括每个tweet的时间延迟信息，根据从源tweet创建时起的延迟将tweet绑定。</p><p>将时间箱的总数设置为100，每个箱代表10分钟的间隔。延迟超过1000分钟的推文将落入最后一个时间段。</p><script type="math/tex; mode=display">TDE_{pos,2i} = sin\frac{pos}{10000^{2i/d_model}}</script><script type="math/tex; mode=display">TDE_{pos,2i+1} = cos\frac{pos}{10000^{2i/d_model}}</script><p>其中pos表达为时间bin，$pos\in[0,100)$</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><p><img src="https://i.loli.net/2021/09/05/2RAGI9fpbJ5D387.png" alt=""></p><p><img src="https://i.loli.net/2021/09/05/MUWvDm5j36NYksw.png" alt=""></p><ul><li>Twitter15 and Twitter16 ：对于Twitter15和Twitter16的数据集，每个声明中都有很大比例的转发：Twit-15和Twitter16分别为89%和90%。因为作者假设转发不会给模型带来新信息，所以删除了Twitter15和Twitter16的所有转发。在删除转发后，观察到少数索赔将只剩下来源Claim。既然作者的方法背后的原则是，我们可以利用人群的信号来侦测谣言，那么没有任何回复的说法就应该是“未经核实的(unverified)”。因此，在训练数据中修改了这类说法的标签为“未经证实”</li></ul><p><img src="https://i.loli.net/2021/09/05/vaNkVL2UIAhD4n1.png" alt=""></p><p><img src="https://i.loli.net/2021/09/05/7riuNwZBWUvxjE6.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Interpretable-Rumor-Detection-in-Microblogs-by-Attending-to-User-Interactions&quot;&gt;&lt;a href=&quot;#Interpretable-Rumor-Detection-in-Microblogs</summary>
      
    
    
    
    
    <category term="context detection" scheme="http://example.com/tags/context-detection/"/>
    
  </entry>
  
  <entry>
    <title>Dice Loss for Data-imbalanced NLP Tasks</title>
    <link href="http://example.com/2021/09/01/Dice-Loss-for-Data-imbalanced-NLP-Tasks/"/>
    <id>http://example.com/2021/09/01/Dice-Loss-for-Data-imbalanced-NLP-Tasks/</id>
    <published>2021-09-01T07:37:09.000Z</published>
    <updated>2021-09-01T12:54:41.077Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dice-Loss-for-Data-imbalanced-NLP-Tasks"><a href="#Dice-Loss-for-Data-imbalanced-NLP-Tasks" class="headerlink" title="Dice Loss for Data-imbalanced NLP Tasks"></a>Dice Loss for Data-imbalanced NLP Tasks</h1><p>许多自然语言处理任务，如序列标注和机器阅读理解(MRC)，都面临着严重的数据失衡问题：</p><ul><li>负样本明显多于正样本，占据绝大多数的负例会支配模型的训练过程，导致模型倾向于负例，而测试时使用的F1指标需要每个类都能准确预测；</li><li>大量简单负例（easy-negative）使训练不堪重负。负例占绝大多数也意味着其中包含了很多简单样本，这些简单样本对于模型学习困难样本几乎没有帮助，反而会在交叉熵的作用下推动模型遗忘对困难样本的知识。</li></ul><p>loss中最常用的交叉熵实际上是以精度为导向的，这造成了训练和测试之间的差异。在训练时，每个训练样本对目标函数的贡献相等，而在测试时，F1 score更关注正例。</p><p>本文认为这种问题是交叉熵本身的特点带来的：交叉熵“平等”地看待每一个样本，无论正负，都尽力把它们推向1（正例）或0（负例）。但实际上，对分类而言，将一个样本分类为负只需要它的概率＜0.5即可，完全没有必要将它推向0。</p><p>基于这个观察，作者使用现有的Dice Loss，并提出一个基于Dice Loss的自适应损失——DSC，在训练时推动模型更加关注困难的样本，降低简单负例的学习度，从而在整体上提高基于F1值的效果。</p><h2 id="从Cross-Entropy-到-Dice-Losses"><a href="#从Cross-Entropy-到-Dice-Losses" class="headerlink" title="从Cross Entropy 到 Dice Losses"></a>从Cross Entropy 到 Dice Losses</h2><h3 id="交叉熵损失-CE"><a href="#交叉熵损失-CE" class="headerlink" title="交叉熵损失(CE)"></a>交叉熵损失(CE)</h3><p>以二分类作为说明，记输入为 $x$, 输出为一个二值概率 $p = [p_0,p_1]$, 并且有一个二元真值 $y = [y_0,y_1]$</p><p>首先交叉熵损失是：</p><script type="math/tex; mode=display">CE =  -(y_0log\ p_0 + y_1log \ p_1)</script><p>显然，对每个样本，CE都对它们一视同仁，不管当前样本是简单还是复杂。当简单样本有很多时，模型训练就会被这些简单的样本占据，使得模型难以从复杂样本中学习。于是，一种简单的改进方法是，降低模型在简单样本上的学习速率，从而得到下述加权交叉损失：</p><script type="math/tex; mode=display">Weighted \ CE = -\alpha(y_0log \ p_0+y_1log \ p_1)</script><p>对不同样本，我们可以设置不同的权重，从而控制模型在该样本上学习的程度。但是此时，权重的选择又变得比较困难。因为我们的目标是缓解数据集的不平衡问题，从而提高基于F1评测标准的效果，我们希望有一种损失函数能够直接作用于F1。</p><h3 id="Sorensen–Dice系数（DSC）"><a href="#Sorensen–Dice系数（DSC）" class="headerlink" title="Sørensen–Dice系数（DSC）"></a>Sørensen–Dice系数（DSC）</h3><p>一种现有的方法——Sørensen–Dice系数（简称DSC）——去衡量F1。</p><p>DSC是一种用于衡量两个集合之间相似度的指标：</p><script type="math/tex; mode=display">DSC(A,B) = \frac{2|A\cap B|}{|A|+|B|}</script><script type="math/tex; mode=display">F1 = \frac{2(precision*recall)}{precision+recall}</script><script type="math/tex; mode=display">A = precision = \frac{TP}{TP+FP} ,  B = recall =\frac{TP}{TP+FN}</script><p>如果我们令A是所有模型预测为正的样本的集合，令B是所有实际上为正的样本集合，那么DSC就可以重写为：</p><script type="math/tex; mode=display">DSC(D,f) = \frac{2TP}{2TP+FN+FP}=F1</script><p>其中D数据集，f是一个分类模型。于是在这个意义上DSC与F1是等价的。</p><p>既然如此，就直接优化DSC，然而上述表达式是离散的，为此，需要把上述DSC表达式转化为连续的版本，从而可以视作一种soft F1。</p><p>对于单个样本x，直接定义它的DSC：</p><script type="math/tex; mode=display">DSC(x,f) = \frac{2p_1y_1}{p_1+y_1}</script><p>可以看到如果x是父类，那么它的DSC就为0，从而不会对训练有贡献。为了让父类也能有所贡献，所以增加一个平滑项：</p><script type="math/tex; mode=display">DSC_s(x,f) = \frac{2p_1y_1 + \epsilon}{p_1+y_1+\epsilon}</script><p>但这样一来，又需要我们根据不同的数据集手动地调整平滑项。而且当easy-negative样本很多的时候，即便使用上述平滑项，整个模型训练过程仍然会被它们主导。基于此，我们使用一种“自调节”的DSC（这里就和focal loss很像）：</p><script type="math/tex; mode=display">DSC(x,f) = \frac{2(1-p_1)p_1\cdot y_1 + \epsilon}{(1-p_1)p_1 + y_1 + \epsilon}</script><p>比较上面两个DSC，可以发现，$1-p_1$ 实际上充当了缩放系数，对于简单样本($p_1$ 趋向于1或0)，$(1-p_1)p_1$ 使得模型更少地去关注他们。</p><p>从导数上看，一旦模型正确分类当前样本（刚刚经过0.5），DSC就会使模型更少关注它，而不是像交叉熵那样，鼓励模型迫近0或1这两个点。这就能有效避免因简单样本过多导致模型训练受到简单样本的支配。</p><p>事实上，这比较类似Focal Loss(FL)，降低已分好类的样本的学习权重：</p><script type="math/tex; mode=display">FL = -(y_0(1-p_0)^\gamma log p_0 + y_1(1-p_1)^\gamma log p_1)</script><p>不过，FL即使能对简单样本降低学习权重，但它本质上仍然是在鼓励简单样本趋向于0或1，这就和DSC有了本质上的区别。因此，说DSC通过“平衡”简单样本和困难样本的学习过程，从而提高了最终的F1值（因为F1要求各类都有比较好的结果）</p><h3 id="Dice-Loss-DL-与Tversky-Loss-TL"><a href="#Dice-Loss-DL-与Tversky-Loss-TL" class="headerlink" title="Dice Loss(DL)与Tversky Loss(TL)"></a>Dice Loss(DL)与Tversky Loss(TL)</h3><p>除了上述DSC外，还比较了两种$DSC_s(x,f)$的变体，分别是Dice Loss（DL）和Tversky Loss（TL）：</p><script type="math/tex; mode=display">DL = 1 - \frac{2p_1y_1+\epsilon}{p_1^2+y_1^2+\epsilon}</script><script type="math/tex; mode=display">TL = 1-\frac{p_1y_1 + \epsilon}{p_1y_1+\alpha p_1y_0+\beta p_0y_1 + \epsilon}</script><p>在$\alpha=\beta=0.5$时，TL就退化为DSC。           </p><h3 id="损失总结"><a href="#损失总结" class="headerlink" title="损失总结"></a>损失总结</h3><p><img src="https://i.loli.net/2021/09/01/YkHOMIlVSPjG5aw.png" alt=""></p><p>后三个统称为Dice loss</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Dice-Loss-for-Data-imbalanced-NLP-Tasks&quot;&gt;&lt;a href=&quot;#Dice-Loss-for-Data-imbalanced-NLP-Tasks&quot; class=&quot;headerlink&quot; title=&quot;Dice Loss for </summary>
      
    
    
    
    
    <category term="nlp" scheme="http://example.com/tags/nlp/"/>
    
  </entry>
  
  <entry>
    <title>Edge-augmented Graph Transformers: Global Self-attention is Enough for Graphs</title>
    <link href="http://example.com/2021/08/29/Edge-augmented-Graph-Transformers-Global-Self-attention-is-Enough-for-Graphs/"/>
    <id>http://example.com/2021/08/29/Edge-augmented-Graph-Transformers-Global-Self-attention-is-Enough-for-Graphs/</id>
    <published>2021-08-29T08:32:53.000Z</published>
    <updated>2021-09-01T13:41:21.763Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Edge-augmented-Graph-Transformers-Global-Self-attention-is-Enough-for-Graphs"><a href="#Edge-augmented-Graph-Transformers-Global-Self-attention-is-Enough-for-Graphs" class="headerlink" title="Edge-augmented Graph Transformers: Global Self-attention is Enough for Graphs"></a>Edge-augmented Graph Transformers: Global Self-attention is Enough for Graphs</h1><p>—do_train —do_eval —train_batch_size 64 —num_train_epochs 50 —embeddings_learning_rate 0.7e-4 —encoder_learning_rate 0.7e-4 —classifier_learning_rate 7e-4 —warmup_steps 200 —max_seq_len 132 —dropout_rate 0.15 —metric_key_for_early_stop “macro avg<strong>f1-score</strong>level_2” —logging_steps 200 —patience 6 —label2freq_level_1_dir /data2/code/DaguanFengxian/bert_model/data/label2freq_level_1.json —label2freq_level_2_dir /data2/code/DaguanFengxian/bert_model/data/label2freq_level_2.json —processor_sep “\t” —loss_fct_name dice </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Edge-augmented-Graph-Transformers-Global-Self-attention-is-Enough-for-Graphs&quot;&gt;&lt;a href=&quot;#Edge-augmented-Graph-Transformers-Global-Sel</summary>
      
    
    
    
    
    <category term="GNN" scheme="http://example.com/tags/GNN/"/>
    
  </entry>
  
</feed>
